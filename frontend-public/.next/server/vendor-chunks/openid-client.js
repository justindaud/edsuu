"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/openid-client";
exports.ids = ["vendor-chunks/openid-client"];
exports.modules = {

/***/ "(rsc)/../node_modules/openid-client/lib/client.js":
/*!***************************************************!*\
  !*** ../node_modules/openid-client/lib/client.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { inspect } = __webpack_require__(/*! util */ \"util\");\nconst stdhttp = __webpack_require__(/*! http */ \"http\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst { strict: assert } = __webpack_require__(/*! assert */ \"assert\");\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst { URL, URLSearchParams } = __webpack_require__(/*! url */ \"url\");\nconst jose = __webpack_require__(/*! jose */ \"(rsc)/../node_modules/jose/dist/node/cjs/index.js\");\nconst tokenHash = __webpack_require__(/*! oidc-token-hash */ \"(rsc)/../node_modules/oidc-token-hash/lib/index.js\");\nconst isKeyObject = __webpack_require__(/*! ./helpers/is_key_object */ \"(rsc)/../node_modules/openid-client/lib/helpers/is_key_object.js\");\nconst decodeJWT = __webpack_require__(/*! ./helpers/decode_jwt */ \"(rsc)/../node_modules/openid-client/lib/helpers/decode_jwt.js\");\nconst base64url = __webpack_require__(/*! ./helpers/base64url */ \"(rsc)/../node_modules/openid-client/lib/helpers/base64url.js\");\nconst defaults = __webpack_require__(/*! ./helpers/defaults */ \"(rsc)/../node_modules/openid-client/lib/helpers/defaults.js\");\nconst parseWwwAuthenticate = __webpack_require__(/*! ./helpers/www_authenticate_parser */ \"(rsc)/../node_modules/openid-client/lib/helpers/www_authenticate_parser.js\");\nconst { assertSigningAlgValuesSupport, assertIssuerConfiguration } = __webpack_require__(/*! ./helpers/assert */ \"(rsc)/../node_modules/openid-client/lib/helpers/assert.js\");\nconst pick = __webpack_require__(/*! ./helpers/pick */ \"(rsc)/../node_modules/openid-client/lib/helpers/pick.js\");\nconst isPlainObject = __webpack_require__(/*! ./helpers/is_plain_object */ \"(rsc)/../node_modules/openid-client/lib/helpers/is_plain_object.js\");\nconst processResponse = __webpack_require__(/*! ./helpers/process_response */ \"(rsc)/../node_modules/openid-client/lib/helpers/process_response.js\");\nconst TokenSet = __webpack_require__(/*! ./token_set */ \"(rsc)/../node_modules/openid-client/lib/token_set.js\");\nconst { OPError, RPError } = __webpack_require__(/*! ./errors */ \"(rsc)/../node_modules/openid-client/lib/errors.js\");\nconst now = __webpack_require__(/*! ./helpers/unix_timestamp */ \"(rsc)/../node_modules/openid-client/lib/helpers/unix_timestamp.js\");\nconst { random } = __webpack_require__(/*! ./helpers/generators */ \"(rsc)/../node_modules/openid-client/lib/helpers/generators.js\");\nconst request = __webpack_require__(/*! ./helpers/request */ \"(rsc)/../node_modules/openid-client/lib/helpers/request.js\");\nconst { CLOCK_TOLERANCE } = __webpack_require__(/*! ./helpers/consts */ \"(rsc)/../node_modules/openid-client/lib/helpers/consts.js\");\nconst { keystores } = __webpack_require__(/*! ./helpers/weak_cache */ \"(rsc)/../node_modules/openid-client/lib/helpers/weak_cache.js\");\nconst KeyStore = __webpack_require__(/*! ./helpers/keystore */ \"(rsc)/../node_modules/openid-client/lib/helpers/keystore.js\");\nconst clone = __webpack_require__(/*! ./helpers/deep_clone */ \"(rsc)/../node_modules/openid-client/lib/helpers/deep_clone.js\");\nconst { authenticatedPost, resolveResponseType, resolveRedirectUri } = __webpack_require__(/*! ./helpers/client */ \"(rsc)/../node_modules/openid-client/lib/helpers/client.js\");\nconst { queryKeyStore } = __webpack_require__(/*! ./helpers/issuer */ \"(rsc)/../node_modules/openid-client/lib/helpers/issuer.js\");\nconst DeviceFlowHandle = __webpack_require__(/*! ./device_flow_handle */ \"(rsc)/../node_modules/openid-client/lib/device_flow_handle.js\");\nconst [major, minor] = process.version.slice(1).split(\".\").map((str)=>parseInt(str, 10));\nconst rsaPssParams = major >= 17 || major === 16 && minor >= 9;\nconst retryAttempt = Symbol();\nconst skipNonceCheck = Symbol();\nconst skipMaxAgeCheck = Symbol();\nfunction pickCb(input) {\n    return pick(input, \"access_token\", \"code\", \"error_description\", \"error_uri\", \"error\", \"expires_in\", \"id_token\", \"iss\", \"response\", \"session_state\", \"state\", \"token_type\");\n}\nfunction authorizationHeaderValue(token, tokenType = \"Bearer\") {\n    return `${tokenType} ${token}`;\n}\nfunction getSearchParams(input) {\n    const parsed = url.parse(input);\n    if (!parsed.search) return {};\n    return querystring.parse(parsed.search.substring(1));\n}\nfunction verifyPresence(payload, jwt, prop) {\n    if (payload[prop] === undefined) {\n        throw new RPError({\n            message: `missing required JWT property ${prop}`,\n            jwt\n        });\n    }\n}\nfunction authorizationParams(params) {\n    const authParams = {\n        client_id: this.client_id,\n        scope: \"openid\",\n        response_type: resolveResponseType.call(this),\n        redirect_uri: resolveRedirectUri.call(this),\n        ...params\n    };\n    Object.entries(authParams).forEach(([key, value])=>{\n        if (value === null || value === undefined) {\n            delete authParams[key];\n        } else if (key === \"claims\" && typeof value === \"object\") {\n            authParams[key] = JSON.stringify(value);\n        } else if (key === \"resource\" && Array.isArray(value)) {\n            authParams[key] = value;\n        } else if (typeof value !== \"string\") {\n            authParams[key] = String(value);\n        }\n    });\n    return authParams;\n}\nfunction getKeystore(jwks) {\n    if (!isPlainObject(jwks) || !Array.isArray(jwks.keys) || jwks.keys.some((k)=>!isPlainObject(k) || !(\"kty\" in k))) {\n        throw new TypeError(\"jwks must be a JSON Web Key Set formatted object\");\n    }\n    return KeyStore.fromJWKS(jwks, {\n        onlyPrivate: true\n    });\n}\n// if an OP doesnt support client_secret_basic but supports client_secret_post, use it instead\n// this is in place to take care of most common pitfalls when first using discovered Issuers without\n// the support for default values defined by Discovery 1.0\nfunction checkBasicSupport(client, properties) {\n    try {\n        const supported = client.issuer.token_endpoint_auth_methods_supported;\n        if (!supported.includes(properties.token_endpoint_auth_method)) {\n            if (supported.includes(\"client_secret_post\")) {\n                properties.token_endpoint_auth_method = \"client_secret_post\";\n            }\n        }\n    } catch (err) {}\n}\nfunction handleCommonMistakes(client, metadata, properties) {\n    if (!metadata.token_endpoint_auth_method) {\n        // if no explicit value was provided\n        checkBasicSupport(client, properties);\n    }\n    // :fp: c'mon people... RTFM\n    if (metadata.redirect_uri) {\n        if (metadata.redirect_uris) {\n            throw new TypeError(\"provide a redirect_uri or redirect_uris, not both\");\n        }\n        properties.redirect_uris = [\n            metadata.redirect_uri\n        ];\n        delete properties.redirect_uri;\n    }\n    if (metadata.response_type) {\n        if (metadata.response_types) {\n            throw new TypeError(\"provide a response_type or response_types, not both\");\n        }\n        properties.response_types = [\n            metadata.response_type\n        ];\n        delete properties.response_type;\n    }\n}\nfunction getDefaultsForEndpoint(endpoint, issuer, properties) {\n    if (!issuer[`${endpoint}_endpoint`]) return;\n    const tokenEndpointAuthMethod = properties.token_endpoint_auth_method;\n    const tokenEndpointAuthSigningAlg = properties.token_endpoint_auth_signing_alg;\n    const eam = `${endpoint}_endpoint_auth_method`;\n    const easa = `${endpoint}_endpoint_auth_signing_alg`;\n    if (properties[eam] === undefined && properties[easa] === undefined) {\n        if (tokenEndpointAuthMethod !== undefined) {\n            properties[eam] = tokenEndpointAuthMethod;\n        }\n        if (tokenEndpointAuthSigningAlg !== undefined) {\n            properties[easa] = tokenEndpointAuthSigningAlg;\n        }\n    }\n}\nclass BaseClient {\n    #metadata;\n    #issuer;\n    #aadIssValidation;\n    #additionalAuthorizedParties;\n    constructor(issuer, aadIssValidation, metadata = {}, jwks, options){\n        this.#metadata = new Map();\n        this.#issuer = issuer;\n        this.#aadIssValidation = aadIssValidation;\n        if (typeof metadata.client_id !== \"string\" || !metadata.client_id) {\n            throw new TypeError(\"client_id is required\");\n        }\n        const properties = {\n            grant_types: [\n                \"authorization_code\"\n            ],\n            id_token_signed_response_alg: \"RS256\",\n            authorization_signed_response_alg: \"RS256\",\n            response_types: [\n                \"code\"\n            ],\n            token_endpoint_auth_method: \"client_secret_basic\",\n            ...this.fapi1() ? {\n                grant_types: [\n                    \"authorization_code\",\n                    \"implicit\"\n                ],\n                id_token_signed_response_alg: \"PS256\",\n                authorization_signed_response_alg: \"PS256\",\n                response_types: [\n                    \"code id_token\"\n                ],\n                tls_client_certificate_bound_access_tokens: true,\n                token_endpoint_auth_method: undefined\n            } : undefined,\n            ...this.fapi2() ? {\n                id_token_signed_response_alg: \"PS256\",\n                authorization_signed_response_alg: \"PS256\",\n                token_endpoint_auth_method: undefined\n            } : undefined,\n            ...metadata\n        };\n        if (this.fapi()) {\n            switch(properties.token_endpoint_auth_method){\n                case \"self_signed_tls_client_auth\":\n                case \"tls_client_auth\":\n                    break;\n                case \"private_key_jwt\":\n                    if (!jwks) {\n                        throw new TypeError(\"jwks is required\");\n                    }\n                    break;\n                case undefined:\n                    throw new TypeError(\"token_endpoint_auth_method is required\");\n                default:\n                    throw new TypeError(\"invalid or unsupported token_endpoint_auth_method\");\n            }\n        }\n        if (this.fapi2()) {\n            if (properties.tls_client_certificate_bound_access_tokens && properties.dpop_bound_access_tokens) {\n                throw new TypeError(\"either tls_client_certificate_bound_access_tokens or dpop_bound_access_tokens must be set to true\");\n            }\n            if (!properties.tls_client_certificate_bound_access_tokens && !properties.dpop_bound_access_tokens) {\n                throw new TypeError(\"either tls_client_certificate_bound_access_tokens or dpop_bound_access_tokens must be set to true\");\n            }\n        }\n        handleCommonMistakes(this, metadata, properties);\n        assertSigningAlgValuesSupport(\"token\", this.issuer, properties);\n        [\n            \"introspection\",\n            \"revocation\"\n        ].forEach((endpoint)=>{\n            getDefaultsForEndpoint(endpoint, this.issuer, properties);\n            assertSigningAlgValuesSupport(endpoint, this.issuer, properties);\n        });\n        Object.entries(properties).forEach(([key, value])=>{\n            this.#metadata.set(key, value);\n            if (!this[key]) {\n                Object.defineProperty(this, key, {\n                    get () {\n                        return this.#metadata.get(key);\n                    },\n                    enumerable: true\n                });\n            }\n        });\n        if (jwks !== undefined) {\n            const keystore = getKeystore.call(this, jwks);\n            keystores.set(this, keystore);\n        }\n        if (options != null && options.additionalAuthorizedParties) {\n            this.#additionalAuthorizedParties = clone(options.additionalAuthorizedParties);\n        }\n        this[CLOCK_TOLERANCE] = 0;\n    }\n    authorizationUrl(params = {}) {\n        if (!isPlainObject(params)) {\n            throw new TypeError(\"params must be a plain object\");\n        }\n        assertIssuerConfiguration(this.issuer, \"authorization_endpoint\");\n        const target = new URL(this.issuer.authorization_endpoint);\n        for (const [name, value] of Object.entries(authorizationParams.call(this, params))){\n            if (Array.isArray(value)) {\n                target.searchParams.delete(name);\n                for (const member of value){\n                    target.searchParams.append(name, member);\n                }\n            } else {\n                target.searchParams.set(name, value);\n            }\n        }\n        // TODO: is the replace needed?\n        return target.href.replace(/\\+/g, \"%20\");\n    }\n    authorizationPost(params = {}) {\n        if (!isPlainObject(params)) {\n            throw new TypeError(\"params must be a plain object\");\n        }\n        const inputs = authorizationParams.call(this, params);\n        const formInputs = Object.keys(inputs).map((name)=>`<input type=\"hidden\" name=\"${name}\" value=\"${inputs[name]}\"/>`).join(\"\\n\");\n        return `<!DOCTYPE html>\n<head>\n<title>Requesting Authorization</title>\n</head>\n<body onload=\"javascript:document.forms[0].submit()\">\n<form method=\"post\" action=\"${this.issuer.authorization_endpoint}\">\n  ${formInputs}\n</form>\n</body>\n</html>`;\n    }\n    endSessionUrl(params = {}) {\n        assertIssuerConfiguration(this.issuer, \"end_session_endpoint\");\n        const { 0: postLogout, length } = this.post_logout_redirect_uris || [];\n        const { post_logout_redirect_uri = length === 1 ? postLogout : undefined } = params;\n        let id_token_hint;\n        ({ id_token_hint, ...params } = params);\n        if (id_token_hint instanceof TokenSet) {\n            if (!id_token_hint.id_token) {\n                throw new TypeError(\"id_token not present in TokenSet\");\n            }\n            id_token_hint = id_token_hint.id_token;\n        }\n        const target = url.parse(this.issuer.end_session_endpoint);\n        const query = defaults(getSearchParams(this.issuer.end_session_endpoint), params, {\n            post_logout_redirect_uri,\n            client_id: this.client_id\n        }, {\n            id_token_hint\n        });\n        Object.entries(query).forEach(([key, value])=>{\n            if (value === null || value === undefined) {\n                delete query[key];\n            }\n        });\n        target.search = null;\n        target.query = query;\n        return url.format(target);\n    }\n    callbackParams(input) {\n        const isIncomingMessage = input instanceof stdhttp.IncomingMessage || input && input.method && input.url;\n        const isString = typeof input === \"string\";\n        if (!isString && !isIncomingMessage) {\n            throw new TypeError(\"#callbackParams only accepts string urls, http.IncomingMessage or a lookalike\");\n        }\n        if (isIncomingMessage) {\n            switch(input.method){\n                case \"GET\":\n                    return pickCb(getSearchParams(input.url));\n                case \"POST\":\n                    if (input.body === undefined) {\n                        throw new TypeError(\"incoming message body missing, include a body parser prior to this method call\");\n                    }\n                    switch(typeof input.body){\n                        case \"object\":\n                        case \"string\":\n                            if (Buffer.isBuffer(input.body)) {\n                                return pickCb(querystring.parse(input.body.toString(\"utf-8\")));\n                            }\n                            if (typeof input.body === \"string\") {\n                                return pickCb(querystring.parse(input.body));\n                            }\n                            return pickCb(input.body);\n                        default:\n                            throw new TypeError(\"invalid IncomingMessage body object\");\n                    }\n                default:\n                    throw new TypeError(\"invalid IncomingMessage method\");\n            }\n        } else {\n            return pickCb(getSearchParams(input));\n        }\n    }\n    async callback(redirectUri, parameters, checks = {}, { exchangeBody, clientAssertionPayload, DPoP } = {}) {\n        let params = pickCb(parameters);\n        if (checks.jarm && !(\"response\" in parameters)) {\n            throw new RPError({\n                message: \"expected a JARM response\",\n                checks,\n                params\n            });\n        } else if (\"response\" in parameters) {\n            const decrypted = await this.decryptJARM(params.response);\n            params = await this.validateJARM(decrypted);\n        }\n        if (this.default_max_age && !checks.max_age) {\n            checks.max_age = this.default_max_age;\n        }\n        if (params.state && !checks.state) {\n            throw new TypeError(\"checks.state argument is missing\");\n        }\n        if (!params.state && checks.state) {\n            throw new RPError({\n                message: \"state missing from the response\",\n                checks,\n                params\n            });\n        }\n        if (checks.state !== params.state) {\n            throw new RPError({\n                printf: [\n                    \"state mismatch, expected %s, got: %s\",\n                    checks.state,\n                    params.state\n                ],\n                checks,\n                params\n            });\n        }\n        if (\"iss\" in params) {\n            assertIssuerConfiguration(this.issuer, \"issuer\");\n            if (params.iss !== this.issuer.issuer) {\n                throw new RPError({\n                    printf: [\n                        \"iss mismatch, expected %s, got: %s\",\n                        this.issuer.issuer,\n                        params.iss\n                    ],\n                    params\n                });\n            }\n        } else if (this.issuer.authorization_response_iss_parameter_supported && !(\"id_token\" in params) && !(\"response\" in parameters)) {\n            throw new RPError({\n                message: \"iss missing from the response\",\n                params\n            });\n        }\n        if (params.error) {\n            throw new OPError(params);\n        }\n        const RESPONSE_TYPE_REQUIRED_PARAMS = {\n            code: [\n                \"code\"\n            ],\n            id_token: [\n                \"id_token\"\n            ],\n            token: [\n                \"access_token\",\n                \"token_type\"\n            ]\n        };\n        if (checks.response_type) {\n            for (const type of checks.response_type.split(\" \")){\n                if (type === \"none\") {\n                    if (params.code || params.id_token || params.access_token) {\n                        throw new RPError({\n                            message: 'unexpected params encountered for \"none\" response',\n                            checks,\n                            params\n                        });\n                    }\n                } else {\n                    for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]){\n                        if (!params[param]) {\n                            throw new RPError({\n                                message: `${param} missing from response`,\n                                checks,\n                                params\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        if (params.id_token) {\n            const tokenset = new TokenSet(params);\n            await this.decryptIdToken(tokenset);\n            await this.validateIdToken(tokenset, checks.nonce, \"authorization\", checks.max_age, checks.state);\n            if (!params.code) {\n                return tokenset;\n            }\n        }\n        if (params.code) {\n            const tokenset = await this.grant({\n                ...exchangeBody,\n                grant_type: \"authorization_code\",\n                code: params.code,\n                redirect_uri: redirectUri,\n                code_verifier: checks.code_verifier\n            }, {\n                clientAssertionPayload,\n                DPoP\n            });\n            await this.decryptIdToken(tokenset);\n            await this.validateIdToken(tokenset, checks.nonce, \"token\", checks.max_age);\n            if (params.session_state) {\n                tokenset.session_state = params.session_state;\n            }\n            return tokenset;\n        }\n        return new TokenSet(params);\n    }\n    async oauthCallback(redirectUri, parameters, checks = {}, { exchangeBody, clientAssertionPayload, DPoP } = {}) {\n        let params = pickCb(parameters);\n        if (checks.jarm && !(\"response\" in parameters)) {\n            throw new RPError({\n                message: \"expected a JARM response\",\n                checks,\n                params\n            });\n        } else if (\"response\" in parameters) {\n            const decrypted = await this.decryptJARM(params.response);\n            params = await this.validateJARM(decrypted);\n        }\n        if (params.state && !checks.state) {\n            throw new TypeError(\"checks.state argument is missing\");\n        }\n        if (!params.state && checks.state) {\n            throw new RPError({\n                message: \"state missing from the response\",\n                checks,\n                params\n            });\n        }\n        if (checks.state !== params.state) {\n            throw new RPError({\n                printf: [\n                    \"state mismatch, expected %s, got: %s\",\n                    checks.state,\n                    params.state\n                ],\n                checks,\n                params\n            });\n        }\n        if (\"iss\" in params) {\n            assertIssuerConfiguration(this.issuer, \"issuer\");\n            if (params.iss !== this.issuer.issuer) {\n                throw new RPError({\n                    printf: [\n                        \"iss mismatch, expected %s, got: %s\",\n                        this.issuer.issuer,\n                        params.iss\n                    ],\n                    params\n                });\n            }\n        } else if (this.issuer.authorization_response_iss_parameter_supported && !(\"id_token\" in params) && !(\"response\" in parameters)) {\n            throw new RPError({\n                message: \"iss missing from the response\",\n                params\n            });\n        }\n        if (params.error) {\n            throw new OPError(params);\n        }\n        if (typeof params.id_token === \"string\" && params.id_token.length) {\n            throw new RPError({\n                message: \"id_token detected in the response, you must use client.callback() instead of client.oauthCallback()\",\n                params\n            });\n        }\n        delete params.id_token;\n        const RESPONSE_TYPE_REQUIRED_PARAMS = {\n            code: [\n                \"code\"\n            ],\n            token: [\n                \"access_token\",\n                \"token_type\"\n            ]\n        };\n        if (checks.response_type) {\n            for (const type of checks.response_type.split(\" \")){\n                if (type === \"none\") {\n                    if (params.code || params.id_token || params.access_token) {\n                        throw new RPError({\n                            message: 'unexpected params encountered for \"none\" response',\n                            checks,\n                            params\n                        });\n                    }\n                }\n                if (RESPONSE_TYPE_REQUIRED_PARAMS[type]) {\n                    for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]){\n                        if (!params[param]) {\n                            throw new RPError({\n                                message: `${param} missing from response`,\n                                checks,\n                                params\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        if (params.code) {\n            const tokenset = await this.grant({\n                ...exchangeBody,\n                grant_type: \"authorization_code\",\n                code: params.code,\n                redirect_uri: redirectUri,\n                code_verifier: checks.code_verifier\n            }, {\n                clientAssertionPayload,\n                DPoP\n            });\n            if (typeof tokenset.id_token === \"string\" && tokenset.id_token.length) {\n                throw new RPError({\n                    message: \"id_token detected in the response, you must use client.callback() instead of client.oauthCallback()\",\n                    params\n                });\n            }\n            delete tokenset.id_token;\n            return tokenset;\n        }\n        return new TokenSet(params);\n    }\n    async decryptIdToken(token) {\n        if (!this.id_token_encrypted_response_alg) {\n            return token;\n        }\n        let idToken = token;\n        if (idToken instanceof TokenSet) {\n            if (!idToken.id_token) {\n                throw new TypeError(\"id_token not present in TokenSet\");\n            }\n            idToken = idToken.id_token;\n        }\n        const expectedAlg = this.id_token_encrypted_response_alg;\n        const expectedEnc = this.id_token_encrypted_response_enc;\n        const result = await this.decryptJWE(idToken, expectedAlg, expectedEnc);\n        if (token instanceof TokenSet) {\n            token.id_token = result;\n            return token;\n        }\n        return result;\n    }\n    async validateJWTUserinfo(body) {\n        const expectedAlg = this.userinfo_signed_response_alg;\n        return this.validateJWT(body, expectedAlg, []);\n    }\n    async decryptJARM(response) {\n        if (!this.authorization_encrypted_response_alg) {\n            return response;\n        }\n        const expectedAlg = this.authorization_encrypted_response_alg;\n        const expectedEnc = this.authorization_encrypted_response_enc;\n        return this.decryptJWE(response, expectedAlg, expectedEnc);\n    }\n    async decryptJWTUserinfo(body) {\n        if (!this.userinfo_encrypted_response_alg) {\n            return body;\n        }\n        const expectedAlg = this.userinfo_encrypted_response_alg;\n        const expectedEnc = this.userinfo_encrypted_response_enc;\n        return this.decryptJWE(body, expectedAlg, expectedEnc);\n    }\n    async decryptJWE(jwe, expectedAlg, expectedEnc = \"A128CBC-HS256\") {\n        const header = JSON.parse(base64url.decode(jwe.split(\".\")[0]));\n        if (header.alg !== expectedAlg) {\n            throw new RPError({\n                printf: [\n                    \"unexpected JWE alg received, expected %s, got: %s\",\n                    expectedAlg,\n                    header.alg\n                ],\n                jwt: jwe\n            });\n        }\n        if (header.enc !== expectedEnc) {\n            throw new RPError({\n                printf: [\n                    \"unexpected JWE enc received, expected %s, got: %s\",\n                    expectedEnc,\n                    header.enc\n                ],\n                jwt: jwe\n            });\n        }\n        const getPlaintext = (result)=>new TextDecoder().decode(result.plaintext);\n        let plaintext;\n        if (expectedAlg.match(/^(?:RSA|ECDH)/)) {\n            const keystore = await keystores.get(this);\n            const protectedHeader = jose.decodeProtectedHeader(jwe);\n            for (const key of keystore.all({\n                ...protectedHeader,\n                use: \"enc\"\n            })){\n                plaintext = await jose.compactDecrypt(jwe, await key.keyObject(protectedHeader.alg)).then(getPlaintext, ()=>{});\n                if (plaintext) break;\n            }\n        } else {\n            plaintext = await jose.compactDecrypt(jwe, this.secretForAlg(expectedAlg === \"dir\" ? expectedEnc : expectedAlg)).then(getPlaintext, ()=>{});\n        }\n        if (!plaintext) {\n            throw new RPError({\n                message: \"failed to decrypt JWE\",\n                jwt: jwe\n            });\n        }\n        return plaintext;\n    }\n    async validateIdToken(tokenSet, nonce, returnedBy, maxAge, state) {\n        let idToken = tokenSet;\n        const expectedAlg = this.id_token_signed_response_alg;\n        const isTokenSet = idToken instanceof TokenSet;\n        if (isTokenSet) {\n            if (!idToken.id_token) {\n                throw new TypeError(\"id_token not present in TokenSet\");\n            }\n            idToken = idToken.id_token;\n        }\n        idToken = String(idToken);\n        const timestamp = now();\n        const { protected: header, payload, key } = await this.validateJWT(idToken, expectedAlg);\n        if (typeof maxAge === \"number\" || maxAge !== skipMaxAgeCheck && this.require_auth_time) {\n            if (!payload.auth_time) {\n                throw new RPError({\n                    message: \"missing required JWT property auth_time\",\n                    jwt: idToken\n                });\n            }\n            if (typeof payload.auth_time !== \"number\") {\n                throw new RPError({\n                    message: \"JWT auth_time claim must be a JSON numeric value\",\n                    jwt: idToken\n                });\n            }\n        }\n        if (typeof maxAge === \"number\" && payload.auth_time + maxAge < timestamp - this[CLOCK_TOLERANCE]) {\n            throw new RPError({\n                printf: [\n                    \"too much time has elapsed since the last End-User authentication, max_age %i, auth_time: %i, now %i\",\n                    maxAge,\n                    payload.auth_time,\n                    timestamp - this[CLOCK_TOLERANCE]\n                ],\n                now: timestamp,\n                tolerance: this[CLOCK_TOLERANCE],\n                auth_time: payload.auth_time,\n                jwt: idToken\n            });\n        }\n        if (nonce !== skipNonceCheck && (payload.nonce || nonce !== undefined) && payload.nonce !== nonce) {\n            throw new RPError({\n                printf: [\n                    \"nonce mismatch, expected %s, got: %s\",\n                    nonce,\n                    payload.nonce\n                ],\n                jwt: idToken\n            });\n        }\n        if (returnedBy === \"authorization\") {\n            if (!payload.at_hash && tokenSet.access_token) {\n                throw new RPError({\n                    message: \"missing required property at_hash\",\n                    jwt: idToken\n                });\n            }\n            if (!payload.c_hash && tokenSet.code) {\n                throw new RPError({\n                    message: \"missing required property c_hash\",\n                    jwt: idToken\n                });\n            }\n            if (this.fapi1()) {\n                if (!payload.s_hash && (tokenSet.state || state)) {\n                    throw new RPError({\n                        message: \"missing required property s_hash\",\n                        jwt: idToken\n                    });\n                }\n            }\n            if (payload.s_hash) {\n                if (!state) {\n                    throw new TypeError('cannot verify s_hash, \"checks.state\" property not provided');\n                }\n                try {\n                    tokenHash.validate({\n                        claim: \"s_hash\",\n                        source: \"state\"\n                    }, payload.s_hash, state, header.alg, key.jwk && key.jwk.crv);\n                } catch (err) {\n                    throw new RPError({\n                        message: err.message,\n                        jwt: idToken\n                    });\n                }\n            }\n        }\n        if (this.fapi() && payload.iat < timestamp - 3600) {\n            throw new RPError({\n                printf: [\n                    \"JWT issued too far in the past, now %i, iat %i\",\n                    timestamp,\n                    payload.iat\n                ],\n                now: timestamp,\n                tolerance: this[CLOCK_TOLERANCE],\n                iat: payload.iat,\n                jwt: idToken\n            });\n        }\n        if (tokenSet.access_token && payload.at_hash !== undefined) {\n            try {\n                tokenHash.validate({\n                    claim: \"at_hash\",\n                    source: \"access_token\"\n                }, payload.at_hash, tokenSet.access_token, header.alg, key.jwk && key.jwk.crv);\n            } catch (err) {\n                throw new RPError({\n                    message: err.message,\n                    jwt: idToken\n                });\n            }\n        }\n        if (tokenSet.code && payload.c_hash !== undefined) {\n            try {\n                tokenHash.validate({\n                    claim: \"c_hash\",\n                    source: \"code\"\n                }, payload.c_hash, tokenSet.code, header.alg, key.jwk && key.jwk.crv);\n            } catch (err) {\n                throw new RPError({\n                    message: err.message,\n                    jwt: idToken\n                });\n            }\n        }\n        return tokenSet;\n    }\n    async validateJWT(jwt, expectedAlg, required = [\n        \"iss\",\n        \"sub\",\n        \"aud\",\n        \"exp\",\n        \"iat\"\n    ]) {\n        const isSelfIssued = this.issuer.issuer === \"https://self-issued.me\";\n        const timestamp = now();\n        let header;\n        let payload;\n        try {\n            ({ header, payload } = decodeJWT(jwt, {\n                complete: true\n            }));\n        } catch (err) {\n            throw new RPError({\n                printf: [\n                    \"failed to decode JWT (%s: %s)\",\n                    err.name,\n                    err.message\n                ],\n                jwt\n            });\n        }\n        if (header.alg !== expectedAlg) {\n            throw new RPError({\n                printf: [\n                    \"unexpected JWT alg received, expected %s, got: %s\",\n                    expectedAlg,\n                    header.alg\n                ],\n                jwt\n            });\n        }\n        if (isSelfIssued) {\n            required = [\n                ...required,\n                \"sub_jwk\"\n            ];\n        }\n        required.forEach(verifyPresence.bind(undefined, payload, jwt));\n        if (payload.iss !== undefined) {\n            let expectedIss = this.issuer.issuer;\n            if (this.#aadIssValidation) {\n                expectedIss = this.issuer.issuer.replace(\"{tenantid}\", payload.tid);\n            }\n            if (payload.iss !== expectedIss) {\n                throw new RPError({\n                    printf: [\n                        \"unexpected iss value, expected %s, got: %s\",\n                        expectedIss,\n                        payload.iss\n                    ],\n                    jwt\n                });\n            }\n        }\n        if (payload.iat !== undefined) {\n            if (typeof payload.iat !== \"number\") {\n                throw new RPError({\n                    message: \"JWT iat claim must be a JSON numeric value\",\n                    jwt\n                });\n            }\n        }\n        if (payload.nbf !== undefined) {\n            if (typeof payload.nbf !== \"number\") {\n                throw new RPError({\n                    message: \"JWT nbf claim must be a JSON numeric value\",\n                    jwt\n                });\n            }\n            if (payload.nbf > timestamp + this[CLOCK_TOLERANCE]) {\n                throw new RPError({\n                    printf: [\n                        \"JWT not active yet, now %i, nbf %i\",\n                        timestamp + this[CLOCK_TOLERANCE],\n                        payload.nbf\n                    ],\n                    now: timestamp,\n                    tolerance: this[CLOCK_TOLERANCE],\n                    nbf: payload.nbf,\n                    jwt\n                });\n            }\n        }\n        if (payload.exp !== undefined) {\n            if (typeof payload.exp !== \"number\") {\n                throw new RPError({\n                    message: \"JWT exp claim must be a JSON numeric value\",\n                    jwt\n                });\n            }\n            if (timestamp - this[CLOCK_TOLERANCE] >= payload.exp) {\n                throw new RPError({\n                    printf: [\n                        \"JWT expired, now %i, exp %i\",\n                        timestamp - this[CLOCK_TOLERANCE],\n                        payload.exp\n                    ],\n                    now: timestamp,\n                    tolerance: this[CLOCK_TOLERANCE],\n                    exp: payload.exp,\n                    jwt\n                });\n            }\n        }\n        if (payload.aud !== undefined) {\n            if (Array.isArray(payload.aud)) {\n                if (payload.aud.length > 1 && !payload.azp) {\n                    throw new RPError({\n                        message: \"missing required JWT property azp\",\n                        jwt\n                    });\n                }\n                if (!payload.aud.includes(this.client_id)) {\n                    throw new RPError({\n                        printf: [\n                            \"aud is missing the client_id, expected %s to be included in %j\",\n                            this.client_id,\n                            payload.aud\n                        ],\n                        jwt\n                    });\n                }\n            } else if (payload.aud !== this.client_id) {\n                throw new RPError({\n                    printf: [\n                        \"aud mismatch, expected %s, got: %s\",\n                        this.client_id,\n                        payload.aud\n                    ],\n                    jwt\n                });\n            }\n        }\n        if (payload.azp !== undefined) {\n            let additionalAuthorizedParties = this.#additionalAuthorizedParties;\n            if (typeof additionalAuthorizedParties === \"string\") {\n                additionalAuthorizedParties = [\n                    this.client_id,\n                    additionalAuthorizedParties\n                ];\n            } else if (Array.isArray(additionalAuthorizedParties)) {\n                additionalAuthorizedParties = [\n                    this.client_id,\n                    ...additionalAuthorizedParties\n                ];\n            } else {\n                additionalAuthorizedParties = [\n                    this.client_id\n                ];\n            }\n            if (!additionalAuthorizedParties.includes(payload.azp)) {\n                throw new RPError({\n                    printf: [\n                        \"azp mismatch, got: %s\",\n                        payload.azp\n                    ],\n                    jwt\n                });\n            }\n        }\n        let keys;\n        if (isSelfIssued) {\n            try {\n                assert(isPlainObject(payload.sub_jwk));\n                const key = await jose.importJWK(payload.sub_jwk, header.alg);\n                assert.equal(key.type, \"public\");\n                keys = [\n                    {\n                        keyObject () {\n                            return key;\n                        }\n                    }\n                ];\n            } catch (err) {\n                throw new RPError({\n                    message: \"failed to use sub_jwk claim as an asymmetric JSON Web Key\",\n                    jwt\n                });\n            }\n            if (await jose.calculateJwkThumbprint(payload.sub_jwk) !== payload.sub) {\n                throw new RPError({\n                    message: \"failed to match the subject with sub_jwk\",\n                    jwt\n                });\n            }\n        } else if (header.alg.startsWith(\"HS\")) {\n            keys = [\n                this.secretForAlg(header.alg)\n            ];\n        } else if (header.alg !== \"none\") {\n            keys = await queryKeyStore.call(this.issuer, {\n                ...header,\n                use: \"sig\"\n            });\n        }\n        if (!keys && header.alg === \"none\") {\n            return {\n                protected: header,\n                payload\n            };\n        }\n        for (const key of keys){\n            const verified = await jose.compactVerify(jwt, key instanceof Uint8Array ? key : await key.keyObject(header.alg)).catch(()=>{});\n            if (verified) {\n                return {\n                    payload,\n                    protected: verified.protectedHeader,\n                    key\n                };\n            }\n        }\n        throw new RPError({\n            message: \"failed to validate JWT signature\",\n            jwt\n        });\n    }\n    async refresh(refreshToken, { exchangeBody, clientAssertionPayload, DPoP } = {}) {\n        let token = refreshToken;\n        if (token instanceof TokenSet) {\n            if (!token.refresh_token) {\n                throw new TypeError(\"refresh_token not present in TokenSet\");\n            }\n            token = token.refresh_token;\n        }\n        const tokenset = await this.grant({\n            ...exchangeBody,\n            grant_type: \"refresh_token\",\n            refresh_token: String(token)\n        }, {\n            clientAssertionPayload,\n            DPoP\n        });\n        if (tokenset.id_token) {\n            await this.decryptIdToken(tokenset);\n            await this.validateIdToken(tokenset, skipNonceCheck, \"token\", skipMaxAgeCheck);\n            if (refreshToken instanceof TokenSet && refreshToken.id_token) {\n                const expectedSub = refreshToken.claims().sub;\n                const actualSub = tokenset.claims().sub;\n                if (actualSub !== expectedSub) {\n                    throw new RPError({\n                        printf: [\n                            \"sub mismatch, expected %s, got: %s\",\n                            expectedSub,\n                            actualSub\n                        ],\n                        jwt: tokenset.id_token\n                    });\n                }\n            }\n        }\n        return tokenset;\n    }\n    async requestResource(resourceUrl, accessToken, { method, headers, body, DPoP, tokenType = DPoP ? \"DPoP\" : accessToken instanceof TokenSet ? accessToken.token_type : \"Bearer\" } = {}, retry) {\n        if (accessToken instanceof TokenSet) {\n            if (!accessToken.access_token) {\n                throw new TypeError(\"access_token not present in TokenSet\");\n            }\n            accessToken = accessToken.access_token;\n        }\n        if (!accessToken) {\n            throw new TypeError(\"no access token provided\");\n        } else if (typeof accessToken !== \"string\") {\n            throw new TypeError(\"invalid access token provided\");\n        }\n        const requestOpts = {\n            headers: {\n                Authorization: authorizationHeaderValue(accessToken, tokenType),\n                ...headers\n            },\n            body\n        };\n        const mTLS = !!this.tls_client_certificate_bound_access_tokens;\n        const response = await request.call(this, {\n            ...requestOpts,\n            responseType: \"buffer\",\n            method,\n            url: resourceUrl\n        }, {\n            accessToken,\n            mTLS,\n            DPoP\n        });\n        const wwwAuthenticate = response.headers[\"www-authenticate\"];\n        if (retry !== retryAttempt && wwwAuthenticate && wwwAuthenticate.toLowerCase().startsWith(\"dpop \") && parseWwwAuthenticate(wwwAuthenticate).error === \"use_dpop_nonce\") {\n            return this.requestResource(resourceUrl, accessToken, {\n                method,\n                headers,\n                body,\n                DPoP,\n                tokenType\n            });\n        }\n        return response;\n    }\n    async userinfo(accessToken, { method = \"GET\", via = \"header\", tokenType, params, DPoP } = {}) {\n        assertIssuerConfiguration(this.issuer, \"userinfo_endpoint\");\n        const options = {\n            tokenType,\n            method: String(method).toUpperCase(),\n            DPoP\n        };\n        if (options.method !== \"GET\" && options.method !== \"POST\") {\n            throw new TypeError(\"#userinfo() method can only be POST or a GET\");\n        }\n        if (via === \"body\" && options.method !== \"POST\") {\n            throw new TypeError(\"can only send body on POST\");\n        }\n        const jwt = !!(this.userinfo_signed_response_alg || this.userinfo_encrypted_response_alg);\n        if (jwt) {\n            options.headers = {\n                Accept: \"application/jwt\"\n            };\n        } else {\n            options.headers = {\n                Accept: \"application/json\"\n            };\n        }\n        const mTLS = !!this.tls_client_certificate_bound_access_tokens;\n        let targetUrl;\n        if (mTLS && this.issuer.mtls_endpoint_aliases) {\n            targetUrl = this.issuer.mtls_endpoint_aliases.userinfo_endpoint;\n        }\n        targetUrl = new URL(targetUrl || this.issuer.userinfo_endpoint);\n        if (via === \"body\") {\n            options.headers.Authorization = undefined;\n            options.headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\";\n            options.body = new URLSearchParams();\n            options.body.append(\"access_token\", accessToken instanceof TokenSet ? accessToken.access_token : accessToken);\n        }\n        // handle additional parameters, GET via querystring, POST via urlencoded body\n        if (params) {\n            if (options.method === \"GET\") {\n                Object.entries(params).forEach(([key, value])=>{\n                    targetUrl.searchParams.append(key, value);\n                });\n            } else if (options.body) {\n                // POST && via body\n                Object.entries(params).forEach(([key, value])=>{\n                    options.body.append(key, value);\n                });\n            } else {\n                // POST && via header\n                options.body = new URLSearchParams();\n                options.headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\";\n                Object.entries(params).forEach(([key, value])=>{\n                    options.body.append(key, value);\n                });\n            }\n        }\n        if (options.body) {\n            options.body = options.body.toString();\n        }\n        const response = await this.requestResource(targetUrl, accessToken, options);\n        let parsed = processResponse(response, {\n            bearer: true\n        });\n        if (jwt) {\n            if (!/^application\\/jwt/.test(response.headers[\"content-type\"])) {\n                throw new RPError({\n                    message: \"expected application/jwt response from the userinfo_endpoint\",\n                    response\n                });\n            }\n            const body = response.body.toString();\n            const userinfo = await this.decryptJWTUserinfo(body);\n            if (!this.userinfo_signed_response_alg) {\n                try {\n                    parsed = JSON.parse(userinfo);\n                    assert(isPlainObject(parsed));\n                } catch (err) {\n                    throw new RPError({\n                        message: \"failed to parse userinfo JWE payload as JSON\",\n                        jwt: userinfo\n                    });\n                }\n            } else {\n                ({ payload: parsed } = await this.validateJWTUserinfo(userinfo));\n            }\n        } else {\n            try {\n                parsed = JSON.parse(response.body);\n            } catch (err) {\n                Object.defineProperty(err, \"response\", {\n                    value: response\n                });\n                throw err;\n            }\n        }\n        if (accessToken instanceof TokenSet && accessToken.id_token) {\n            const expectedSub = accessToken.claims().sub;\n            if (parsed.sub !== expectedSub) {\n                throw new RPError({\n                    printf: [\n                        \"userinfo sub mismatch, expected %s, got: %s\",\n                        expectedSub,\n                        parsed.sub\n                    ],\n                    body: parsed,\n                    jwt: accessToken.id_token\n                });\n            }\n        }\n        return parsed;\n    }\n    encryptionSecret(len) {\n        const hash = len <= 256 ? \"sha256\" : len <= 384 ? \"sha384\" : len <= 512 ? \"sha512\" : false;\n        if (!hash) {\n            throw new Error(\"unsupported symmetric encryption key derivation\");\n        }\n        return crypto.createHash(hash).update(this.client_secret).digest().slice(0, len / 8);\n    }\n    secretForAlg(alg) {\n        if (!this.client_secret) {\n            throw new TypeError(\"client_secret is required\");\n        }\n        if (/^A(\\d{3})(?:GCM)?KW$/.test(alg)) {\n            return this.encryptionSecret(parseInt(RegExp.$1, 10));\n        }\n        if (/^A(\\d{3})(?:GCM|CBC-HS(\\d{3}))$/.test(alg)) {\n            return this.encryptionSecret(parseInt(RegExp.$2 || RegExp.$1, 10));\n        }\n        return new TextEncoder().encode(this.client_secret);\n    }\n    async grant(body, { clientAssertionPayload, DPoP } = {}, retry) {\n        assertIssuerConfiguration(this.issuer, \"token_endpoint\");\n        const response = await authenticatedPost.call(this, \"token\", {\n            form: body,\n            responseType: \"json\"\n        }, {\n            clientAssertionPayload,\n            DPoP\n        });\n        let responseBody;\n        try {\n            responseBody = processResponse(response);\n        } catch (err) {\n            if (retry !== retryAttempt && err instanceof OPError && err.error === \"use_dpop_nonce\") {\n                return this.grant(body, {\n                    clientAssertionPayload,\n                    DPoP\n                }, retryAttempt);\n            }\n            throw err;\n        }\n        return new TokenSet(responseBody);\n    }\n    async deviceAuthorization(params = {}, { exchangeBody, clientAssertionPayload, DPoP } = {}) {\n        assertIssuerConfiguration(this.issuer, \"device_authorization_endpoint\");\n        assertIssuerConfiguration(this.issuer, \"token_endpoint\");\n        const body = authorizationParams.call(this, {\n            client_id: this.client_id,\n            redirect_uri: null,\n            response_type: null,\n            ...params\n        });\n        const response = await authenticatedPost.call(this, \"device_authorization\", {\n            responseType: \"json\",\n            form: body\n        }, {\n            clientAssertionPayload,\n            endpointAuthMethod: \"token\"\n        });\n        const responseBody = processResponse(response);\n        return new DeviceFlowHandle({\n            client: this,\n            exchangeBody,\n            clientAssertionPayload,\n            response: responseBody,\n            maxAge: params.max_age,\n            DPoP\n        });\n    }\n    async revoke(token, hint, { revokeBody, clientAssertionPayload } = {}) {\n        assertIssuerConfiguration(this.issuer, \"revocation_endpoint\");\n        if (hint !== undefined && typeof hint !== \"string\") {\n            throw new TypeError(\"hint must be a string\");\n        }\n        const form = {\n            ...revokeBody,\n            token\n        };\n        if (hint) {\n            form.token_type_hint = hint;\n        }\n        const response = await authenticatedPost.call(this, \"revocation\", {\n            form\n        }, {\n            clientAssertionPayload\n        });\n        processResponse(response, {\n            body: false\n        });\n    }\n    async introspect(token, hint, { introspectBody, clientAssertionPayload } = {}) {\n        assertIssuerConfiguration(this.issuer, \"introspection_endpoint\");\n        if (hint !== undefined && typeof hint !== \"string\") {\n            throw new TypeError(\"hint must be a string\");\n        }\n        const form = {\n            ...introspectBody,\n            token\n        };\n        if (hint) {\n            form.token_type_hint = hint;\n        }\n        const response = await authenticatedPost.call(this, \"introspection\", {\n            form,\n            responseType: \"json\"\n        }, {\n            clientAssertionPayload\n        });\n        const responseBody = processResponse(response);\n        return responseBody;\n    }\n    static async register(metadata, options = {}) {\n        const { initialAccessToken, jwks, ...clientOptions } = options;\n        assertIssuerConfiguration(this.issuer, \"registration_endpoint\");\n        if (jwks !== undefined && !(metadata.jwks || metadata.jwks_uri)) {\n            const keystore = await getKeystore.call(this, jwks);\n            metadata.jwks = keystore.toJWKS();\n        }\n        const response = await request.call(this, {\n            headers: {\n                Accept: \"application/json\",\n                ...initialAccessToken ? {\n                    Authorization: authorizationHeaderValue(initialAccessToken)\n                } : undefined\n            },\n            responseType: \"json\",\n            json: metadata,\n            url: this.issuer.registration_endpoint,\n            method: \"POST\"\n        });\n        const responseBody = processResponse(response, {\n            statusCode: 201,\n            bearer: true\n        });\n        return new this(responseBody, jwks, clientOptions);\n    }\n    get metadata() {\n        return clone(Object.fromEntries(this.#metadata.entries()));\n    }\n    static async fromUri(registrationClientUri, registrationAccessToken, jwks, clientOptions) {\n        const response = await request.call(this, {\n            method: \"GET\",\n            url: registrationClientUri,\n            responseType: \"json\",\n            headers: {\n                Authorization: authorizationHeaderValue(registrationAccessToken),\n                Accept: \"application/json\"\n            }\n        });\n        const responseBody = processResponse(response, {\n            bearer: true\n        });\n        return new this(responseBody, jwks, clientOptions);\n    }\n    async requestObject(requestObject = {}, { sign: signingAlgorithm = this.request_object_signing_alg || \"none\", encrypt: { alg: eKeyManagement = this.request_object_encryption_alg, enc: eContentEncryption = this.request_object_encryption_enc || \"A128CBC-HS256\" } = {} } = {}) {\n        if (!isPlainObject(requestObject)) {\n            throw new TypeError(\"requestObject must be a plain object\");\n        }\n        let signed;\n        let key;\n        const unix = now();\n        const header = {\n            alg: signingAlgorithm,\n            typ: \"oauth-authz-req+jwt\"\n        };\n        const payload = JSON.stringify(defaults({}, requestObject, {\n            iss: this.client_id,\n            aud: this.issuer.issuer,\n            client_id: this.client_id,\n            jti: random(),\n            iat: unix,\n            exp: unix + 300,\n            ...this.fapi() ? {\n                nbf: unix\n            } : undefined\n        }));\n        if (signingAlgorithm === \"none\") {\n            signed = [\n                base64url.encode(JSON.stringify(header)),\n                base64url.encode(payload),\n                \"\"\n            ].join(\".\");\n        } else {\n            const symmetric = signingAlgorithm.startsWith(\"HS\");\n            if (symmetric) {\n                key = this.secretForAlg(signingAlgorithm);\n            } else {\n                const keystore = await keystores.get(this);\n                if (!keystore) {\n                    throw new TypeError(`no keystore present for client, cannot sign using alg ${signingAlgorithm}`);\n                }\n                key = keystore.get({\n                    alg: signingAlgorithm,\n                    use: \"sig\"\n                });\n                if (!key) {\n                    throw new TypeError(`no key to sign with found for alg ${signingAlgorithm}`);\n                }\n            }\n            signed = await new jose.CompactSign(new TextEncoder().encode(payload)).setProtectedHeader({\n                ...header,\n                kid: symmetric ? undefined : key.jwk.kid\n            }).sign(symmetric ? key : await key.keyObject(signingAlgorithm));\n        }\n        if (!eKeyManagement) {\n            return signed;\n        }\n        const fields = {\n            alg: eKeyManagement,\n            enc: eContentEncryption,\n            cty: \"oauth-authz-req+jwt\"\n        };\n        if (fields.alg.match(/^(RSA|ECDH)/)) {\n            [key] = await queryKeyStore.call(this.issuer, {\n                alg: fields.alg,\n                use: \"enc\"\n            }, {\n                allowMulti: true\n            });\n        } else {\n            key = this.secretForAlg(fields.alg === \"dir\" ? fields.enc : fields.alg);\n        }\n        return new jose.CompactEncrypt(new TextEncoder().encode(signed)).setProtectedHeader({\n            ...fields,\n            kid: key instanceof Uint8Array ? undefined : key.jwk.kid\n        }).encrypt(key instanceof Uint8Array ? key : await key.keyObject(fields.alg));\n    }\n    async pushedAuthorizationRequest(params = {}, { clientAssertionPayload } = {}) {\n        assertIssuerConfiguration(this.issuer, \"pushed_authorization_request_endpoint\");\n        const body = {\n            ...\"request\" in params ? params : authorizationParams.call(this, params),\n            client_id: this.client_id\n        };\n        const response = await authenticatedPost.call(this, \"pushed_authorization_request\", {\n            responseType: \"json\",\n            form: body\n        }, {\n            clientAssertionPayload,\n            endpointAuthMethod: \"token\"\n        });\n        const responseBody = processResponse(response, {\n            statusCode: 201\n        });\n        if (!(\"expires_in\" in responseBody)) {\n            throw new RPError({\n                message: \"expected expires_in in Pushed Authorization Successful Response\",\n                response\n            });\n        }\n        if (typeof responseBody.expires_in !== \"number\") {\n            throw new RPError({\n                message: \"invalid expires_in value in Pushed Authorization Successful Response\",\n                response\n            });\n        }\n        if (!(\"request_uri\" in responseBody)) {\n            throw new RPError({\n                message: \"expected request_uri in Pushed Authorization Successful Response\",\n                response\n            });\n        }\n        if (typeof responseBody.request_uri !== \"string\") {\n            throw new RPError({\n                message: \"invalid request_uri value in Pushed Authorization Successful Response\",\n                response\n            });\n        }\n        return responseBody;\n    }\n    get issuer() {\n        return this.#issuer;\n    }\n    /* istanbul ignore next */ [inspect.custom]() {\n        return `${this.constructor.name} ${inspect(this.metadata, {\n            depth: Infinity,\n            colors: process.stdout.isTTY,\n            compact: false,\n            sorted: true\n        })}`;\n    }\n    fapi() {\n        return this.fapi1() || this.fapi2();\n    }\n    fapi1() {\n        return this.constructor.name === \"FAPI1Client\";\n    }\n    fapi2() {\n        return this.constructor.name === \"FAPI2Client\";\n    }\n    async validateJARM(response) {\n        const expectedAlg = this.authorization_signed_response_alg;\n        const { payload } = await this.validateJWT(response, expectedAlg, [\n            \"iss\",\n            \"exp\",\n            \"aud\"\n        ]);\n        return pickCb(payload);\n    }\n    /**\n   * @name dpopProof\n   * @api private\n   */ async dpopProof(payload, privateKeyInput, accessToken) {\n        if (!isPlainObject(payload)) {\n            throw new TypeError(\"payload must be a plain object\");\n        }\n        let privateKey;\n        if (isKeyObject(privateKeyInput)) {\n            privateKey = privateKeyInput;\n        } else if (privateKeyInput[Symbol.toStringTag] === \"CryptoKey\") {\n            privateKey = privateKeyInput;\n        } else if (jose.cryptoRuntime === \"node:crypto\") {\n            privateKey = crypto.createPrivateKey(privateKeyInput);\n        } else {\n            throw new TypeError(\"unrecognized crypto runtime\");\n        }\n        if (privateKey.type !== \"private\") {\n            throw new TypeError('\"DPoP\" option must be a private key');\n        }\n        let alg = determineDPoPAlgorithm.call(this, privateKey, privateKeyInput);\n        if (!alg) {\n            throw new TypeError(\"could not determine DPoP JWS Algorithm\");\n        }\n        return new jose.SignJWT({\n            ath: accessToken ? base64url.encode(crypto.createHash(\"sha256\").update(accessToken).digest()) : undefined,\n            ...payload\n        }).setProtectedHeader({\n            alg,\n            typ: \"dpop+jwt\",\n            jwk: await getJwk(privateKey, privateKeyInput)\n        }).setIssuedAt().setJti(random()).sign(privateKey);\n    }\n}\nfunction determineDPoPAlgorithmFromCryptoKey(cryptoKey) {\n    switch(cryptoKey.algorithm.name){\n        case \"Ed25519\":\n        case \"Ed448\":\n            return \"EdDSA\";\n        case \"ECDSA\":\n            {\n                switch(cryptoKey.algorithm.namedCurve){\n                    case \"P-256\":\n                        return \"ES256\";\n                    case \"P-384\":\n                        return \"ES384\";\n                    case \"P-521\":\n                        return \"ES512\";\n                    default:\n                        break;\n                }\n                break;\n            }\n        case \"RSASSA-PKCS1-v1_5\":\n            return `RS${cryptoKey.algorithm.hash.name.slice(4)}`;\n        case \"RSA-PSS\":\n            return `PS${cryptoKey.algorithm.hash.name.slice(4)}`;\n        default:\n            throw new TypeError(\"unsupported DPoP private key\");\n    }\n}\nlet determineDPoPAlgorithm;\nif (jose.cryptoRuntime === \"node:crypto\") {\n    determineDPoPAlgorithm = function(privateKey, privateKeyInput) {\n        if (privateKeyInput[Symbol.toStringTag] === \"CryptoKey\") {\n            return determineDPoPAlgorithmFromCryptoKey(privateKey);\n        }\n        switch(privateKey.asymmetricKeyType){\n            case \"ed25519\":\n            case \"ed448\":\n                return \"EdDSA\";\n            case \"ec\":\n                return determineEcAlgorithm(privateKey, privateKeyInput);\n            case \"rsa\":\n            case rsaPssParams && \"rsa-pss\":\n                return determineRsaAlgorithm(privateKey, privateKeyInput, this.issuer.dpop_signing_alg_values_supported);\n            default:\n                throw new TypeError(\"unsupported DPoP private key\");\n        }\n    };\n    const RSPS = /^(?:RS|PS)(?:256|384|512)$/;\n    function determineRsaAlgorithm(privateKey, privateKeyInput, valuesSupported) {\n        if (typeof privateKeyInput === \"object\" && privateKeyInput.format === \"jwk\" && privateKeyInput.key && privateKeyInput.key.alg) {\n            return privateKeyInput.key.alg;\n        }\n        if (Array.isArray(valuesSupported)) {\n            let candidates = valuesSupported.filter(RegExp.prototype.test.bind(RSPS));\n            if (privateKey.asymmetricKeyType === \"rsa-pss\") {\n                candidates = candidates.filter((value)=>value.startsWith(\"PS\"));\n            }\n            return [\n                \"PS256\",\n                \"PS384\",\n                \"PS512\",\n                \"RS256\",\n                \"RS384\",\n                \"RS384\"\n            ].find((preferred)=>candidates.includes(preferred));\n        }\n        return \"PS256\";\n    }\n    const p256 = Buffer.from([\n        42,\n        134,\n        72,\n        206,\n        61,\n        3,\n        1,\n        7\n    ]);\n    const p384 = Buffer.from([\n        43,\n        129,\n        4,\n        0,\n        34\n    ]);\n    const p521 = Buffer.from([\n        43,\n        129,\n        4,\n        0,\n        35\n    ]);\n    const secp256k1 = Buffer.from([\n        43,\n        129,\n        4,\n        0,\n        10\n    ]);\n    function determineEcAlgorithm(privateKey, privateKeyInput) {\n        // If input was a JWK\n        switch(typeof privateKeyInput === \"object\" && typeof privateKeyInput.key === \"object\" && privateKeyInput.key.crv){\n            case \"P-256\":\n                return \"ES256\";\n            case \"secp256k1\":\n                return \"ES256K\";\n            case \"P-384\":\n                return \"ES384\";\n            case \"P-512\":\n                return \"ES512\";\n            default:\n                break;\n        }\n        const buf = privateKey.export({\n            format: \"der\",\n            type: \"pkcs8\"\n        });\n        const i = buf[1] < 128 ? 17 : 18;\n        const len = buf[i];\n        const curveOid = buf.slice(i + 1, i + 1 + len);\n        if (curveOid.equals(p256)) {\n            return \"ES256\";\n        }\n        if (curveOid.equals(p384)) {\n            return \"ES384\";\n        }\n        if (curveOid.equals(p521)) {\n            return \"ES512\";\n        }\n        if (curveOid.equals(secp256k1)) {\n            return \"ES256K\";\n        }\n        throw new TypeError(\"unsupported DPoP private key curve\");\n    }\n} else {\n    determineDPoPAlgorithm = determineDPoPAlgorithmFromCryptoKey;\n}\nconst jwkCache = new WeakMap();\nasync function getJwk(keyObject, privateKeyInput) {\n    if (jose.cryptoRuntime === \"node:crypto\" && typeof privateKeyInput === \"object\" && typeof privateKeyInput.key === \"object\" && privateKeyInput.format === \"jwk\") {\n        return pick(privateKeyInput.key, \"kty\", \"crv\", \"x\", \"y\", \"e\", \"n\");\n    }\n    if (jwkCache.has(privateKeyInput)) {\n        return jwkCache.get(privateKeyInput);\n    }\n    const jwk = pick(await jose.exportJWK(keyObject), \"kty\", \"crv\", \"x\", \"y\", \"e\", \"n\");\n    if (isKeyObject(privateKeyInput) || jose.cryptoRuntime === \"WebCryptoAPI\") {\n        jwkCache.set(privateKeyInput, jwk);\n    }\n    return jwk;\n}\nmodule.exports = (issuer, aadIssValidation = false)=>class Client extends BaseClient {\n        constructor(...args){\n            super(issuer, aadIssValidation, ...args);\n        }\n        static get issuer() {\n            return issuer;\n        }\n    };\nmodule.exports.BaseClient = BaseClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2NsaWVudC5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxFQUFFQSxPQUFPLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDNUIsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUM7QUFDeEIsTUFBTUUsU0FBU0YsbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUFFRyxRQUFRQyxNQUFNLEVBQUUsR0FBR0osbUJBQU9BLENBQUM7QUFDbkMsTUFBTUssY0FBY0wsbUJBQU9BLENBQUM7QUFDNUIsTUFBTU0sTUFBTU4sbUJBQU9BLENBQUM7QUFDcEIsTUFBTSxFQUFFTyxHQUFHLEVBQUVDLGVBQWUsRUFBRSxHQUFHUixtQkFBT0EsQ0FBQztBQUV6QyxNQUFNUyxPQUFPVCxtQkFBT0EsQ0FBQztBQUNyQixNQUFNVSxZQUFZVixtQkFBT0EsQ0FBQztBQUUxQixNQUFNVyxjQUFjWCxtQkFBT0EsQ0FBQztBQUM1QixNQUFNWSxZQUFZWixtQkFBT0EsQ0FBQztBQUMxQixNQUFNYSxZQUFZYixtQkFBT0EsQ0FBQztBQUMxQixNQUFNYyxXQUFXZCxtQkFBT0EsQ0FBQztBQUN6QixNQUFNZSx1QkFBdUJmLG1CQUFPQSxDQUFDO0FBQ3JDLE1BQU0sRUFBRWdCLDZCQUE2QixFQUFFQyx5QkFBeUIsRUFBRSxHQUFHakIsbUJBQU9BLENBQUM7QUFDN0UsTUFBTWtCLE9BQU9sQixtQkFBT0EsQ0FBQztBQUNyQixNQUFNbUIsZ0JBQWdCbkIsbUJBQU9BLENBQUM7QUFDOUIsTUFBTW9CLGtCQUFrQnBCLG1CQUFPQSxDQUFDO0FBQ2hDLE1BQU1xQixXQUFXckIsbUJBQU9BLENBQUM7QUFDekIsTUFBTSxFQUFFc0IsT0FBTyxFQUFFQyxPQUFPLEVBQUUsR0FBR3ZCLG1CQUFPQSxDQUFDO0FBQ3JDLE1BQU13QixNQUFNeEIsbUJBQU9BLENBQUM7QUFDcEIsTUFBTSxFQUFFeUIsTUFBTSxFQUFFLEdBQUd6QixtQkFBT0EsQ0FBQztB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O1FBRUEsV0FBV3JULFNBQVM7WUFDbEIsT0FBT0E7UUFDVDtJQUNGO0FBRUZrVCx5QkFBeUIsR0FBR2xTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWRzdS1ob3VzZS1wdWJsaWMvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2NsaWVudC5qcz9iMTk0Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgaW5zcGVjdCB9ID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3Qgc3RkaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3QgeyBzdHJpY3Q6IGFzc2VydCB9ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5jb25zdCBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5jb25zdCB1cmwgPSByZXF1aXJlKCd1cmwnKTtcbmNvbnN0IHsgVVJMLCBVUkxTZWFyY2hQYXJhbXMgfSA9IHJlcXVpcmUoJ3VybCcpO1xuXG5jb25zdCBqb3NlID0gcmVxdWlyZSgnam9zZScpO1xuY29uc3QgdG9rZW5IYXNoID0gcmVxdWlyZSgnb2lkYy10b2tlbi1oYXNoJyk7XG5cbmNvbnN0IGlzS2V5T2JqZWN0ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzX2tleV9vYmplY3QnKTtcbmNvbnN0IGRlY29kZUpXVCA9IHJlcXVpcmUoJy4vaGVscGVycy9kZWNvZGVfand0Jyk7XG5jb25zdCBiYXNlNjR1cmwgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmFzZTY0dXJsJyk7XG5jb25zdCBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vaGVscGVycy9kZWZhdWx0cycpO1xuY29uc3QgcGFyc2VXd3dBdXRoZW50aWNhdGUgPSByZXF1aXJlKCcuL2hlbHBlcnMvd3d3X2F1dGhlbnRpY2F0ZV9wYXJzZXInKTtcbmNvbnN0IHsgYXNzZXJ0U2lnbmluZ0FsZ1ZhbHVlc1N1cHBvcnQsIGFzc2VydElzc3VlckNvbmZpZ3VyYXRpb24gfSA9IHJlcXVpcmUoJy4vaGVscGVycy9hc3NlcnQnKTtcbmNvbnN0IHBpY2sgPSByZXF1aXJlKCcuL2hlbHBlcnMvcGljaycpO1xuY29uc3QgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vaGVscGVycy9pc19wbGFpbl9vYmplY3QnKTtcbmNvbnN0IHByb2Nlc3NSZXNwb25zZSA9IHJlcXVpcmUoJy4vaGVscGVycy9wcm9jZXNzX3Jlc3BvbnNlJyk7XG5jb25zdCBUb2tlblNldCA9IHJlcXVpcmUoJy4vdG9rZW5fc2V0Jyk7XG5jb25zdCB7IE9QRXJyb3IsIFJQRXJyb3IgfSA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBub3cgPSByZXF1aXJlKCcuL2hlbHBlcnMvdW5peF90aW1lc3RhbXAnKTtcbmNvbnN0IHsgcmFuZG9tIH0gPSByZXF1aXJlKCcuL2hlbHBlcnMvZ2VuZXJhdG9ycycpO1xuY29uc3QgcmVxdWVzdCA9IHJlcXVpcmUoJy4vaGVscGVycy9yZXF1ZXN0Jyk7XG5jb25zdCB7IENMT0NLX1RPTEVSQU5DRSB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2NvbnN0cycpO1xuY29uc3QgeyBrZXlzdG9yZXMgfSA9IHJlcXVpcmUoJy4vaGVscGVycy93ZWFrX2NhY2hlJyk7XG5jb25zdCBLZXlTdG9yZSA9IHJlcXVpcmUoJy4vaGVscGVycy9rZXlzdG9yZScpO1xuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuL2hlbHBlcnMvZGVlcF9jbG9uZScpO1xuY29uc3QgeyBhdXRoZW50aWNhdGVkUG9zdCwgcmVzb2x2ZVJlc3BvbnNlVHlwZSwgcmVzb2x2ZVJlZGlyZWN0VXJpIH0gPSByZXF1aXJlKCcuL2hlbHBlcnMvY2xpZW50Jyk7XG5jb25zdCB7IHF1ZXJ5S2V5U3RvcmUgfSA9IHJlcXVpcmUoJy4vaGVscGVycy9pc3N1ZXInKTtcbmNvbnN0IERldmljZUZsb3dIYW5kbGUgPSByZXF1aXJlKCcuL2RldmljZV9mbG93X2hhbmRsZScpO1xuXG5jb25zdCBbbWFqb3IsIG1pbm9yXSA9IHByb2Nlc3MudmVyc2lvblxuICAuc2xpY2UoMSlcbiAgLnNwbGl0KCcuJylcbiAgLm1hcCgoc3RyKSA9PiBwYXJzZUludChzdHIsIDEwKSk7XG5cbmNvbnN0IHJzYVBzc1BhcmFtcyA9IG1ham9yID49IDE3IHx8IChtYWpvciA9PT0gMTYgJiYgbWlub3IgPj0gOSk7XG5jb25zdCByZXRyeUF0dGVtcHQgPSBTeW1ib2woKTtcbmNvbnN0IHNraXBOb25jZUNoZWNrID0gU3ltYm9sKCk7XG5jb25zdCBza2lwTWF4QWdlQ2hlY2sgPSBTeW1ib2woKTtcblxuZnVuY3Rpb24gcGlja0NiKGlucHV0KSB7XG4gIHJldHVybiBwaWNrKFxuICAgIGlucHV0LFxuICAgICdhY2Nlc3NfdG9rZW4nLCAvLyBPQXV0aCAyLjBcbiAgICAnY29kZScsIC8vIE9BdXRoIDIuMFxuICAgICdlcnJvcl9kZXNjcmlwdGlvbicsIC8vIE9BdXRoIDIuMFxuICAgICdlcnJvcl91cmknLCAvLyBPQXV0aCAyLjBcbiAgICAnZXJyb3InLCAvLyBPQXV0aCAyLjBcbiAgICAnZXhwaXJlc19pbicsIC8vIE9BdXRoIDIuMFxuICAgICdpZF90b2tlbicsIC8vIE9JREMgQ29yZSAxLjBcbiAgICAnaXNzJywgLy8gZHJhZnQtaWV0Zi1vYXV0aC1pc3MtYXV0aC1yZXNwXG4gICAgJ3Jlc3BvbnNlJywgLy8gRkFQSSBKQVJNXG4gICAgJ3Nlc3Npb25fc3RhdGUnLCAvLyBPSURDIFNlc3Npb24gTWFuYWdlbWVudFxuICAgICdzdGF0ZScsIC8vIE9BdXRoIDIuMFxuICAgICd0b2tlbl90eXBlJywgLy8gT0F1dGggMi4wXG4gICk7XG59XG5cbmZ1bmN0aW9uIGF1dGhvcml6YXRpb25IZWFkZXJWYWx1ZSh0b2tlbiwgdG9rZW5UeXBlID0gJ0JlYXJlcicpIHtcbiAgcmV0dXJuIGAke3Rva2VuVHlwZX0gJHt0b2tlbn1gO1xufVxuXG5mdW5jdGlvbiBnZXRTZWFyY2hQYXJhbXMoaW5wdXQpIHtcbiAgY29uc3QgcGFyc2VkID0gdXJsLnBhcnNlKGlucHV0KTtcbiAgaWYgKCFwYXJzZWQuc2VhcmNoKSByZXR1cm4ge307XG4gIHJldHVybiBxdWVyeXN0cmluZy5wYXJzZShwYXJzZWQuc2VhcmNoLnN1YnN0cmluZygxKSk7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeVByZXNlbmNlKHBheWxvYWQsIGp3dCwgcHJvcCkge1xuICBpZiAocGF5bG9hZFtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYG1pc3NpbmcgcmVxdWlyZWQgSldUIHByb3BlcnR5ICR7cHJvcH1gLFxuICAgICAgand0LFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGF1dGhvcml6YXRpb25QYXJhbXMocGFyYW1zKSB7XG4gIGNvbnN0IGF1dGhQYXJhbXMgPSB7XG4gICAgY2xpZW50X2lkOiB0aGlzLmNsaWVudF9pZCxcbiAgICBzY29wZTogJ29wZW5pZCcsXG4gICAgcmVzcG9uc2VfdHlwZTogcmVzb2x2ZVJlc3BvbnNlVHlwZS5jYWxsKHRoaXMpLFxuICAgIHJlZGlyZWN0X3VyaTogcmVzb2x2ZVJlZGlyZWN0VXJpLmNhbGwodGhpcyksXG4gICAgLi4ucGFyYW1zLFxuICB9O1xuXG4gIE9iamVjdC5lbnRyaWVzKGF1dGhQYXJhbXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWxldGUgYXV0aFBhcmFtc1trZXldO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnY2xhaW1zJyAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBhdXRoUGFyYW1zW2tleV0gPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdyZXNvdXJjZScgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGF1dGhQYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgYXV0aFBhcmFtc1trZXldID0gU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBhdXRoUGFyYW1zO1xufVxuXG5mdW5jdGlvbiBnZXRLZXlzdG9yZShqd2tzKSB7XG4gIGlmIChcbiAgICAhaXNQbGFpbk9iamVjdChqd2tzKSB8fFxuICAgICFBcnJheS5pc0FycmF5KGp3a3Mua2V5cykgfHxcbiAgICBqd2tzLmtleXMuc29tZSgoaykgPT4gIWlzUGxhaW5PYmplY3QoaykgfHwgISgna3R5JyBpbiBrKSlcbiAgKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignandrcyBtdXN0IGJlIGEgSlNPTiBXZWIgS2V5IFNldCBmb3JtYXR0ZWQgb2JqZWN0Jyk7XG4gIH1cblxuICByZXR1cm4gS2V5U3RvcmUuZnJvbUpXS1MoandrcywgeyBvbmx5UHJpdmF0ZTogdHJ1ZSB9KTtcbn1cblxuLy8gaWYgYW4gT1AgZG9lc250IHN1cHBvcnQgY2xpZW50X3NlY3JldF9iYXNpYyBidXQgc3VwcG9ydHMgY2xpZW50X3NlY3JldF9wb3N0LCB1c2UgaXQgaW5zdGVhZFxuLy8gdGhpcyBpcyBpbiBwbGFjZSB0byB0YWtlIGNhcmUgb2YgbW9zdCBjb21tb24gcGl0ZmFsbHMgd2hlbiBmaXJzdCB1c2luZyBkaXNjb3ZlcmVkIElzc3VlcnMgd2l0aG91dFxuLy8gdGhlIHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzIGRlZmluZWQgYnkgRGlzY292ZXJ5IDEuMFxuZnVuY3Rpb24gY2hlY2tCYXNpY1N1cHBvcnQoY2xpZW50LCBwcm9wZXJ0aWVzKSB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3VwcG9ydGVkID0gY2xpZW50Lmlzc3Vlci50b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZHNfc3VwcG9ydGVkO1xuICAgIGlmICghc3VwcG9ydGVkLmluY2x1ZGVzKHByb3BlcnRpZXMudG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2QpKSB7XG4gICAgICBpZiAoc3VwcG9ydGVkLmluY2x1ZGVzKCdjbGllbnRfc2VjcmV0X3Bvc3QnKSkge1xuICAgICAgICBwcm9wZXJ0aWVzLnRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kID0gJ2NsaWVudF9zZWNyZXRfcG9zdCc7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHt9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUNvbW1vbk1pc3Rha2VzKGNsaWVudCwgbWV0YWRhdGEsIHByb3BlcnRpZXMpIHtcbiAgaWYgKCFtZXRhZGF0YS50b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZCkge1xuICAgIC8vIGlmIG5vIGV4cGxpY2l0IHZhbHVlIHdhcyBwcm92aWRlZFxuICAgIGNoZWNrQmFzaWNTdXBwb3J0KGNsaWVudCwgcHJvcGVydGllcyk7XG4gIH1cblxuICAvLyA6ZnA6IGMnbW9uIHBlb3BsZS4uLiBSVEZNXG4gIGlmIChtZXRhZGF0YS5yZWRpcmVjdF91cmkpIHtcbiAgICBpZiAobWV0YWRhdGEucmVkaXJlY3RfdXJpcykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJvdmlkZSBhIHJlZGlyZWN0X3VyaSBvciByZWRpcmVjdF91cmlzLCBub3QgYm90aCcpO1xuICAgIH1cbiAgICBwcm9wZXJ0aWVzLnJlZGlyZWN0X3VyaXMgPSBbbWV0YWRhdGEucmVkaXJlY3RfdXJpXTtcbiAgICBkZWxldGUgcHJvcGVydGllcy5yZWRpcmVjdF91cmk7XG4gIH1cblxuICBpZiAobWV0YWRhdGEucmVzcG9uc2VfdHlwZSkge1xuICAgIGlmIChtZXRhZGF0YS5yZXNwb25zZV90eXBlcykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJvdmlkZSBhIHJlc3BvbnNlX3R5cGUgb3IgcmVzcG9uc2VfdHlwZXMsIG5vdCBib3RoJyk7XG4gICAgfVxuICAgIHByb3BlcnRpZXMucmVzcG9uc2VfdHlwZXMgPSBbbWV0YWRhdGEucmVzcG9uc2VfdHlwZV07XG4gICAgZGVsZXRlIHByb3BlcnRpZXMucmVzcG9uc2VfdHlwZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0c0ZvckVuZHBvaW50KGVuZHBvaW50LCBpc3N1ZXIsIHByb3BlcnRpZXMpIHtcbiAgaWYgKCFpc3N1ZXJbYCR7ZW5kcG9pbnR9X2VuZHBvaW50YF0pIHJldHVybjtcblxuICBjb25zdCB0b2tlbkVuZHBvaW50QXV0aE1ldGhvZCA9IHByb3BlcnRpZXMudG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2Q7XG4gIGNvbnN0IHRva2VuRW5kcG9pbnRBdXRoU2lnbmluZ0FsZyA9IHByb3BlcnRpZXMudG9rZW5fZW5kcG9pbnRfYXV0aF9zaWduaW5nX2FsZztcblxuICBjb25zdCBlYW0gPSBgJHtlbmRwb2ludH1fZW5kcG9pbnRfYXV0aF9tZXRob2RgO1xuICBjb25zdCBlYXNhID0gYCR7ZW5kcG9pbnR9X2VuZHBvaW50X2F1dGhfc2lnbmluZ19hbGdgO1xuXG4gIGlmIChwcm9wZXJ0aWVzW2VhbV0gPT09IHVuZGVmaW5lZCAmJiBwcm9wZXJ0aWVzW2Vhc2FdID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodG9rZW5FbmRwb2ludEF1dGhNZXRob2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcHJvcGVydGllc1tlYW1dID0gdG9rZW5FbmRwb2ludEF1dGhNZXRob2Q7XG4gICAgfVxuICAgIGlmICh0b2tlbkVuZHBvaW50QXV0aFNpZ25pbmdBbGcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcHJvcGVydGllc1tlYXNhXSA9IHRva2VuRW5kcG9pbnRBdXRoU2lnbmluZ0FsZztcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgQmFzZUNsaWVudCB7XG4gICNtZXRhZGF0YTtcbiAgI2lzc3VlcjtcbiAgI2FhZElzc1ZhbGlkYXRpb247XG4gICNhZGRpdGlvbmFsQXV0aG9yaXplZFBhcnRpZXM7XG4gIGNvbnN0cnVjdG9yKGlzc3VlciwgYWFkSXNzVmFsaWRhdGlvbiwgbWV0YWRhdGEgPSB7fSwgandrcywgb3B0aW9ucykge1xuICAgIHRoaXMuI21ldGFkYXRhID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuI2lzc3VlciA9IGlzc3VlcjtcbiAgICB0aGlzLiNhYWRJc3NWYWxpZGF0aW9uID0gYWFkSXNzVmFsaWRhdGlvbjtcblxuICAgIGlmICh0eXBlb2YgbWV0YWRhdGEuY2xpZW50X2lkICE9PSAnc3RyaW5nJyB8fCAhbWV0YWRhdGEuY2xpZW50X2lkKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjbGllbnRfaWQgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgZ3JhbnRfdHlwZXM6IFsnYXV0aG9yaXphdGlvbl9jb2RlJ10sXG4gICAgICBpZF90b2tlbl9zaWduZWRfcmVzcG9uc2VfYWxnOiAnUlMyNTYnLFxuICAgICAgYXV0aG9yaXphdGlvbl9zaWduZWRfcmVzcG9uc2VfYWxnOiAnUlMyNTYnLFxuICAgICAgcmVzcG9uc2VfdHlwZXM6IFsnY29kZSddLFxuICAgICAgdG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2Q6ICdjbGllbnRfc2VjcmV0X2Jhc2ljJyxcbiAgICAgIC4uLih0aGlzLmZhcGkxKClcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBncmFudF90eXBlczogWydhdXRob3JpemF0aW9uX2NvZGUnLCAnaW1wbGljaXQnXSxcbiAgICAgICAgICAgIGlkX3Rva2VuX3NpZ25lZF9yZXNwb25zZV9hbGc6ICdQUzI1NicsXG4gICAgICAgICAgICBhdXRob3JpemF0aW9uX3NpZ25lZF9yZXNwb25zZV9hbGc6ICdQUzI1NicsXG4gICAgICAgICAgICByZXNwb25zZV90eXBlczogWydjb2RlIGlkX3Rva2VuJ10sXG4gICAgICAgICAgICB0bHNfY2xpZW50X2NlcnRpZmljYXRlX2JvdW5kX2FjY2Vzc190b2tlbnM6IHRydWUsXG4gICAgICAgICAgICB0b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZDogdW5kZWZpbmVkLFxuICAgICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQpLFxuICAgICAgLi4uKHRoaXMuZmFwaTIoKVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGlkX3Rva2VuX3NpZ25lZF9yZXNwb25zZV9hbGc6ICdQUzI1NicsXG4gICAgICAgICAgICBhdXRob3JpemF0aW9uX3NpZ25lZF9yZXNwb25zZV9hbGc6ICdQUzI1NicsXG4gICAgICAgICAgICB0b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZDogdW5kZWZpbmVkLFxuICAgICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQpLFxuICAgICAgLi4ubWV0YWRhdGEsXG4gICAgfTtcblxuICAgIGlmICh0aGlzLmZhcGkoKSkge1xuICAgICAgc3dpdGNoIChwcm9wZXJ0aWVzLnRva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kKSB7XG4gICAgICAgIGNhc2UgJ3NlbGZfc2lnbmVkX3Rsc19jbGllbnRfYXV0aCc6XG4gICAgICAgIGNhc2UgJ3Rsc19jbGllbnRfYXV0aCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3ByaXZhdGVfa2V5X2p3dCc6XG4gICAgICAgICAgaWYgKCFqd2tzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdqd2tzIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZCBpcyByZXF1aXJlZCcpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgb3IgdW5zdXBwb3J0ZWQgdG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2QnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5mYXBpMigpKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHByb3BlcnRpZXMudGxzX2NsaWVudF9jZXJ0aWZpY2F0ZV9ib3VuZF9hY2Nlc3NfdG9rZW5zICYmXG4gICAgICAgIHByb3BlcnRpZXMuZHBvcF9ib3VuZF9hY2Nlc3NfdG9rZW5zXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnZWl0aGVyIHRsc19jbGllbnRfY2VydGlmaWNhdGVfYm91bmRfYWNjZXNzX3Rva2VucyBvciBkcG9wX2JvdW5kX2FjY2Vzc190b2tlbnMgbXVzdCBiZSBzZXQgdG8gdHJ1ZScsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgIXByb3BlcnRpZXMudGxzX2NsaWVudF9jZXJ0aWZpY2F0ZV9ib3VuZF9hY2Nlc3NfdG9rZW5zICYmXG4gICAgICAgICFwcm9wZXJ0aWVzLmRwb3BfYm91bmRfYWNjZXNzX3Rva2Vuc1xuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ2VpdGhlciB0bHNfY2xpZW50X2NlcnRpZmljYXRlX2JvdW5kX2FjY2Vzc190b2tlbnMgb3IgZHBvcF9ib3VuZF9hY2Nlc3NfdG9rZW5zIG11c3QgYmUgc2V0IHRvIHRydWUnLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZUNvbW1vbk1pc3Rha2VzKHRoaXMsIG1ldGFkYXRhLCBwcm9wZXJ0aWVzKTtcblxuICAgIGFzc2VydFNpZ25pbmdBbGdWYWx1ZXNTdXBwb3J0KCd0b2tlbicsIHRoaXMuaXNzdWVyLCBwcm9wZXJ0aWVzKTtcbiAgICBbJ2ludHJvc3BlY3Rpb24nLCAncmV2b2NhdGlvbiddLmZvckVhY2goKGVuZHBvaW50KSA9PiB7XG4gICAgICBnZXREZWZhdWx0c0ZvckVuZHBvaW50KGVuZHBvaW50LCB0aGlzLmlzc3VlciwgcHJvcGVydGllcyk7XG4gICAgICBhc3NlcnRTaWduaW5nQWxnVmFsdWVzU3VwcG9ydChlbmRwb2ludCwgdGhpcy5pc3N1ZXIsIHByb3BlcnRpZXMpO1xuICAgIH0pO1xuXG4gICAgT2JqZWN0LmVudHJpZXMocHJvcGVydGllcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICB0aGlzLiNtZXRhZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICBpZiAoIXRoaXNba2V5XSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI21ldGFkYXRhLmdldChrZXkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoandrcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBrZXlzdG9yZSA9IGdldEtleXN0b3JlLmNhbGwodGhpcywgandrcyk7XG4gICAgICBrZXlzdG9yZXMuc2V0KHRoaXMsIGtleXN0b3JlKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuYWRkaXRpb25hbEF1dGhvcml6ZWRQYXJ0aWVzKSB7XG4gICAgICB0aGlzLiNhZGRpdGlvbmFsQXV0aG9yaXplZFBhcnRpZXMgPSBjbG9uZShvcHRpb25zLmFkZGl0aW9uYWxBdXRob3JpemVkUGFydGllcyk7XG4gICAgfVxuXG4gICAgdGhpc1tDTE9DS19UT0xFUkFOQ0VdID0gMDtcbiAgfVxuXG4gIGF1dGhvcml6YXRpb25VcmwocGFyYW1zID0ge30pIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QocGFyYW1zKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1zIG11c3QgYmUgYSBwbGFpbiBvYmplY3QnKTtcbiAgICB9XG4gICAgYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbih0aGlzLmlzc3VlciwgJ2F1dGhvcml6YXRpb25fZW5kcG9pbnQnKTtcbiAgICBjb25zdCB0YXJnZXQgPSBuZXcgVVJMKHRoaXMuaXNzdWVyLmF1dGhvcml6YXRpb25fZW5kcG9pbnQpO1xuXG4gICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGF1dGhvcml6YXRpb25QYXJhbXMuY2FsbCh0aGlzLCBwYXJhbXMpKSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHRhcmdldC5zZWFyY2hQYXJhbXMuZGVsZXRlKG5hbWUpO1xuICAgICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiB2YWx1ZSkge1xuICAgICAgICAgIHRhcmdldC5zZWFyY2hQYXJhbXMuYXBwZW5kKG5hbWUsIG1lbWJlcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldC5zZWFyY2hQYXJhbXMuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBpcyB0aGUgcmVwbGFjZSBuZWVkZWQ/XG4gICAgcmV0dXJuIHRhcmdldC5ocmVmLnJlcGxhY2UoL1xcKy9nLCAnJTIwJyk7XG4gIH1cblxuICBhdXRob3JpemF0aW9uUG9zdChwYXJhbXMgPSB7fSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChwYXJhbXMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbXMgbXVzdCBiZSBhIHBsYWluIG9iamVjdCcpO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dHMgPSBhdXRob3JpemF0aW9uUGFyYW1zLmNhbGwodGhpcywgcGFyYW1zKTtcbiAgICBjb25zdCBmb3JtSW5wdXRzID0gT2JqZWN0LmtleXMoaW5wdXRzKVxuICAgICAgLm1hcCgobmFtZSkgPT4gYDxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgbmFtZT1cIiR7bmFtZX1cIiB2YWx1ZT1cIiR7aW5wdXRzW25hbWVdfVwiLz5gKVxuICAgICAgLmpvaW4oJ1xcbicpO1xuXG4gICAgcmV0dXJuIGA8IURPQ1RZUEUgaHRtbD5cbjxoZWFkPlxuPHRpdGxlPlJlcXVlc3RpbmcgQXV0aG9yaXphdGlvbjwvdGl0bGU+XG48L2hlYWQ+XG48Ym9keSBvbmxvYWQ9XCJqYXZhc2NyaXB0OmRvY3VtZW50LmZvcm1zWzBdLnN1Ym1pdCgpXCI+XG48Zm9ybSBtZXRob2Q9XCJwb3N0XCIgYWN0aW9uPVwiJHt0aGlzLmlzc3Vlci5hdXRob3JpemF0aW9uX2VuZHBvaW50fVwiPlxuICAke2Zvcm1JbnB1dHN9XG48L2Zvcm0+XG48L2JvZHk+XG48L2h0bWw+YDtcbiAgfVxuXG4gIGVuZFNlc3Npb25VcmwocGFyYW1zID0ge30pIHtcbiAgICBhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uKHRoaXMuaXNzdWVyLCAnZW5kX3Nlc3Npb25fZW5kcG9pbnQnKTtcblxuICAgIGNvbnN0IHsgMDogcG9zdExvZ291dCwgbGVuZ3RoIH0gPSB0aGlzLnBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaXMgfHwgW107XG5cbiAgICBjb25zdCB7IHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSA9IGxlbmd0aCA9PT0gMSA/IHBvc3RMb2dvdXQgOiB1bmRlZmluZWQgfSA9IHBhcmFtcztcblxuICAgIGxldCBpZF90b2tlbl9oaW50O1xuICAgICh7IGlkX3Rva2VuX2hpbnQsIC4uLnBhcmFtcyB9ID0gcGFyYW1zKTtcbiAgICBpZiAoaWRfdG9rZW5faGludCBpbnN0YW5jZW9mIFRva2VuU2V0KSB7XG4gICAgICBpZiAoIWlkX3Rva2VuX2hpbnQuaWRfdG9rZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaWRfdG9rZW4gbm90IHByZXNlbnQgaW4gVG9rZW5TZXQnKTtcbiAgICAgIH1cbiAgICAgIGlkX3Rva2VuX2hpbnQgPSBpZF90b2tlbl9oaW50LmlkX3Rva2VuO1xuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9IHVybC5wYXJzZSh0aGlzLmlzc3Vlci5lbmRfc2Vzc2lvbl9lbmRwb2ludCk7XG4gICAgY29uc3QgcXVlcnkgPSBkZWZhdWx0cyhcbiAgICAgIGdldFNlYXJjaFBhcmFtcyh0aGlzLmlzc3Vlci5lbmRfc2Vzc2lvbl9lbmRwb2ludCksXG4gICAgICBwYXJhbXMsXG4gICAgICB7XG4gICAgICAgIHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSxcbiAgICAgICAgY2xpZW50X2lkOiB0aGlzLmNsaWVudF9pZCxcbiAgICAgIH0sXG4gICAgICB7IGlkX3Rva2VuX2hpbnQgfSxcbiAgICApO1xuXG4gICAgT2JqZWN0LmVudHJpZXMocXVlcnkpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVsZXRlIHF1ZXJ5W2tleV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0YXJnZXQuc2VhcmNoID0gbnVsbDtcbiAgICB0YXJnZXQucXVlcnkgPSBxdWVyeTtcblxuICAgIHJldHVybiB1cmwuZm9ybWF0KHRhcmdldCk7XG4gIH1cblxuICBjYWxsYmFja1BhcmFtcyhpbnB1dCkge1xuICAgIGNvbnN0IGlzSW5jb21pbmdNZXNzYWdlID1cbiAgICAgIGlucHV0IGluc3RhbmNlb2Ygc3RkaHR0cC5JbmNvbWluZ01lc3NhZ2UgfHwgKGlucHV0ICYmIGlucHV0Lm1ldGhvZCAmJiBpbnB1dC51cmwpO1xuICAgIGNvbnN0IGlzU3RyaW5nID0gdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJztcblxuICAgIGlmICghaXNTdHJpbmcgJiYgIWlzSW5jb21pbmdNZXNzYWdlKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnI2NhbGxiYWNrUGFyYW1zIG9ubHkgYWNjZXB0cyBzdHJpbmcgdXJscywgaHR0cC5JbmNvbWluZ01lc3NhZ2Ugb3IgYSBsb29rYWxpa2UnLFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGlzSW5jb21pbmdNZXNzYWdlKSB7XG4gICAgICBzd2l0Y2ggKGlucHV0Lm1ldGhvZCkge1xuICAgICAgICBjYXNlICdHRVQnOlxuICAgICAgICAgIHJldHVybiBwaWNrQ2IoZ2V0U2VhcmNoUGFyYW1zKGlucHV0LnVybCkpO1xuICAgICAgICBjYXNlICdQT1NUJzpcbiAgICAgICAgICBpZiAoaW5wdXQuYm9keSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAnaW5jb21pbmcgbWVzc2FnZSBib2R5IG1pc3NpbmcsIGluY2x1ZGUgYSBib2R5IHBhcnNlciBwcmlvciB0byB0aGlzIG1ldGhvZCBjYWxsJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGlucHV0LmJvZHkpIHtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGlucHV0LmJvZHkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBpY2tDYihxdWVyeXN0cmluZy5wYXJzZShpbnB1dC5ib2R5LnRvU3RyaW5nKCd1dGYtOCcpKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dC5ib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBwaWNrQ2IocXVlcnlzdHJpbmcucGFyc2UoaW5wdXQuYm9keSkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHBpY2tDYihpbnB1dC5ib2R5KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgSW5jb21pbmdNZXNzYWdlIGJvZHkgb2JqZWN0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgSW5jb21pbmdNZXNzYWdlIG1ldGhvZCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGlja0NiKGdldFNlYXJjaFBhcmFtcyhpbnB1dCkpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGNhbGxiYWNrKFxuICAgIHJlZGlyZWN0VXJpLFxuICAgIHBhcmFtZXRlcnMsXG4gICAgY2hlY2tzID0ge30sXG4gICAgeyBleGNoYW5nZUJvZHksIGNsaWVudEFzc2VydGlvblBheWxvYWQsIERQb1AgfSA9IHt9LFxuICApIHtcbiAgICBsZXQgcGFyYW1zID0gcGlja0NiKHBhcmFtZXRlcnMpO1xuXG4gICAgaWYgKGNoZWNrcy5qYXJtICYmICEoJ3Jlc3BvbnNlJyBpbiBwYXJhbWV0ZXJzKSkge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiAnZXhwZWN0ZWQgYSBKQVJNIHJlc3BvbnNlJyxcbiAgICAgICAgY2hlY2tzLFxuICAgICAgICBwYXJhbXMsXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCdyZXNwb25zZScgaW4gcGFyYW1ldGVycykge1xuICAgICAgY29uc3QgZGVjcnlwdGVkID0gYXdhaXQgdGhpcy5kZWNyeXB0SkFSTShwYXJhbXMucmVzcG9uc2UpO1xuICAgICAgcGFyYW1zID0gYXdhaXQgdGhpcy52YWxpZGF0ZUpBUk0oZGVjcnlwdGVkKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kZWZhdWx0X21heF9hZ2UgJiYgIWNoZWNrcy5tYXhfYWdlKSB7XG4gICAgICBjaGVja3MubWF4X2FnZSA9IHRoaXMuZGVmYXVsdF9tYXhfYWdlO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuc3RhdGUgJiYgIWNoZWNrcy5zdGF0ZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2hlY2tzLnN0YXRlIGFyZ3VtZW50IGlzIG1pc3NpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5zdGF0ZSAmJiBjaGVja3Muc3RhdGUpIHtcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogJ3N0YXRlIG1pc3NpbmcgZnJvbSB0aGUgcmVzcG9uc2UnLFxuICAgICAgICBjaGVja3MsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChjaGVja3Muc3RhdGUgIT09IHBhcmFtcy5zdGF0ZSkge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICBwcmludGY6IFsnc3RhdGUgbWlzbWF0Y2gsIGV4cGVjdGVkICVzLCBnb3Q6ICVzJywgY2hlY2tzLnN0YXRlLCBwYXJhbXMuc3RhdGVdLFxuICAgICAgICBjaGVja3MsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICgnaXNzJyBpbiBwYXJhbXMpIHtcbiAgICAgIGFzc2VydElzc3VlckNvbmZpZ3VyYXRpb24odGhpcy5pc3N1ZXIsICdpc3N1ZXInKTtcbiAgICAgIGlmIChwYXJhbXMuaXNzICE9PSB0aGlzLmlzc3Vlci5pc3N1ZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgIHByaW50ZjogWydpc3MgbWlzbWF0Y2gsIGV4cGVjdGVkICVzLCBnb3Q6ICVzJywgdGhpcy5pc3N1ZXIuaXNzdWVyLCBwYXJhbXMuaXNzXSxcbiAgICAgICAgICBwYXJhbXMsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0aGlzLmlzc3Vlci5hdXRob3JpemF0aW9uX3Jlc3BvbnNlX2lzc19wYXJhbWV0ZXJfc3VwcG9ydGVkICYmXG4gICAgICAhKCdpZF90b2tlbicgaW4gcGFyYW1zKSAmJlxuICAgICAgISgncmVzcG9uc2UnIGluIHBhcmFtZXRlcnMpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6ICdpc3MgbWlzc2luZyBmcm9tIHRoZSByZXNwb25zZScsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBPUEVycm9yKHBhcmFtcyk7XG4gICAgfVxuXG4gICAgY29uc3QgUkVTUE9OU0VfVFlQRV9SRVFVSVJFRF9QQVJBTVMgPSB7XG4gICAgICBjb2RlOiBbJ2NvZGUnXSxcbiAgICAgIGlkX3Rva2VuOiBbJ2lkX3Rva2VuJ10sXG4gICAgICB0b2tlbjogWydhY2Nlc3NfdG9rZW4nLCAndG9rZW5fdHlwZSddLFxuICAgIH07XG5cbiAgICBpZiAoY2hlY2tzLnJlc3BvbnNlX3R5cGUpIHtcbiAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBjaGVja3MucmVzcG9uc2VfdHlwZS5zcGxpdCgnICcpKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnbm9uZScpIHtcbiAgICAgICAgICBpZiAocGFyYW1zLmNvZGUgfHwgcGFyYW1zLmlkX3Rva2VuIHx8IHBhcmFtcy5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ3VuZXhwZWN0ZWQgcGFyYW1zIGVuY291bnRlcmVkIGZvciBcIm5vbmVcIiByZXNwb25zZScsXG4gICAgICAgICAgICAgIGNoZWNrcyxcbiAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3QgcGFyYW0gb2YgUkVTUE9OU0VfVFlQRV9SRVFVSVJFRF9QQVJBTVNbdHlwZV0pIHtcbiAgICAgICAgICAgIGlmICghcGFyYW1zW3BhcmFtXSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYCR7cGFyYW19IG1pc3NpbmcgZnJvbSByZXNwb25zZWAsXG4gICAgICAgICAgICAgICAgY2hlY2tzLFxuICAgICAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5pZF90b2tlbikge1xuICAgICAgY29uc3QgdG9rZW5zZXQgPSBuZXcgVG9rZW5TZXQocGFyYW1zKTtcbiAgICAgIGF3YWl0IHRoaXMuZGVjcnlwdElkVG9rZW4odG9rZW5zZXQpO1xuICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZUlkVG9rZW4oXG4gICAgICAgIHRva2Vuc2V0LFxuICAgICAgICBjaGVja3Mubm9uY2UsXG4gICAgICAgICdhdXRob3JpemF0aW9uJyxcbiAgICAgICAgY2hlY2tzLm1heF9hZ2UsXG4gICAgICAgIGNoZWNrcy5zdGF0ZSxcbiAgICAgICk7XG5cbiAgICAgIGlmICghcGFyYW1zLmNvZGUpIHtcbiAgICAgICAgcmV0dXJuIHRva2Vuc2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXJhbXMuY29kZSkge1xuICAgICAgY29uc3QgdG9rZW5zZXQgPSBhd2FpdCB0aGlzLmdyYW50KFxuICAgICAgICB7XG4gICAgICAgICAgLi4uZXhjaGFuZ2VCb2R5LFxuICAgICAgICAgIGdyYW50X3R5cGU6ICdhdXRob3JpemF0aW9uX2NvZGUnLFxuICAgICAgICAgIGNvZGU6IHBhcmFtcy5jb2RlLFxuICAgICAgICAgIHJlZGlyZWN0X3VyaTogcmVkaXJlY3RVcmksXG4gICAgICAgICAgY29kZV92ZXJpZmllcjogY2hlY2tzLmNvZGVfdmVyaWZpZXIsXG4gICAgICAgIH0sXG4gICAgICAgIHsgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCwgRFBvUCB9LFxuICAgICAgKTtcblxuICAgICAgYXdhaXQgdGhpcy5kZWNyeXB0SWRUb2tlbih0b2tlbnNldCk7XG4gICAgICBhd2FpdCB0aGlzLnZhbGlkYXRlSWRUb2tlbih0b2tlbnNldCwgY2hlY2tzLm5vbmNlLCAndG9rZW4nLCBjaGVja3MubWF4X2FnZSk7XG5cbiAgICAgIGlmIChwYXJhbXMuc2Vzc2lvbl9zdGF0ZSkge1xuICAgICAgICB0b2tlbnNldC5zZXNzaW9uX3N0YXRlID0gcGFyYW1zLnNlc3Npb25fc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b2tlbnNldDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFRva2VuU2V0KHBhcmFtcyk7XG4gIH1cblxuICBhc3luYyBvYXV0aENhbGxiYWNrKFxuICAgIHJlZGlyZWN0VXJpLFxuICAgIHBhcmFtZXRlcnMsXG4gICAgY2hlY2tzID0ge30sXG4gICAgeyBleGNoYW5nZUJvZHksIGNsaWVudEFzc2VydGlvblBheWxvYWQsIERQb1AgfSA9IHt9LFxuICApIHtcbiAgICBsZXQgcGFyYW1zID0gcGlja0NiKHBhcmFtZXRlcnMpO1xuXG4gICAgaWYgKGNoZWNrcy5qYXJtICYmICEoJ3Jlc3BvbnNlJyBpbiBwYXJhbWV0ZXJzKSkge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiAnZXhwZWN0ZWQgYSBKQVJNIHJlc3BvbnNlJyxcbiAgICAgICAgY2hlY2tzLFxuICAgICAgICBwYXJhbXMsXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCdyZXNwb25zZScgaW4gcGFyYW1ldGVycykge1xuICAgICAgY29uc3QgZGVjcnlwdGVkID0gYXdhaXQgdGhpcy5kZWNyeXB0SkFSTShwYXJhbXMucmVzcG9uc2UpO1xuICAgICAgcGFyYW1zID0gYXdhaXQgdGhpcy52YWxpZGF0ZUpBUk0oZGVjcnlwdGVkKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLnN0YXRlICYmICFjaGVja3Muc3RhdGUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NoZWNrcy5zdGF0ZSBhcmd1bWVudCBpcyBtaXNzaW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJhbXMuc3RhdGUgJiYgY2hlY2tzLnN0YXRlKSB7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6ICdzdGF0ZSBtaXNzaW5nIGZyb20gdGhlIHJlc3BvbnNlJyxcbiAgICAgICAgY2hlY2tzLFxuICAgICAgICBwYXJhbXMsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tzLnN0YXRlICE9PSBwYXJhbXMuc3RhdGUpIHtcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgcHJpbnRmOiBbJ3N0YXRlIG1pc21hdGNoLCBleHBlY3RlZCAlcywgZ290OiAlcycsIGNoZWNrcy5zdGF0ZSwgcGFyYW1zLnN0YXRlXSxcbiAgICAgICAgY2hlY2tzLFxuICAgICAgICBwYXJhbXMsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoJ2lzcycgaW4gcGFyYW1zKSB7XG4gICAgICBhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uKHRoaXMuaXNzdWVyLCAnaXNzdWVyJyk7XG4gICAgICBpZiAocGFyYW1zLmlzcyAhPT0gdGhpcy5pc3N1ZXIuaXNzdWVyKSB7XG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgICBwcmludGY6IFsnaXNzIG1pc21hdGNoLCBleHBlY3RlZCAlcywgZ290OiAlcycsIHRoaXMuaXNzdWVyLmlzc3VlciwgcGFyYW1zLmlzc10sXG4gICAgICAgICAgcGFyYW1zLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdGhpcy5pc3N1ZXIuYXV0aG9yaXphdGlvbl9yZXNwb25zZV9pc3NfcGFyYW1ldGVyX3N1cHBvcnRlZCAmJlxuICAgICAgISgnaWRfdG9rZW4nIGluIHBhcmFtcykgJiZcbiAgICAgICEoJ3Jlc3BvbnNlJyBpbiBwYXJhbWV0ZXJzKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiAnaXNzIG1pc3NpbmcgZnJvbSB0aGUgcmVzcG9uc2UnLFxuICAgICAgICBwYXJhbXMsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgT1BFcnJvcihwYXJhbXMpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcGFyYW1zLmlkX3Rva2VuID09PSAnc3RyaW5nJyAmJiBwYXJhbXMuaWRfdG9rZW4ubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgJ2lkX3Rva2VuIGRldGVjdGVkIGluIHRoZSByZXNwb25zZSwgeW91IG11c3QgdXNlIGNsaWVudC5jYWxsYmFjaygpIGluc3RlYWQgb2YgY2xpZW50Lm9hdXRoQ2FsbGJhY2soKScsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBkZWxldGUgcGFyYW1zLmlkX3Rva2VuO1xuXG4gICAgY29uc3QgUkVTUE9OU0VfVFlQRV9SRVFVSVJFRF9QQVJBTVMgPSB7XG4gICAgICBjb2RlOiBbJ2NvZGUnXSxcbiAgICAgIHRva2VuOiBbJ2FjY2Vzc190b2tlbicsICd0b2tlbl90eXBlJ10sXG4gICAgfTtcblxuICAgIGlmIChjaGVja3MucmVzcG9uc2VfdHlwZSkge1xuICAgICAgZm9yIChjb25zdCB0eXBlIG9mIGNoZWNrcy5yZXNwb25zZV90eXBlLnNwbGl0KCcgJykpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdub25lJykge1xuICAgICAgICAgIGlmIChwYXJhbXMuY29kZSB8fCBwYXJhbXMuaWRfdG9rZW4gfHwgcGFyYW1zLmFjY2Vzc190b2tlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgICAgICBtZXNzYWdlOiAndW5leHBlY3RlZCBwYXJhbXMgZW5jb3VudGVyZWQgZm9yIFwibm9uZVwiIHJlc3BvbnNlJyxcbiAgICAgICAgICAgICAgY2hlY2tzLFxuICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoUkVTUE9OU0VfVFlQRV9SRVFVSVJFRF9QQVJBTVNbdHlwZV0pIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIFJFU1BPTlNFX1RZUEVfUkVRVUlSRURfUEFSQU1TW3R5cGVdKSB7XG4gICAgICAgICAgICBpZiAoIXBhcmFtc1twYXJhbV0pIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGAke3BhcmFtfSBtaXNzaW5nIGZyb20gcmVzcG9uc2VgLFxuICAgICAgICAgICAgICAgIGNoZWNrcyxcbiAgICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXJhbXMuY29kZSkge1xuICAgICAgY29uc3QgdG9rZW5zZXQgPSBhd2FpdCB0aGlzLmdyYW50KFxuICAgICAgICB7XG4gICAgICAgICAgLi4uZXhjaGFuZ2VCb2R5LFxuICAgICAgICAgIGdyYW50X3R5cGU6ICdhdXRob3JpemF0aW9uX2NvZGUnLFxuICAgICAgICAgIGNvZGU6IHBhcmFtcy5jb2RlLFxuICAgICAgICAgIHJlZGlyZWN0X3VyaTogcmVkaXJlY3RVcmksXG4gICAgICAgICAgY29kZV92ZXJpZmllcjogY2hlY2tzLmNvZGVfdmVyaWZpZXIsXG4gICAgICAgIH0sXG4gICAgICAgIHsgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCwgRFBvUCB9LFxuICAgICAgKTtcblxuICAgICAgaWYgKHR5cGVvZiB0b2tlbnNldC5pZF90b2tlbiA9PT0gJ3N0cmluZycgJiYgdG9rZW5zZXQuaWRfdG9rZW4ubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgJ2lkX3Rva2VuIGRldGVjdGVkIGluIHRoZSByZXNwb25zZSwgeW91IG11c3QgdXNlIGNsaWVudC5jYWxsYmFjaygpIGluc3RlYWQgb2YgY2xpZW50Lm9hdXRoQ2FsbGJhY2soKScsXG4gICAgICAgICAgcGFyYW1zLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0b2tlbnNldC5pZF90b2tlbjtcblxuICAgICAgcmV0dXJuIHRva2Vuc2V0O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVG9rZW5TZXQocGFyYW1zKTtcbiAgfVxuXG4gIGFzeW5jIGRlY3J5cHRJZFRva2VuKHRva2VuKSB7XG4gICAgaWYgKCF0aGlzLmlkX3Rva2VuX2VuY3J5cHRlZF9yZXNwb25zZV9hbGcpIHtcbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG5cbiAgICBsZXQgaWRUb2tlbiA9IHRva2VuO1xuXG4gICAgaWYgKGlkVG9rZW4gaW5zdGFuY2VvZiBUb2tlblNldCkge1xuICAgICAgaWYgKCFpZFRva2VuLmlkX3Rva2VuKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lkX3Rva2VuIG5vdCBwcmVzZW50IGluIFRva2VuU2V0Jyk7XG4gICAgICB9XG4gICAgICBpZFRva2VuID0gaWRUb2tlbi5pZF90b2tlbjtcbiAgICB9XG5cbiAgICBjb25zdCBleHBlY3RlZEFsZyA9IHRoaXMuaWRfdG9rZW5fZW5jcnlwdGVkX3Jlc3BvbnNlX2FsZztcbiAgICBjb25zdCBleHBlY3RlZEVuYyA9IHRoaXMuaWRfdG9rZW5fZW5jcnlwdGVkX3Jlc3BvbnNlX2VuYztcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZGVjcnlwdEpXRShpZFRva2VuLCBleHBlY3RlZEFsZywgZXhwZWN0ZWRFbmMpO1xuXG4gICAgaWYgKHRva2VuIGluc3RhbmNlb2YgVG9rZW5TZXQpIHtcbiAgICAgIHRva2VuLmlkX3Rva2VuID0gcmVzdWx0O1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBhc3luYyB2YWxpZGF0ZUpXVFVzZXJpbmZvKGJvZHkpIHtcbiAgICBjb25zdCBleHBlY3RlZEFsZyA9IHRoaXMudXNlcmluZm9fc2lnbmVkX3Jlc3BvbnNlX2FsZztcblxuICAgIHJldHVybiB0aGlzLnZhbGlkYXRlSldUKGJvZHksIGV4cGVjdGVkQWxnLCBbXSk7XG4gIH1cblxuICBhc3luYyBkZWNyeXB0SkFSTShyZXNwb25zZSkge1xuICAgIGlmICghdGhpcy5hdXRob3JpemF0aW9uX2VuY3J5cHRlZF9yZXNwb25zZV9hbGcpIHtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG5cbiAgICBjb25zdCBleHBlY3RlZEFsZyA9IHRoaXMuYXV0aG9yaXphdGlvbl9lbmNyeXB0ZWRfcmVzcG9uc2VfYWxnO1xuICAgIGNvbnN0IGV4cGVjdGVkRW5jID0gdGhpcy5hdXRob3JpemF0aW9uX2VuY3J5cHRlZF9yZXNwb25zZV9lbmM7XG5cbiAgICByZXR1cm4gdGhpcy5kZWNyeXB0SldFKHJlc3BvbnNlLCBleHBlY3RlZEFsZywgZXhwZWN0ZWRFbmMpO1xuICB9XG5cbiAgYXN5bmMgZGVjcnlwdEpXVFVzZXJpbmZvKGJvZHkpIHtcbiAgICBpZiAoIXRoaXMudXNlcmluZm9fZW5jcnlwdGVkX3Jlc3BvbnNlX2FsZykge1xuICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfVxuXG4gICAgY29uc3QgZXhwZWN0ZWRBbGcgPSB0aGlzLnVzZXJpbmZvX2VuY3J5cHRlZF9yZXNwb25zZV9hbGc7XG4gICAgY29uc3QgZXhwZWN0ZWRFbmMgPSB0aGlzLnVzZXJpbmZvX2VuY3J5cHRlZF9yZXNwb25zZV9lbmM7XG5cbiAgICByZXR1cm4gdGhpcy5kZWNyeXB0SldFKGJvZHksIGV4cGVjdGVkQWxnLCBleHBlY3RlZEVuYyk7XG4gIH1cblxuICBhc3luYyBkZWNyeXB0SldFKGp3ZSwgZXhwZWN0ZWRBbGcsIGV4cGVjdGVkRW5jID0gJ0ExMjhDQkMtSFMyNTYnKSB7XG4gICAgY29uc3QgaGVhZGVyID0gSlNPTi5wYXJzZShiYXNlNjR1cmwuZGVjb2RlKGp3ZS5zcGxpdCgnLicpWzBdKSk7XG5cbiAgICBpZiAoaGVhZGVyLmFsZyAhPT0gZXhwZWN0ZWRBbGcpIHtcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgcHJpbnRmOiBbJ3VuZXhwZWN0ZWQgSldFIGFsZyByZWNlaXZlZCwgZXhwZWN0ZWQgJXMsIGdvdDogJXMnLCBleHBlY3RlZEFsZywgaGVhZGVyLmFsZ10sXG4gICAgICAgIGp3dDogandlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGhlYWRlci5lbmMgIT09IGV4cGVjdGVkRW5jKSB7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgIHByaW50ZjogWyd1bmV4cGVjdGVkIEpXRSBlbmMgcmVjZWl2ZWQsIGV4cGVjdGVkICVzLCBnb3Q6ICVzJywgZXhwZWN0ZWRFbmMsIGhlYWRlci5lbmNdLFxuICAgICAgICBqd3Q6IGp3ZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGdldFBsYWludGV4dCA9IChyZXN1bHQpID0+IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShyZXN1bHQucGxhaW50ZXh0KTtcbiAgICBsZXQgcGxhaW50ZXh0O1xuICAgIGlmIChleHBlY3RlZEFsZy5tYXRjaCgvXig/OlJTQXxFQ0RIKS8pKSB7XG4gICAgICBjb25zdCBrZXlzdG9yZSA9IGF3YWl0IGtleXN0b3Jlcy5nZXQodGhpcyk7XG5cbiAgICAgIGNvbnN0IHByb3RlY3RlZEhlYWRlciA9IGpvc2UuZGVjb2RlUHJvdGVjdGVkSGVhZGVyKGp3ZSk7XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXN0b3JlLmFsbCh7XG4gICAgICAgIC4uLnByb3RlY3RlZEhlYWRlcixcbiAgICAgICAgdXNlOiAnZW5jJyxcbiAgICAgIH0pKSB7XG4gICAgICAgIHBsYWludGV4dCA9IGF3YWl0IGpvc2VcbiAgICAgICAgICAuY29tcGFjdERlY3J5cHQoandlLCBhd2FpdCBrZXkua2V5T2JqZWN0KHByb3RlY3RlZEhlYWRlci5hbGcpKVxuICAgICAgICAgIC50aGVuKGdldFBsYWludGV4dCwgKCkgPT4ge30pO1xuICAgICAgICBpZiAocGxhaW50ZXh0KSBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGxhaW50ZXh0ID0gYXdhaXQgam9zZVxuICAgICAgICAuY29tcGFjdERlY3J5cHQoandlLCB0aGlzLnNlY3JldEZvckFsZyhleHBlY3RlZEFsZyA9PT0gJ2RpcicgPyBleHBlY3RlZEVuYyA6IGV4cGVjdGVkQWxnKSlcbiAgICAgICAgLnRoZW4oZ2V0UGxhaW50ZXh0LCAoKSA9PiB7fSk7XG4gICAgfVxuXG4gICAgaWYgKCFwbGFpbnRleHQpIHtcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogJ2ZhaWxlZCB0byBkZWNyeXB0IEpXRScsXG4gICAgICAgIGp3dDogandlLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwbGFpbnRleHQ7XG4gIH1cblxuICBhc3luYyB2YWxpZGF0ZUlkVG9rZW4odG9rZW5TZXQsIG5vbmNlLCByZXR1cm5lZEJ5LCBtYXhBZ2UsIHN0YXRlKSB7XG4gICAgbGV0IGlkVG9rZW4gPSB0b2tlblNldDtcblxuICAgIGNvbnN0IGV4cGVjdGVkQWxnID0gdGhpcy5pZF90b2tlbl9zaWduZWRfcmVzcG9uc2VfYWxnO1xuXG4gICAgY29uc3QgaXNUb2tlblNldCA9IGlkVG9rZW4gaW5zdGFuY2VvZiBUb2tlblNldDtcblxuICAgIGlmIChpc1Rva2VuU2V0KSB7XG4gICAgICBpZiAoIWlkVG9rZW4uaWRfdG9rZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaWRfdG9rZW4gbm90IHByZXNlbnQgaW4gVG9rZW5TZXQnKTtcbiAgICAgIH1cbiAgICAgIGlkVG9rZW4gPSBpZFRva2VuLmlkX3Rva2VuO1xuICAgIH1cblxuICAgIGlkVG9rZW4gPSBTdHJpbmcoaWRUb2tlbik7XG5cbiAgICBjb25zdCB0aW1lc3RhbXAgPSBub3coKTtcbiAgICBjb25zdCB7IHByb3RlY3RlZDogaGVhZGVyLCBwYXlsb2FkLCBrZXkgfSA9IGF3YWl0IHRoaXMudmFsaWRhdGVKV1QoaWRUb2tlbiwgZXhwZWN0ZWRBbGcpO1xuXG4gICAgaWYgKHR5cGVvZiBtYXhBZ2UgPT09ICdudW1iZXInIHx8IChtYXhBZ2UgIT09IHNraXBNYXhBZ2VDaGVjayAmJiB0aGlzLnJlcXVpcmVfYXV0aF90aW1lKSkge1xuICAgICAgaWYgKCFwYXlsb2FkLmF1dGhfdGltZSkge1xuICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogJ21pc3NpbmcgcmVxdWlyZWQgSldUIHByb3BlcnR5IGF1dGhfdGltZScsXG4gICAgICAgICAgand0OiBpZFRva2VuLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcGF5bG9hZC5hdXRoX3RpbWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiAnSldUIGF1dGhfdGltZSBjbGFpbSBtdXN0IGJlIGEgSlNPTiBudW1lcmljIHZhbHVlJyxcbiAgICAgICAgICBqd3Q6IGlkVG9rZW4sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBtYXhBZ2UgPT09ICdudW1iZXInICYmXG4gICAgICBwYXlsb2FkLmF1dGhfdGltZSArIG1heEFnZSA8IHRpbWVzdGFtcCAtIHRoaXNbQ0xPQ0tfVE9MRVJBTkNFXVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICBwcmludGY6IFtcbiAgICAgICAgICAndG9vIG11Y2ggdGltZSBoYXMgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCBFbmQtVXNlciBhdXRoZW50aWNhdGlvbiwgbWF4X2FnZSAlaSwgYXV0aF90aW1lOiAlaSwgbm93ICVpJyxcbiAgICAgICAgICBtYXhBZ2UsXG4gICAgICAgICAgcGF5bG9hZC5hdXRoX3RpbWUsXG4gICAgICAgICAgdGltZXN0YW1wIC0gdGhpc1tDTE9DS19UT0xFUkFOQ0VdLFxuICAgICAgICBdLFxuICAgICAgICBub3c6IHRpbWVzdGFtcCxcbiAgICAgICAgdG9sZXJhbmNlOiB0aGlzW0NMT0NLX1RPTEVSQU5DRV0sXG4gICAgICAgIGF1dGhfdGltZTogcGF5bG9hZC5hdXRoX3RpbWUsXG4gICAgICAgIGp3dDogaWRUb2tlbixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIG5vbmNlICE9PSBza2lwTm9uY2VDaGVjayAmJlxuICAgICAgKHBheWxvYWQubm9uY2UgfHwgbm9uY2UgIT09IHVuZGVmaW5lZCkgJiZcbiAgICAgIHBheWxvYWQubm9uY2UgIT09IG5vbmNlXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgIHByaW50ZjogWydub25jZSBtaXNtYXRjaCwgZXhwZWN0ZWQgJXMsIGdvdDogJXMnLCBub25jZSwgcGF5bG9hZC5ub25jZV0sXG4gICAgICAgIGp3dDogaWRUb2tlbixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXR1cm5lZEJ5ID09PSAnYXV0aG9yaXphdGlvbicpIHtcbiAgICAgIGlmICghcGF5bG9hZC5hdF9oYXNoICYmIHRva2VuU2V0LmFjY2Vzc190b2tlbikge1xuICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgYXRfaGFzaCcsXG4gICAgICAgICAgand0OiBpZFRva2VuLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwYXlsb2FkLmNfaGFzaCAmJiB0b2tlblNldC5jb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBjX2hhc2gnLFxuICAgICAgICAgIGp3dDogaWRUb2tlbixcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmZhcGkxKCkpIHtcbiAgICAgICAgaWYgKCFwYXlsb2FkLnNfaGFzaCAmJiAodG9rZW5TZXQuc3RhdGUgfHwgc3RhdGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgc19oYXNoJyxcbiAgICAgICAgICAgIGp3dDogaWRUb2tlbixcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGF5bG9hZC5zX2hhc2gpIHtcbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Nhbm5vdCB2ZXJpZnkgc19oYXNoLCBcImNoZWNrcy5zdGF0ZVwiIHByb3BlcnR5IG5vdCBwcm92aWRlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0b2tlbkhhc2gudmFsaWRhdGUoXG4gICAgICAgICAgICB7IGNsYWltOiAnc19oYXNoJywgc291cmNlOiAnc3RhdGUnIH0sXG4gICAgICAgICAgICBwYXlsb2FkLnNfaGFzaCxcbiAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgaGVhZGVyLmFsZyxcbiAgICAgICAgICAgIGtleS5qd2sgJiYga2V5Lmp3ay5jcnYsXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3IoeyBtZXNzYWdlOiBlcnIubWVzc2FnZSwgand0OiBpZFRva2VuIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmFwaSgpICYmIHBheWxvYWQuaWF0IDwgdGltZXN0YW1wIC0gMzYwMCkge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICBwcmludGY6IFsnSldUIGlzc3VlZCB0b28gZmFyIGluIHRoZSBwYXN0LCBub3cgJWksIGlhdCAlaScsIHRpbWVzdGFtcCwgcGF5bG9hZC5pYXRdLFxuICAgICAgICBub3c6IHRpbWVzdGFtcCxcbiAgICAgICAgdG9sZXJhbmNlOiB0aGlzW0NMT0NLX1RPTEVSQU5DRV0sXG4gICAgICAgIGlhdDogcGF5bG9hZC5pYXQsXG4gICAgICAgIGp3dDogaWRUb2tlbixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0b2tlblNldC5hY2Nlc3NfdG9rZW4gJiYgcGF5bG9hZC5hdF9oYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRva2VuSGFzaC52YWxpZGF0ZShcbiAgICAgICAgICB7IGNsYWltOiAnYXRfaGFzaCcsIHNvdXJjZTogJ2FjY2Vzc190b2tlbicgfSxcbiAgICAgICAgICBwYXlsb2FkLmF0X2hhc2gsXG4gICAgICAgICAgdG9rZW5TZXQuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgIGhlYWRlci5hbGcsXG4gICAgICAgICAga2V5Lmp3ayAmJiBrZXkuandrLmNydixcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7IG1lc3NhZ2U6IGVyci5tZXNzYWdlLCBqd3Q6IGlkVG9rZW4gfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRva2VuU2V0LmNvZGUgJiYgcGF5bG9hZC5jX2hhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdG9rZW5IYXNoLnZhbGlkYXRlKFxuICAgICAgICAgIHsgY2xhaW06ICdjX2hhc2gnLCBzb3VyY2U6ICdjb2RlJyB9LFxuICAgICAgICAgIHBheWxvYWQuY19oYXNoLFxuICAgICAgICAgIHRva2VuU2V0LmNvZGUsXG4gICAgICAgICAgaGVhZGVyLmFsZyxcbiAgICAgICAgICBrZXkuandrICYmIGtleS5qd2suY3J2LFxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHsgbWVzc2FnZTogZXJyLm1lc3NhZ2UsIGp3dDogaWRUb2tlbiB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdG9rZW5TZXQ7XG4gIH1cblxuICBhc3luYyB2YWxpZGF0ZUpXVChqd3QsIGV4cGVjdGVkQWxnLCByZXF1aXJlZCA9IFsnaXNzJywgJ3N1YicsICdhdWQnLCAnZXhwJywgJ2lhdCddKSB7XG4gICAgY29uc3QgaXNTZWxmSXNzdWVkID0gdGhpcy5pc3N1ZXIuaXNzdWVyID09PSAnaHR0cHM6Ly9zZWxmLWlzc3VlZC5tZSc7XG4gICAgY29uc3QgdGltZXN0YW1wID0gbm93KCk7XG4gICAgbGV0IGhlYWRlcjtcbiAgICBsZXQgcGF5bG9hZDtcbiAgICB0cnkge1xuICAgICAgKHsgaGVhZGVyLCBwYXlsb2FkIH0gPSBkZWNvZGVKV1Qoand0LCB7IGNvbXBsZXRlOiB0cnVlIH0pKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgcHJpbnRmOiBbJ2ZhaWxlZCB0byBkZWNvZGUgSldUICglczogJXMpJywgZXJyLm5hbWUsIGVyci5tZXNzYWdlXSxcbiAgICAgICAgand0LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGhlYWRlci5hbGcgIT09IGV4cGVjdGVkQWxnKSB7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgIHByaW50ZjogWyd1bmV4cGVjdGVkIEpXVCBhbGcgcmVjZWl2ZWQsIGV4cGVjdGVkICVzLCBnb3Q6ICVzJywgZXhwZWN0ZWRBbGcsIGhlYWRlci5hbGddLFxuICAgICAgICBqd3QsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaXNTZWxmSXNzdWVkKSB7XG4gICAgICByZXF1aXJlZCA9IFsuLi5yZXF1aXJlZCwgJ3N1Yl9qd2snXTtcbiAgICB9XG5cbiAgICByZXF1aXJlZC5mb3JFYWNoKHZlcmlmeVByZXNlbmNlLmJpbmQodW5kZWZpbmVkLCBwYXlsb2FkLCBqd3QpKTtcblxuICAgIGlmIChwYXlsb2FkLmlzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgZXhwZWN0ZWRJc3MgPSB0aGlzLmlzc3Vlci5pc3N1ZXI7XG5cbiAgICAgIGlmICh0aGlzLiNhYWRJc3NWYWxpZGF0aW9uKSB7XG4gICAgICAgIGV4cGVjdGVkSXNzID0gdGhpcy5pc3N1ZXIuaXNzdWVyLnJlcGxhY2UoJ3t0ZW5hbnRpZH0nLCBwYXlsb2FkLnRpZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXlsb2FkLmlzcyAhPT0gZXhwZWN0ZWRJc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgIHByaW50ZjogWyd1bmV4cGVjdGVkIGlzcyB2YWx1ZSwgZXhwZWN0ZWQgJXMsIGdvdDogJXMnLCBleHBlY3RlZElzcywgcGF5bG9hZC5pc3NdLFxuICAgICAgICAgIGp3dCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBheWxvYWQuaWF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF5bG9hZC5pYXQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiAnSldUIGlhdCBjbGFpbSBtdXN0IGJlIGEgSlNPTiBudW1lcmljIHZhbHVlJyxcbiAgICAgICAgICBqd3QsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXlsb2FkLm5iZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIHBheWxvYWQubmJmICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogJ0pXVCBuYmYgY2xhaW0gbXVzdCBiZSBhIEpTT04gbnVtZXJpYyB2YWx1ZScsXG4gICAgICAgICAgand0LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXlsb2FkLm5iZiA+IHRpbWVzdGFtcCArIHRoaXNbQ0xPQ0tfVE9MRVJBTkNFXSkge1xuICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgICAgcHJpbnRmOiBbXG4gICAgICAgICAgICAnSldUIG5vdCBhY3RpdmUgeWV0LCBub3cgJWksIG5iZiAlaScsXG4gICAgICAgICAgICB0aW1lc3RhbXAgKyB0aGlzW0NMT0NLX1RPTEVSQU5DRV0sXG4gICAgICAgICAgICBwYXlsb2FkLm5iZixcbiAgICAgICAgICBdLFxuICAgICAgICAgIG5vdzogdGltZXN0YW1wLFxuICAgICAgICAgIHRvbGVyYW5jZTogdGhpc1tDTE9DS19UT0xFUkFOQ0VdLFxuICAgICAgICAgIG5iZjogcGF5bG9hZC5uYmYsXG4gICAgICAgICAgand0LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGF5bG9hZC5leHAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkLmV4cCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6ICdKV1QgZXhwIGNsYWltIG11c3QgYmUgYSBKU09OIG51bWVyaWMgdmFsdWUnLFxuICAgICAgICAgIGp3dCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodGltZXN0YW1wIC0gdGhpc1tDTE9DS19UT0xFUkFOQ0VdID49IHBheWxvYWQuZXhwKSB7XG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgICBwcmludGY6IFsnSldUIGV4cGlyZWQsIG5vdyAlaSwgZXhwICVpJywgdGltZXN0YW1wIC0gdGhpc1tDTE9DS19UT0xFUkFOQ0VdLCBwYXlsb2FkLmV4cF0sXG4gICAgICAgICAgbm93OiB0aW1lc3RhbXAsXG4gICAgICAgICAgdG9sZXJhbmNlOiB0aGlzW0NMT0NLX1RPTEVSQU5DRV0sXG4gICAgICAgICAgZXhwOiBwYXlsb2FkLmV4cCxcbiAgICAgICAgICBqd3QsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXlsb2FkLmF1ZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkLmF1ZCkpIHtcbiAgICAgICAgaWYgKHBheWxvYWQuYXVkLmxlbmd0aCA+IDEgJiYgIXBheWxvYWQuYXpwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogJ21pc3NpbmcgcmVxdWlyZWQgSldUIHByb3BlcnR5IGF6cCcsXG4gICAgICAgICAgICBqd3QsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXBheWxvYWQuYXVkLmluY2x1ZGVzKHRoaXMuY2xpZW50X2lkKSkge1xuICAgICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgICAgIHByaW50ZjogW1xuICAgICAgICAgICAgICAnYXVkIGlzIG1pc3NpbmcgdGhlIGNsaWVudF9pZCwgZXhwZWN0ZWQgJXMgdG8gYmUgaW5jbHVkZWQgaW4gJWonLFxuICAgICAgICAgICAgICB0aGlzLmNsaWVudF9pZCxcbiAgICAgICAgICAgICAgcGF5bG9hZC5hdWQsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgand0LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBheWxvYWQuYXVkICE9PSB0aGlzLmNsaWVudF9pZCkge1xuICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgICAgcHJpbnRmOiBbJ2F1ZCBtaXNtYXRjaCwgZXhwZWN0ZWQgJXMsIGdvdDogJXMnLCB0aGlzLmNsaWVudF9pZCwgcGF5bG9hZC5hdWRdLFxuICAgICAgICAgIGp3dCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBheWxvYWQuYXpwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCBhZGRpdGlvbmFsQXV0aG9yaXplZFBhcnRpZXMgPSB0aGlzLiNhZGRpdGlvbmFsQXV0aG9yaXplZFBhcnRpZXM7XG5cbiAgICAgIGlmICh0eXBlb2YgYWRkaXRpb25hbEF1dGhvcml6ZWRQYXJ0aWVzID09PSAnc3RyaW5nJykge1xuICAgICAgICBhZGRpdGlvbmFsQXV0aG9yaXplZFBhcnRpZXMgPSBbdGhpcy5jbGllbnRfaWQsIGFkZGl0aW9uYWxBdXRob3JpemVkUGFydGllc107XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYWRkaXRpb25hbEF1dGhvcml6ZWRQYXJ0aWVzKSkge1xuICAgICAgICBhZGRpdGlvbmFsQXV0aG9yaXplZFBhcnRpZXMgPSBbdGhpcy5jbGllbnRfaWQsIC4uLmFkZGl0aW9uYWxBdXRob3JpemVkUGFydGllc107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRpdGlvbmFsQXV0aG9yaXplZFBhcnRpZXMgPSBbdGhpcy5jbGllbnRfaWRdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFkZGl0aW9uYWxBdXRob3JpemVkUGFydGllcy5pbmNsdWRlcyhwYXlsb2FkLmF6cCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgIHByaW50ZjogWydhenAgbWlzbWF0Y2gsIGdvdDogJXMnLCBwYXlsb2FkLmF6cF0sXG4gICAgICAgICAgand0LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQga2V5cztcblxuICAgIGlmIChpc1NlbGZJc3N1ZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGFzc2VydChpc1BsYWluT2JqZWN0KHBheWxvYWQuc3ViX2p3aykpO1xuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBqb3NlLmltcG9ydEpXSyhwYXlsb2FkLnN1Yl9qd2ssIGhlYWRlci5hbGcpO1xuICAgICAgICBhc3NlcnQuZXF1YWwoa2V5LnR5cGUsICdwdWJsaWMnKTtcbiAgICAgICAga2V5cyA9IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXlPYmplY3QoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6ICdmYWlsZWQgdG8gdXNlIHN1Yl9qd2sgY2xhaW0gYXMgYW4gYXN5bW1ldHJpYyBKU09OIFdlYiBLZXknLFxuICAgICAgICAgIGp3dCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoKGF3YWl0IGpvc2UuY2FsY3VsYXRlSndrVGh1bWJwcmludChwYXlsb2FkLnN1Yl9qd2spKSAhPT0gcGF5bG9hZC5zdWIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6ICdmYWlsZWQgdG8gbWF0Y2ggdGhlIHN1YmplY3Qgd2l0aCBzdWJfandrJyxcbiAgICAgICAgICBqd3QsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGVhZGVyLmFsZy5zdGFydHNXaXRoKCdIUycpKSB7XG4gICAgICBrZXlzID0gW3RoaXMuc2VjcmV0Rm9yQWxnKGhlYWRlci5hbGcpXTtcbiAgICB9IGVsc2UgaWYgKGhlYWRlci5hbGcgIT09ICdub25lJykge1xuICAgICAga2V5cyA9IGF3YWl0IHF1ZXJ5S2V5U3RvcmUuY2FsbCh0aGlzLmlzc3VlciwgeyAuLi5oZWFkZXIsIHVzZTogJ3NpZycgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFrZXlzICYmIGhlYWRlci5hbGcgPT09ICdub25lJykge1xuICAgICAgcmV0dXJuIHsgcHJvdGVjdGVkOiBoZWFkZXIsIHBheWxvYWQgfTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBjb25zdCB2ZXJpZmllZCA9IGF3YWl0IGpvc2VcbiAgICAgICAgLmNvbXBhY3RWZXJpZnkoand0LCBrZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8ga2V5IDogYXdhaXQga2V5LmtleU9iamVjdChoZWFkZXIuYWxnKSlcbiAgICAgICAgLmNhdGNoKCgpID0+IHt9KTtcbiAgICAgIGlmICh2ZXJpZmllZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgcHJvdGVjdGVkOiB2ZXJpZmllZC5wcm90ZWN0ZWRIZWFkZXIsXG4gICAgICAgICAga2V5LFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgIG1lc3NhZ2U6ICdmYWlsZWQgdG8gdmFsaWRhdGUgSldUIHNpZ25hdHVyZScsXG4gICAgICBqd3QsXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyByZWZyZXNoKHJlZnJlc2hUb2tlbiwgeyBleGNoYW5nZUJvZHksIGNsaWVudEFzc2VydGlvblBheWxvYWQsIERQb1AgfSA9IHt9KSB7XG4gICAgbGV0IHRva2VuID0gcmVmcmVzaFRva2VuO1xuXG4gICAgaWYgKHRva2VuIGluc3RhbmNlb2YgVG9rZW5TZXQpIHtcbiAgICAgIGlmICghdG9rZW4ucmVmcmVzaF90b2tlbikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWZyZXNoX3Rva2VuIG5vdCBwcmVzZW50IGluIFRva2VuU2V0Jyk7XG4gICAgICB9XG4gICAgICB0b2tlbiA9IHRva2VuLnJlZnJlc2hfdG9rZW47XG4gICAgfVxuXG4gICAgY29uc3QgdG9rZW5zZXQgPSBhd2FpdCB0aGlzLmdyYW50KFxuICAgICAge1xuICAgICAgICAuLi5leGNoYW5nZUJvZHksXG4gICAgICAgIGdyYW50X3R5cGU6ICdyZWZyZXNoX3Rva2VuJyxcbiAgICAgICAgcmVmcmVzaF90b2tlbjogU3RyaW5nKHRva2VuKSxcbiAgICAgIH0sXG4gICAgICB7IGNsaWVudEFzc2VydGlvblBheWxvYWQsIERQb1AgfSxcbiAgICApO1xuXG4gICAgaWYgKHRva2Vuc2V0LmlkX3Rva2VuKSB7XG4gICAgICBhd2FpdCB0aGlzLmRlY3J5cHRJZFRva2VuKHRva2Vuc2V0KTtcbiAgICAgIGF3YWl0IHRoaXMudmFsaWRhdGVJZFRva2VuKHRva2Vuc2V0LCBza2lwTm9uY2VDaGVjaywgJ3Rva2VuJywgc2tpcE1heEFnZUNoZWNrKTtcblxuICAgICAgaWYgKHJlZnJlc2hUb2tlbiBpbnN0YW5jZW9mIFRva2VuU2V0ICYmIHJlZnJlc2hUb2tlbi5pZF90b2tlbikge1xuICAgICAgICBjb25zdCBleHBlY3RlZFN1YiA9IHJlZnJlc2hUb2tlbi5jbGFpbXMoKS5zdWI7XG4gICAgICAgIGNvbnN0IGFjdHVhbFN1YiA9IHRva2Vuc2V0LmNsYWltcygpLnN1YjtcbiAgICAgICAgaWYgKGFjdHVhbFN1YiAhPT0gZXhwZWN0ZWRTdWIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgICAgICBwcmludGY6IFsnc3ViIG1pc21hdGNoLCBleHBlY3RlZCAlcywgZ290OiAlcycsIGV4cGVjdGVkU3ViLCBhY3R1YWxTdWJdLFxuICAgICAgICAgICAgand0OiB0b2tlbnNldC5pZF90b2tlbixcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b2tlbnNldDtcbiAgfVxuXG4gIGFzeW5jIHJlcXVlc3RSZXNvdXJjZShcbiAgICByZXNvdXJjZVVybCxcbiAgICBhY2Nlc3NUb2tlbixcbiAgICB7XG4gICAgICBtZXRob2QsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keSxcbiAgICAgIERQb1AsXG4gICAgICB0b2tlblR5cGUgPSBEUG9QXG4gICAgICAgID8gJ0RQb1AnXG4gICAgICAgIDogYWNjZXNzVG9rZW4gaW5zdGFuY2VvZiBUb2tlblNldFxuICAgICAgICA/IGFjY2Vzc1Rva2VuLnRva2VuX3R5cGVcbiAgICAgICAgOiAnQmVhcmVyJyxcbiAgICB9ID0ge30sXG4gICAgcmV0cnksXG4gICkge1xuICAgIGlmIChhY2Nlc3NUb2tlbiBpbnN0YW5jZW9mIFRva2VuU2V0KSB7XG4gICAgICBpZiAoIWFjY2Vzc1Rva2VuLmFjY2Vzc190b2tlbikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhY2Nlc3NfdG9rZW4gbm90IHByZXNlbnQgaW4gVG9rZW5TZXQnKTtcbiAgICAgIH1cbiAgICAgIGFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW4uYWNjZXNzX3Rva2VuO1xuICAgIH1cblxuICAgIGlmICghYWNjZXNzVG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vIGFjY2VzcyB0b2tlbiBwcm92aWRlZCcpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFjY2Vzc1Rva2VuICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBhY2Nlc3MgdG9rZW4gcHJvdmlkZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0T3B0cyA9IHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYXV0aG9yaXphdGlvbkhlYWRlclZhbHVlKGFjY2Vzc1Rva2VuLCB0b2tlblR5cGUpLFxuICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgfSxcbiAgICAgIGJvZHksXG4gICAgfTtcblxuICAgIGNvbnN0IG1UTFMgPSAhIXRoaXMudGxzX2NsaWVudF9jZXJ0aWZpY2F0ZV9ib3VuZF9hY2Nlc3NfdG9rZW5zO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0LmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAge1xuICAgICAgICAuLi5yZXF1ZXN0T3B0cyxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiAnYnVmZmVyJyxcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICB1cmw6IHJlc291cmNlVXJsLFxuICAgICAgfSxcbiAgICAgIHsgYWNjZXNzVG9rZW4sIG1UTFMsIERQb1AgfSxcbiAgICApO1xuXG4gICAgY29uc3Qgd3d3QXV0aGVudGljYXRlID0gcmVzcG9uc2UuaGVhZGVyc1snd3d3LWF1dGhlbnRpY2F0ZSddO1xuICAgIGlmIChcbiAgICAgIHJldHJ5ICE9PSByZXRyeUF0dGVtcHQgJiZcbiAgICAgIHd3d0F1dGhlbnRpY2F0ZSAmJlxuICAgICAgd3d3QXV0aGVudGljYXRlLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnZHBvcCAnKSAmJlxuICAgICAgcGFyc2VXd3dBdXRoZW50aWNhdGUod3d3QXV0aGVudGljYXRlKS5lcnJvciA9PT0gJ3VzZV9kcG9wX25vbmNlJ1xuICAgICkge1xuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFJlc291cmNlKHJlc291cmNlVXJsLCBhY2Nlc3NUb2tlbiwge1xuICAgICAgICBtZXRob2QsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGJvZHksXG4gICAgICAgIERQb1AsXG4gICAgICAgIHRva2VuVHlwZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuXG4gIGFzeW5jIHVzZXJpbmZvKGFjY2Vzc1Rva2VuLCB7IG1ldGhvZCA9ICdHRVQnLCB2aWEgPSAnaGVhZGVyJywgdG9rZW5UeXBlLCBwYXJhbXMsIERQb1AgfSA9IHt9KSB7XG4gICAgYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbih0aGlzLmlzc3VlciwgJ3VzZXJpbmZvX2VuZHBvaW50Jyk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHRva2VuVHlwZSxcbiAgICAgIG1ldGhvZDogU3RyaW5nKG1ldGhvZCkudG9VcHBlckNhc2UoKSxcbiAgICAgIERQb1AsXG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLm1ldGhvZCAhPT0gJ0dFVCcgJiYgb3B0aW9ucy5tZXRob2QgIT09ICdQT1NUJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignI3VzZXJpbmZvKCkgbWV0aG9kIGNhbiBvbmx5IGJlIFBPU1Qgb3IgYSBHRVQnKTtcbiAgICB9XG5cbiAgICBpZiAodmlhID09PSAnYm9keScgJiYgb3B0aW9ucy5tZXRob2QgIT09ICdQT1NUJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FuIG9ubHkgc2VuZCBib2R5IG9uIFBPU1QnKTtcbiAgICB9XG5cbiAgICBjb25zdCBqd3QgPSAhISh0aGlzLnVzZXJpbmZvX3NpZ25lZF9yZXNwb25zZV9hbGcgfHwgdGhpcy51c2VyaW5mb19lbmNyeXB0ZWRfcmVzcG9uc2VfYWxnKTtcblxuICAgIGlmIChqd3QpIHtcbiAgICAgIG9wdGlvbnMuaGVhZGVycyA9IHsgQWNjZXB0OiAnYXBwbGljYXRpb24vand0JyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLmhlYWRlcnMgPSB7IEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nIH07XG4gICAgfVxuICAgIGNvbnN0IG1UTFMgPSAhIXRoaXMudGxzX2NsaWVudF9jZXJ0aWZpY2F0ZV9ib3VuZF9hY2Nlc3NfdG9rZW5zO1xuXG4gICAgbGV0IHRhcmdldFVybDtcbiAgICBpZiAobVRMUyAmJiB0aGlzLmlzc3Vlci5tdGxzX2VuZHBvaW50X2FsaWFzZXMpIHtcbiAgICAgIHRhcmdldFVybCA9IHRoaXMuaXNzdWVyLm10bHNfZW5kcG9pbnRfYWxpYXNlcy51c2VyaW5mb19lbmRwb2ludDtcbiAgICB9XG5cbiAgICB0YXJnZXRVcmwgPSBuZXcgVVJMKHRhcmdldFVybCB8fCB0aGlzLmlzc3Vlci51c2VyaW5mb19lbmRwb2ludCk7XG5cbiAgICBpZiAodmlhID09PSAnYm9keScpIHtcbiAgICAgIG9wdGlvbnMuaGVhZGVycy5BdXRob3JpemF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgb3B0aW9ucy5oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgICAgb3B0aW9ucy5ib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgb3B0aW9ucy5ib2R5LmFwcGVuZChcbiAgICAgICAgJ2FjY2Vzc190b2tlbicsXG4gICAgICAgIGFjY2Vzc1Rva2VuIGluc3RhbmNlb2YgVG9rZW5TZXQgPyBhY2Nlc3NUb2tlbi5hY2Nlc3NfdG9rZW4gOiBhY2Nlc3NUb2tlbixcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIGFkZGl0aW9uYWwgcGFyYW1ldGVycywgR0VUIHZpYSBxdWVyeXN0cmluZywgUE9TVCB2aWEgdXJsZW5jb2RlZCBib2R5XG4gICAgaWYgKHBhcmFtcykge1xuICAgICAgaWYgKG9wdGlvbnMubWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICBPYmplY3QuZW50cmllcyhwYXJhbXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgIHRhcmdldFVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5ib2R5KSB7XG4gICAgICAgIC8vIFBPU1QgJiYgdmlhIGJvZHlcbiAgICAgICAgT2JqZWN0LmVudHJpZXMocGFyYW1zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICBvcHRpb25zLmJvZHkuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFBPU1QgJiYgdmlhIGhlYWRlclxuICAgICAgICBvcHRpb25zLmJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIG9wdGlvbnMuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgICAgICAgT2JqZWN0LmVudHJpZXMocGFyYW1zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICBvcHRpb25zLmJvZHkuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5ib2R5KSB7XG4gICAgICBvcHRpb25zLmJvZHkgPSBvcHRpb25zLmJvZHkudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucmVxdWVzdFJlc291cmNlKHRhcmdldFVybCwgYWNjZXNzVG9rZW4sIG9wdGlvbnMpO1xuXG4gICAgbGV0IHBhcnNlZCA9IHByb2Nlc3NSZXNwb25zZShyZXNwb25zZSwgeyBiZWFyZXI6IHRydWUgfSk7XG5cbiAgICBpZiAoand0KSB7XG4gICAgICBpZiAoIS9eYXBwbGljYXRpb25cXC9qd3QvLnRlc3QocmVzcG9uc2UuaGVhZGVyc1snY29udGVudC10eXBlJ10pKSB7XG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiAnZXhwZWN0ZWQgYXBwbGljYXRpb24vand0IHJlc3BvbnNlIGZyb20gdGhlIHVzZXJpbmZvX2VuZHBvaW50JyxcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJvZHkgPSByZXNwb25zZS5ib2R5LnRvU3RyaW5nKCk7XG4gICAgICBjb25zdCB1c2VyaW5mbyA9IGF3YWl0IHRoaXMuZGVjcnlwdEpXVFVzZXJpbmZvKGJvZHkpO1xuICAgICAgaWYgKCF0aGlzLnVzZXJpbmZvX3NpZ25lZF9yZXNwb25zZV9hbGcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwYXJzZWQgPSBKU09OLnBhcnNlKHVzZXJpbmZvKTtcbiAgICAgICAgICBhc3NlcnQoaXNQbGFpbk9iamVjdChwYXJzZWQpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogJ2ZhaWxlZCB0byBwYXJzZSB1c2VyaW5mbyBKV0UgcGF5bG9hZCBhcyBKU09OJyxcbiAgICAgICAgICAgIGp3dDogdXNlcmluZm8sXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICh7IHBheWxvYWQ6IHBhcnNlZCB9ID0gYXdhaXQgdGhpcy52YWxpZGF0ZUpXVFVzZXJpbmZvKHVzZXJpbmZvKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZCA9IEpTT04ucGFyc2UocmVzcG9uc2UuYm9keSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVyciwgJ3Jlc3BvbnNlJywgeyB2YWx1ZTogcmVzcG9uc2UgfSk7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYWNjZXNzVG9rZW4gaW5zdGFuY2VvZiBUb2tlblNldCAmJiBhY2Nlc3NUb2tlbi5pZF90b2tlbikge1xuICAgICAgY29uc3QgZXhwZWN0ZWRTdWIgPSBhY2Nlc3NUb2tlbi5jbGFpbXMoKS5zdWI7XG4gICAgICBpZiAocGFyc2VkLnN1YiAhPT0gZXhwZWN0ZWRTdWIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICAgIHByaW50ZjogWyd1c2VyaW5mbyBzdWIgbWlzbWF0Y2gsIGV4cGVjdGVkICVzLCBnb3Q6ICVzJywgZXhwZWN0ZWRTdWIsIHBhcnNlZC5zdWJdLFxuICAgICAgICAgIGJvZHk6IHBhcnNlZCxcbiAgICAgICAgICBqd3Q6IGFjY2Vzc1Rva2VuLmlkX3Rva2VuLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgZW5jcnlwdGlvblNlY3JldChsZW4pIHtcbiAgICBjb25zdCBoYXNoID0gbGVuIDw9IDI1NiA/ICdzaGEyNTYnIDogbGVuIDw9IDM4NCA/ICdzaGEzODQnIDogbGVuIDw9IDUxMiA/ICdzaGE1MTInIDogZmFsc2U7XG4gICAgaWYgKCFoYXNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIHN5bW1ldHJpYyBlbmNyeXB0aW9uIGtleSBkZXJpdmF0aW9uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyeXB0b1xuICAgICAgLmNyZWF0ZUhhc2goaGFzaClcbiAgICAgIC51cGRhdGUodGhpcy5jbGllbnRfc2VjcmV0KVxuICAgICAgLmRpZ2VzdCgpXG4gICAgICAuc2xpY2UoMCwgbGVuIC8gOCk7XG4gIH1cblxuICBzZWNyZXRGb3JBbGcoYWxnKSB7XG4gICAgaWYgKCF0aGlzLmNsaWVudF9zZWNyZXQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NsaWVudF9zZWNyZXQgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoL15BKFxcZHszfSkoPzpHQ00pP0tXJC8udGVzdChhbGcpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNyeXB0aW9uU2VjcmV0KHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApKTtcbiAgICB9XG5cbiAgICBpZiAoL15BKFxcZHszfSkoPzpHQ018Q0JDLUhTKFxcZHszfSkpJC8udGVzdChhbGcpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNyeXB0aW9uU2VjcmV0KHBhcnNlSW50KFJlZ0V4cC4kMiB8fCBSZWdFeHAuJDEsIDEwKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh0aGlzLmNsaWVudF9zZWNyZXQpO1xuICB9XG5cbiAgYXN5bmMgZ3JhbnQoYm9keSwgeyBjbGllbnRBc3NlcnRpb25QYXlsb2FkLCBEUG9QIH0gPSB7fSwgcmV0cnkpIHtcbiAgICBhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uKHRoaXMuaXNzdWVyLCAndG9rZW5fZW5kcG9pbnQnKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF1dGhlbnRpY2F0ZWRQb3N0LmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3Rva2VuJyxcbiAgICAgIHtcbiAgICAgICAgZm9ybTogYm9keSxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICB9LFxuICAgICAgeyBjbGllbnRBc3NlcnRpb25QYXlsb2FkLCBEUG9QIH0sXG4gICAgKTtcbiAgICBsZXQgcmVzcG9uc2VCb2R5O1xuICAgIHRyeSB7XG4gICAgICByZXNwb25zZUJvZHkgPSBwcm9jZXNzUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHJldHJ5ICE9PSByZXRyeUF0dGVtcHQgJiYgZXJyIGluc3RhbmNlb2YgT1BFcnJvciAmJiBlcnIuZXJyb3IgPT09ICd1c2VfZHBvcF9ub25jZScpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JhbnQoYm9keSwgeyBjbGllbnRBc3NlcnRpb25QYXlsb2FkLCBEUG9QIH0sIHJldHJ5QXR0ZW1wdCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUb2tlblNldChyZXNwb25zZUJvZHkpO1xuICB9XG5cbiAgYXN5bmMgZGV2aWNlQXV0aG9yaXphdGlvbihwYXJhbXMgPSB7fSwgeyBleGNoYW5nZUJvZHksIGNsaWVudEFzc2VydGlvblBheWxvYWQsIERQb1AgfSA9IHt9KSB7XG4gICAgYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbih0aGlzLmlzc3VlciwgJ2RldmljZV9hdXRob3JpemF0aW9uX2VuZHBvaW50Jyk7XG4gICAgYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbih0aGlzLmlzc3VlciwgJ3Rva2VuX2VuZHBvaW50Jyk7XG5cbiAgICBjb25zdCBib2R5ID0gYXV0aG9yaXphdGlvblBhcmFtcy5jYWxsKHRoaXMsIHtcbiAgICAgIGNsaWVudF9pZDogdGhpcy5jbGllbnRfaWQsXG4gICAgICByZWRpcmVjdF91cmk6IG51bGwsXG4gICAgICByZXNwb25zZV90eXBlOiBudWxsLFxuICAgICAgLi4ucGFyYW1zLFxuICAgIH0pO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhdXRoZW50aWNhdGVkUG9zdC5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdkZXZpY2VfYXV0aG9yaXphdGlvbicsXG4gICAgICB7XG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgICBmb3JtOiBib2R5LFxuICAgICAgfSxcbiAgICAgIHsgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCwgZW5kcG9pbnRBdXRoTWV0aG9kOiAndG9rZW4nIH0sXG4gICAgKTtcbiAgICBjb25zdCByZXNwb25zZUJvZHkgPSBwcm9jZXNzUmVzcG9uc2UocmVzcG9uc2UpO1xuXG4gICAgcmV0dXJuIG5ldyBEZXZpY2VGbG93SGFuZGxlKHtcbiAgICAgIGNsaWVudDogdGhpcyxcbiAgICAgIGV4Y2hhbmdlQm9keSxcbiAgICAgIGNsaWVudEFzc2VydGlvblBheWxvYWQsXG4gICAgICByZXNwb25zZTogcmVzcG9uc2VCb2R5LFxuICAgICAgbWF4QWdlOiBwYXJhbXMubWF4X2FnZSxcbiAgICAgIERQb1AsXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyByZXZva2UodG9rZW4sIGhpbnQsIHsgcmV2b2tlQm9keSwgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCB9ID0ge30pIHtcbiAgICBhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uKHRoaXMuaXNzdWVyLCAncmV2b2NhdGlvbl9lbmRwb2ludCcpO1xuICAgIGlmIChoaW50ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGhpbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoaW50IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBjb25zdCBmb3JtID0geyAuLi5yZXZva2VCb2R5LCB0b2tlbiB9O1xuXG4gICAgaWYgKGhpbnQpIHtcbiAgICAgIGZvcm0udG9rZW5fdHlwZV9oaW50ID0gaGludDtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF1dGhlbnRpY2F0ZWRQb3N0LmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3Jldm9jYXRpb24nLFxuICAgICAge1xuICAgICAgICBmb3JtLFxuICAgICAgfSxcbiAgICAgIHsgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCB9LFxuICAgICk7XG4gICAgcHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlLCB7IGJvZHk6IGZhbHNlIH0pO1xuICB9XG5cbiAgYXN5bmMgaW50cm9zcGVjdCh0b2tlbiwgaGludCwgeyBpbnRyb3NwZWN0Qm9keSwgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCB9ID0ge30pIHtcbiAgICBhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uKHRoaXMuaXNzdWVyLCAnaW50cm9zcGVjdGlvbl9lbmRwb2ludCcpO1xuICAgIGlmIChoaW50ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGhpbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoaW50IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBjb25zdCBmb3JtID0geyAuLi5pbnRyb3NwZWN0Qm9keSwgdG9rZW4gfTtcbiAgICBpZiAoaGludCkge1xuICAgICAgZm9ybS50b2tlbl90eXBlX2hpbnQgPSBoaW50O1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXV0aGVudGljYXRlZFBvc3QuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAnaW50cm9zcGVjdGlvbicsXG4gICAgICB7IGZvcm0sIHJlc3BvbnNlVHlwZTogJ2pzb24nIH0sXG4gICAgICB7IGNsaWVudEFzc2VydGlvblBheWxvYWQgfSxcbiAgICApO1xuXG4gICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gcHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlKTtcblxuICAgIHJldHVybiByZXNwb25zZUJvZHk7XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgcmVnaXN0ZXIobWV0YWRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgaW5pdGlhbEFjY2Vzc1Rva2VuLCBqd2tzLCAuLi5jbGllbnRPcHRpb25zIH0gPSBvcHRpb25zO1xuXG4gICAgYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbih0aGlzLmlzc3VlciwgJ3JlZ2lzdHJhdGlvbl9lbmRwb2ludCcpO1xuXG4gICAgaWYgKGp3a3MgIT09IHVuZGVmaW5lZCAmJiAhKG1ldGFkYXRhLmp3a3MgfHwgbWV0YWRhdGEuandrc191cmkpKSB7XG4gICAgICBjb25zdCBrZXlzdG9yZSA9IGF3YWl0IGdldEtleXN0b3JlLmNhbGwodGhpcywgandrcyk7XG4gICAgICBtZXRhZGF0YS5qd2tzID0ga2V5c3RvcmUudG9KV0tTKCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0LmNhbGwodGhpcywge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgLi4uKGluaXRpYWxBY2Nlc3NUb2tlblxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBhdXRob3JpemF0aW9uSGVhZGVyVmFsdWUoaW5pdGlhbEFjY2Vzc1Rva2VuKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IHVuZGVmaW5lZCksXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICBqc29uOiBtZXRhZGF0YSxcbiAgICAgIHVybDogdGhpcy5pc3N1ZXIucmVnaXN0cmF0aW9uX2VuZHBvaW50LFxuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgfSk7XG4gICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gcHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlLCB7IHN0YXR1c0NvZGU6IDIwMSwgYmVhcmVyOiB0cnVlIH0pO1xuXG4gICAgcmV0dXJuIG5ldyB0aGlzKHJlc3BvbnNlQm9keSwgandrcywgY2xpZW50T3B0aW9ucyk7XG4gIH1cblxuICBnZXQgbWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuIGNsb25lKE9iamVjdC5mcm9tRW50cmllcyh0aGlzLiNtZXRhZGF0YS5lbnRyaWVzKCkpKTtcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBmcm9tVXJpKHJlZ2lzdHJhdGlvbkNsaWVudFVyaSwgcmVnaXN0cmF0aW9uQWNjZXNzVG9rZW4sIGp3a3MsIGNsaWVudE9wdGlvbnMpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QuY2FsbCh0aGlzLCB7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgdXJsOiByZWdpc3RyYXRpb25DbGllbnRVcmksXG4gICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYXV0aG9yaXphdGlvbkhlYWRlclZhbHVlKHJlZ2lzdHJhdGlvbkFjY2Vzc1Rva2VuKSxcbiAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IHByb2Nlc3NSZXNwb25zZShyZXNwb25zZSwgeyBiZWFyZXI6IHRydWUgfSk7XG5cbiAgICByZXR1cm4gbmV3IHRoaXMocmVzcG9uc2VCb2R5LCBqd2tzLCBjbGllbnRPcHRpb25zKTtcbiAgfVxuXG4gIGFzeW5jIHJlcXVlc3RPYmplY3QoXG4gICAgcmVxdWVzdE9iamVjdCA9IHt9LFxuICAgIHtcbiAgICAgIHNpZ246IHNpZ25pbmdBbGdvcml0aG0gPSB0aGlzLnJlcXVlc3Rfb2JqZWN0X3NpZ25pbmdfYWxnIHx8ICdub25lJyxcbiAgICAgIGVuY3J5cHQ6IHtcbiAgICAgICAgYWxnOiBlS2V5TWFuYWdlbWVudCA9IHRoaXMucmVxdWVzdF9vYmplY3RfZW5jcnlwdGlvbl9hbGcsXG4gICAgICAgIGVuYzogZUNvbnRlbnRFbmNyeXB0aW9uID0gdGhpcy5yZXF1ZXN0X29iamVjdF9lbmNyeXB0aW9uX2VuYyB8fCAnQTEyOENCQy1IUzI1NicsXG4gICAgICB9ID0ge30sXG4gICAgfSA9IHt9LFxuICApIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QocmVxdWVzdE9iamVjdCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlcXVlc3RPYmplY3QgbXVzdCBiZSBhIHBsYWluIG9iamVjdCcpO1xuICAgIH1cblxuICAgIGxldCBzaWduZWQ7XG4gICAgbGV0IGtleTtcbiAgICBjb25zdCB1bml4ID0gbm93KCk7XG4gICAgY29uc3QgaGVhZGVyID0geyBhbGc6IHNpZ25pbmdBbGdvcml0aG0sIHR5cDogJ29hdXRoLWF1dGh6LXJlcStqd3QnIH07XG4gICAgY29uc3QgcGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KFxuICAgICAgZGVmYXVsdHMoe30sIHJlcXVlc3RPYmplY3QsIHtcbiAgICAgICAgaXNzOiB0aGlzLmNsaWVudF9pZCxcbiAgICAgICAgYXVkOiB0aGlzLmlzc3Vlci5pc3N1ZXIsXG4gICAgICAgIGNsaWVudF9pZDogdGhpcy5jbGllbnRfaWQsXG4gICAgICAgIGp0aTogcmFuZG9tKCksXG4gICAgICAgIGlhdDogdW5peCxcbiAgICAgICAgZXhwOiB1bml4ICsgMzAwLFxuICAgICAgICAuLi4odGhpcy5mYXBpKCkgPyB7IG5iZjogdW5peCB9IDogdW5kZWZpbmVkKSxcbiAgICAgIH0pLFxuICAgICk7XG4gICAgaWYgKHNpZ25pbmdBbGdvcml0aG0gPT09ICdub25lJykge1xuICAgICAgc2lnbmVkID0gW2Jhc2U2NHVybC5lbmNvZGUoSlNPTi5zdHJpbmdpZnkoaGVhZGVyKSksIGJhc2U2NHVybC5lbmNvZGUocGF5bG9hZCksICcnXS5qb2luKCcuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN5bW1ldHJpYyA9IHNpZ25pbmdBbGdvcml0aG0uc3RhcnRzV2l0aCgnSFMnKTtcbiAgICAgIGlmIChzeW1tZXRyaWMpIHtcbiAgICAgICAga2V5ID0gdGhpcy5zZWNyZXRGb3JBbGcoc2lnbmluZ0FsZ29yaXRobSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBrZXlzdG9yZSA9IGF3YWl0IGtleXN0b3Jlcy5nZXQodGhpcyk7XG5cbiAgICAgICAgaWYgKCFrZXlzdG9yZSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBgbm8ga2V5c3RvcmUgcHJlc2VudCBmb3IgY2xpZW50LCBjYW5ub3Qgc2lnbiB1c2luZyBhbGcgJHtzaWduaW5nQWxnb3JpdGhtfWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBrZXkgPSBrZXlzdG9yZS5nZXQoeyBhbGc6IHNpZ25pbmdBbGdvcml0aG0sIHVzZTogJ3NpZycgfSk7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgbm8ga2V5IHRvIHNpZ24gd2l0aCBmb3VuZCBmb3IgYWxnICR7c2lnbmluZ0FsZ29yaXRobX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzaWduZWQgPSBhd2FpdCBuZXcgam9zZS5Db21wYWN0U2lnbihuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocGF5bG9hZCkpXG4gICAgICAgIC5zZXRQcm90ZWN0ZWRIZWFkZXIoe1xuICAgICAgICAgIC4uLmhlYWRlcixcbiAgICAgICAgICBraWQ6IHN5bW1ldHJpYyA/IHVuZGVmaW5lZCA6IGtleS5qd2sua2lkLFxuICAgICAgICB9KVxuICAgICAgICAuc2lnbihzeW1tZXRyaWMgPyBrZXkgOiBhd2FpdCBrZXkua2V5T2JqZWN0KHNpZ25pbmdBbGdvcml0aG0pKTtcbiAgICB9XG5cbiAgICBpZiAoIWVLZXlNYW5hZ2VtZW50KSB7XG4gICAgICByZXR1cm4gc2lnbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IGZpZWxkcyA9IHsgYWxnOiBlS2V5TWFuYWdlbWVudCwgZW5jOiBlQ29udGVudEVuY3J5cHRpb24sIGN0eTogJ29hdXRoLWF1dGh6LXJlcStqd3QnIH07XG5cbiAgICBpZiAoZmllbGRzLmFsZy5tYXRjaCgvXihSU0F8RUNESCkvKSkge1xuICAgICAgW2tleV0gPSBhd2FpdCBxdWVyeUtleVN0b3JlLmNhbGwoXG4gICAgICAgIHRoaXMuaXNzdWVyLFxuICAgICAgICB7IGFsZzogZmllbGRzLmFsZywgdXNlOiAnZW5jJyB9LFxuICAgICAgICB7IGFsbG93TXVsdGk6IHRydWUgfSxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IHRoaXMuc2VjcmV0Rm9yQWxnKGZpZWxkcy5hbGcgPT09ICdkaXInID8gZmllbGRzLmVuYyA6IGZpZWxkcy5hbGcpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgam9zZS5Db21wYWN0RW5jcnlwdChuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc2lnbmVkKSlcbiAgICAgIC5zZXRQcm90ZWN0ZWRIZWFkZXIoe1xuICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgIGtpZDoga2V5IGluc3RhbmNlb2YgVWludDhBcnJheSA/IHVuZGVmaW5lZCA6IGtleS5qd2sua2lkLFxuICAgICAgfSlcbiAgICAgIC5lbmNyeXB0KGtleSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBrZXkgOiBhd2FpdCBrZXkua2V5T2JqZWN0KGZpZWxkcy5hbGcpKTtcbiAgfVxuXG4gIGFzeW5jIHB1c2hlZEF1dGhvcml6YXRpb25SZXF1ZXN0KHBhcmFtcyA9IHt9LCB7IGNsaWVudEFzc2VydGlvblBheWxvYWQgfSA9IHt9KSB7XG4gICAgYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbih0aGlzLmlzc3VlciwgJ3B1c2hlZF9hdXRob3JpemF0aW9uX3JlcXVlc3RfZW5kcG9pbnQnKTtcblxuICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAuLi4oJ3JlcXVlc3QnIGluIHBhcmFtcyA/IHBhcmFtcyA6IGF1dGhvcml6YXRpb25QYXJhbXMuY2FsbCh0aGlzLCBwYXJhbXMpKSxcbiAgICAgIGNsaWVudF9pZDogdGhpcy5jbGllbnRfaWQsXG4gICAgfTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXV0aGVudGljYXRlZFBvc3QuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAncHVzaGVkX2F1dGhvcml6YXRpb25fcmVxdWVzdCcsXG4gICAgICB7XG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgICBmb3JtOiBib2R5LFxuICAgICAgfSxcbiAgICAgIHsgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCwgZW5kcG9pbnRBdXRoTWV0aG9kOiAndG9rZW4nIH0sXG4gICAgKTtcbiAgICBjb25zdCByZXNwb25zZUJvZHkgPSBwcm9jZXNzUmVzcG9uc2UocmVzcG9uc2UsIHsgc3RhdHVzQ29kZTogMjAxIH0pO1xuXG4gICAgaWYgKCEoJ2V4cGlyZXNfaW4nIGluIHJlc3BvbnNlQm9keSkpIHtcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogJ2V4cGVjdGVkIGV4cGlyZXNfaW4gaW4gUHVzaGVkIEF1dGhvcml6YXRpb24gU3VjY2Vzc2Z1bCBSZXNwb25zZScsXG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzcG9uc2VCb2R5LmV4cGlyZXNfaW4gIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6ICdpbnZhbGlkIGV4cGlyZXNfaW4gdmFsdWUgaW4gUHVzaGVkIEF1dGhvcml6YXRpb24gU3VjY2Vzc2Z1bCBSZXNwb25zZScsXG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghKCdyZXF1ZXN0X3VyaScgaW4gcmVzcG9uc2VCb2R5KSkge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiAnZXhwZWN0ZWQgcmVxdWVzdF91cmkgaW4gUHVzaGVkIEF1dGhvcml6YXRpb24gU3VjY2Vzc2Z1bCBSZXNwb25zZScsXG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzcG9uc2VCb2R5LnJlcXVlc3RfdXJpICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiAnaW52YWxpZCByZXF1ZXN0X3VyaSB2YWx1ZSBpbiBQdXNoZWQgQXV0aG9yaXphdGlvbiBTdWNjZXNzZnVsIFJlc3BvbnNlJyxcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2VCb2R5O1xuICB9XG5cbiAgZ2V0IGlzc3VlcigpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNzdWVyO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgW2luc3BlY3QuY3VzdG9tXSgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSAke2luc3BlY3QodGhpcy5tZXRhZGF0YSwge1xuICAgICAgZGVwdGg6IEluZmluaXR5LFxuICAgICAgY29sb3JzOiBwcm9jZXNzLnN0ZG91dC5pc1RUWSxcbiAgICAgIGNvbXBhY3Q6IGZhbHNlLFxuICAgICAgc29ydGVkOiB0cnVlLFxuICAgIH0pfWA7XG4gIH1cblxuICBmYXBpKCkge1xuICAgIHJldHVybiB0aGlzLmZhcGkxKCkgfHwgdGhpcy5mYXBpMigpO1xuICB9XG5cbiAgZmFwaTEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZSA9PT0gJ0ZBUEkxQ2xpZW50JztcbiAgfVxuXG4gIGZhcGkyKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdGQVBJMkNsaWVudCc7XG4gIH1cblxuICBhc3luYyB2YWxpZGF0ZUpBUk0ocmVzcG9uc2UpIHtcbiAgICBjb25zdCBleHBlY3RlZEFsZyA9IHRoaXMuYXV0aG9yaXphdGlvbl9zaWduZWRfcmVzcG9uc2VfYWxnO1xuICAgIGNvbnN0IHsgcGF5bG9hZCB9ID0gYXdhaXQgdGhpcy52YWxpZGF0ZUpXVChyZXNwb25zZSwgZXhwZWN0ZWRBbGcsIFsnaXNzJywgJ2V4cCcsICdhdWQnXSk7XG4gICAgcmV0dXJuIHBpY2tDYihwYXlsb2FkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZSBkcG9wUHJvb2ZcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhc3luYyBkcG9wUHJvb2YocGF5bG9hZCwgcHJpdmF0ZUtleUlucHV0LCBhY2Nlc3NUb2tlbikge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChwYXlsb2FkKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGF5bG9hZCBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgbGV0IHByaXZhdGVLZXk7XG4gICAgaWYgKGlzS2V5T2JqZWN0KHByaXZhdGVLZXlJbnB1dCkpIHtcbiAgICAgIHByaXZhdGVLZXkgPSBwcml2YXRlS2V5SW5wdXQ7XG4gICAgfSBlbHNlIGlmIChwcml2YXRlS2V5SW5wdXRbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0NyeXB0b0tleScpIHtcbiAgICAgIHByaXZhdGVLZXkgPSBwcml2YXRlS2V5SW5wdXQ7XG4gICAgfSBlbHNlIGlmIChqb3NlLmNyeXB0b1J1bnRpbWUgPT09ICdub2RlOmNyeXB0bycpIHtcbiAgICAgIHByaXZhdGVLZXkgPSBjcnlwdG8uY3JlYXRlUHJpdmF0ZUtleShwcml2YXRlS2V5SW5wdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bnJlY29nbml6ZWQgY3J5cHRvIHJ1bnRpbWUnKTtcbiAgICB9XG5cbiAgICBpZiAocHJpdmF0ZUtleS50eXBlICE9PSAncHJpdmF0ZScpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiRFBvUFwiIG9wdGlvbiBtdXN0IGJlIGEgcHJpdmF0ZSBrZXknKTtcbiAgICB9XG4gICAgbGV0IGFsZyA9IGRldGVybWluZURQb1BBbGdvcml0aG0uY2FsbCh0aGlzLCBwcml2YXRlS2V5LCBwcml2YXRlS2V5SW5wdXQpO1xuXG4gICAgaWYgKCFhbGcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NvdWxkIG5vdCBkZXRlcm1pbmUgRFBvUCBKV1MgQWxnb3JpdGhtJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBqb3NlLlNpZ25KV1Qoe1xuICAgICAgYXRoOiBhY2Nlc3NUb2tlblxuICAgICAgICA/IGJhc2U2NHVybC5lbmNvZGUoY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShhY2Nlc3NUb2tlbikuZGlnZXN0KCkpXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgLi4ucGF5bG9hZCxcbiAgICB9KVxuICAgICAgLnNldFByb3RlY3RlZEhlYWRlcih7XG4gICAgICAgIGFsZyxcbiAgICAgICAgdHlwOiAnZHBvcCtqd3QnLFxuICAgICAgICBqd2s6IGF3YWl0IGdldEp3ayhwcml2YXRlS2V5LCBwcml2YXRlS2V5SW5wdXQpLFxuICAgICAgfSlcbiAgICAgIC5zZXRJc3N1ZWRBdCgpXG4gICAgICAuc2V0SnRpKHJhbmRvbSgpKVxuICAgICAgLnNpZ24ocHJpdmF0ZUtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lRFBvUEFsZ29yaXRobUZyb21DcnlwdG9LZXkoY3J5cHRvS2V5KSB7XG4gIHN3aXRjaCAoY3J5cHRvS2V5LmFsZ29yaXRobS5uYW1lKSB7XG4gICAgY2FzZSAnRWQyNTUxOSc6XG4gICAgY2FzZSAnRWQ0NDgnOlxuICAgICAgcmV0dXJuICdFZERTQSc7XG4gICAgY2FzZSAnRUNEU0EnOiB7XG4gICAgICBzd2l0Y2ggKGNyeXB0b0tleS5hbGdvcml0aG0ubmFtZWRDdXJ2ZSkge1xuICAgICAgICBjYXNlICdQLTI1Nic6XG4gICAgICAgICAgcmV0dXJuICdFUzI1Nic7XG4gICAgICAgIGNhc2UgJ1AtMzg0JzpcbiAgICAgICAgICByZXR1cm4gJ0VTMzg0JztcbiAgICAgICAgY2FzZSAnUC01MjEnOlxuICAgICAgICAgIHJldHVybiAnRVM1MTInO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgJ1JTQVNTQS1QS0NTMS12MV81JzpcbiAgICAgIHJldHVybiBgUlMke2NyeXB0b0tleS5hbGdvcml0aG0uaGFzaC5uYW1lLnNsaWNlKDQpfWA7XG4gICAgY2FzZSAnUlNBLVBTUyc6XG4gICAgICByZXR1cm4gYFBTJHtjcnlwdG9LZXkuYWxnb3JpdGhtLmhhc2gubmFtZS5zbGljZSg0KX1gO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bnN1cHBvcnRlZCBEUG9QIHByaXZhdGUga2V5Jyk7XG4gIH1cbn1cblxubGV0IGRldGVybWluZURQb1BBbGdvcml0aG07XG5pZiAoam9zZS5jcnlwdG9SdW50aW1lID09PSAnbm9kZTpjcnlwdG8nKSB7XG4gIGRldGVybWluZURQb1BBbGdvcml0aG0gPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgcHJpdmF0ZUtleUlucHV0KSB7XG4gICAgaWYgKHByaXZhdGVLZXlJbnB1dFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnQ3J5cHRvS2V5Jykge1xuICAgICAgcmV0dXJuIGRldGVybWluZURQb1BBbGdvcml0aG1Gcm9tQ3J5cHRvS2V5KHByaXZhdGVLZXkpO1xuICAgIH1cblxuICAgIHN3aXRjaCAocHJpdmF0ZUtleS5hc3ltbWV0cmljS2V5VHlwZSkge1xuICAgICAgY2FzZSAnZWQyNTUxOSc6XG4gICAgICBjYXNlICdlZDQ0OCc6XG4gICAgICAgIHJldHVybiAnRWREU0EnO1xuICAgICAgY2FzZSAnZWMnOlxuICAgICAgICByZXR1cm4gZGV0ZXJtaW5lRWNBbGdvcml0aG0ocHJpdmF0ZUtleSwgcHJpdmF0ZUtleUlucHV0KTtcbiAgICAgIGNhc2UgJ3JzYSc6XG4gICAgICBjYXNlIHJzYVBzc1BhcmFtcyAmJiAncnNhLXBzcyc6XG4gICAgICAgIHJldHVybiBkZXRlcm1pbmVSc2FBbGdvcml0aG0oXG4gICAgICAgICAgcHJpdmF0ZUtleSxcbiAgICAgICAgICBwcml2YXRlS2V5SW5wdXQsXG4gICAgICAgICAgdGhpcy5pc3N1ZXIuZHBvcF9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkLFxuICAgICAgICApO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5zdXBwb3J0ZWQgRFBvUCBwcml2YXRlIGtleScpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBSU1BTID0gL14oPzpSU3xQUykoPzoyNTZ8Mzg0fDUxMikkLztcbiAgZnVuY3Rpb24gZGV0ZXJtaW5lUnNhQWxnb3JpdGhtKHByaXZhdGVLZXksIHByaXZhdGVLZXlJbnB1dCwgdmFsdWVzU3VwcG9ydGVkKSB7XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIHByaXZhdGVLZXlJbnB1dCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHByaXZhdGVLZXlJbnB1dC5mb3JtYXQgPT09ICdqd2snICYmXG4gICAgICBwcml2YXRlS2V5SW5wdXQua2V5ICYmXG4gICAgICBwcml2YXRlS2V5SW5wdXQua2V5LmFsZ1xuICAgICkge1xuICAgICAgcmV0dXJuIHByaXZhdGVLZXlJbnB1dC5rZXkuYWxnO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlc1N1cHBvcnRlZCkpIHtcbiAgICAgIGxldCBjYW5kaWRhdGVzID0gdmFsdWVzU3VwcG9ydGVkLmZpbHRlcihSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZChSU1BTKSk7XG4gICAgICBpZiAocHJpdmF0ZUtleS5hc3ltbWV0cmljS2V5VHlwZSA9PT0gJ3JzYS1wc3MnKSB7XG4gICAgICAgIGNhbmRpZGF0ZXMgPSBjYW5kaWRhdGVzLmZpbHRlcigodmFsdWUpID0+IHZhbHVlLnN0YXJ0c1dpdGgoJ1BTJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFsnUFMyNTYnLCAnUFMzODQnLCAnUFM1MTInLCAnUlMyNTYnLCAnUlMzODQnLCAnUlMzODQnXS5maW5kKChwcmVmZXJyZWQpID0+XG4gICAgICAgIGNhbmRpZGF0ZXMuaW5jbHVkZXMocHJlZmVycmVkKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuICdQUzI1Nic7XG4gIH1cblxuICBjb25zdCBwMjU2ID0gQnVmZmVyLmZyb20oWzQyLCAxMzQsIDcyLCAyMDYsIDYxLCAzLCAxLCA3XSk7XG4gIGNvbnN0IHAzODQgPSBCdWZmZXIuZnJvbShbNDMsIDEyOSwgNCwgMCwgMzRdKTtcbiAgY29uc3QgcDUyMSA9IEJ1ZmZlci5mcm9tKFs0MywgMTI5LCA0LCAwLCAzNV0pO1xuICBjb25zdCBzZWNwMjU2azEgPSBCdWZmZXIuZnJvbShbNDMsIDEyOSwgNCwgMCwgMTBdKTtcblxuICBmdW5jdGlvbiBkZXRlcm1pbmVFY0FsZ29yaXRobShwcml2YXRlS2V5LCBwcml2YXRlS2V5SW5wdXQpIHtcbiAgICAvLyBJZiBpbnB1dCB3YXMgYSBKV0tcbiAgICBzd2l0Y2ggKFxuICAgICAgdHlwZW9mIHByaXZhdGVLZXlJbnB1dCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBwcml2YXRlS2V5SW5wdXQua2V5ID09PSAnb2JqZWN0JyAmJlxuICAgICAgcHJpdmF0ZUtleUlucHV0LmtleS5jcnZcbiAgICApIHtcbiAgICAgIGNhc2UgJ1AtMjU2JzpcbiAgICAgICAgcmV0dXJuICdFUzI1Nic7XG4gICAgICBjYXNlICdzZWNwMjU2azEnOlxuICAgICAgICByZXR1cm4gJ0VTMjU2Syc7XG4gICAgICBjYXNlICdQLTM4NCc6XG4gICAgICAgIHJldHVybiAnRVMzODQnO1xuICAgICAgY2FzZSAnUC01MTInOlxuICAgICAgICByZXR1cm4gJ0VTNTEyJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZiA9IHByaXZhdGVLZXkuZXhwb3J0KHsgZm9ybWF0OiAnZGVyJywgdHlwZTogJ3BrY3M4JyB9KTtcbiAgICBjb25zdCBpID0gYnVmWzFdIDwgMTI4ID8gMTcgOiAxODtcbiAgICBjb25zdCBsZW4gPSBidWZbaV07XG4gICAgY29uc3QgY3VydmVPaWQgPSBidWYuc2xpY2UoaSArIDEsIGkgKyAxICsgbGVuKTtcbiAgICBpZiAoY3VydmVPaWQuZXF1YWxzKHAyNTYpKSB7XG4gICAgICByZXR1cm4gJ0VTMjU2JztcbiAgICB9XG5cbiAgICBpZiAoY3VydmVPaWQuZXF1YWxzKHAzODQpKSB7XG4gICAgICByZXR1cm4gJ0VTMzg0JztcbiAgICB9XG4gICAgaWYgKGN1cnZlT2lkLmVxdWFscyhwNTIxKSkge1xuICAgICAgcmV0dXJuICdFUzUxMic7XG4gICAgfVxuXG4gICAgaWYgKGN1cnZlT2lkLmVxdWFscyhzZWNwMjU2azEpKSB7XG4gICAgICByZXR1cm4gJ0VTMjU2Syc7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5zdXBwb3J0ZWQgRFBvUCBwcml2YXRlIGtleSBjdXJ2ZScpO1xuICB9XG59IGVsc2Uge1xuICBkZXRlcm1pbmVEUG9QQWxnb3JpdGhtID0gZGV0ZXJtaW5lRFBvUEFsZ29yaXRobUZyb21DcnlwdG9LZXk7XG59XG5cbmNvbnN0IGp3a0NhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmFzeW5jIGZ1bmN0aW9uIGdldEp3ayhrZXlPYmplY3QsIHByaXZhdGVLZXlJbnB1dCkge1xuICBpZiAoXG4gICAgam9zZS5jcnlwdG9SdW50aW1lID09PSAnbm9kZTpjcnlwdG8nICYmXG4gICAgdHlwZW9mIHByaXZhdGVLZXlJbnB1dCA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgcHJpdmF0ZUtleUlucHV0LmtleSA9PT0gJ29iamVjdCcgJiZcbiAgICBwcml2YXRlS2V5SW5wdXQuZm9ybWF0ID09PSAnandrJ1xuICApIHtcbiAgICByZXR1cm4gcGljayhwcml2YXRlS2V5SW5wdXQua2V5LCAna3R5JywgJ2NydicsICd4JywgJ3knLCAnZScsICduJyk7XG4gIH1cblxuICBpZiAoandrQ2FjaGUuaGFzKHByaXZhdGVLZXlJbnB1dCkpIHtcbiAgICByZXR1cm4gandrQ2FjaGUuZ2V0KHByaXZhdGVLZXlJbnB1dCk7XG4gIH1cblxuICBjb25zdCBqd2sgPSBwaWNrKGF3YWl0IGpvc2UuZXhwb3J0SldLKGtleU9iamVjdCksICdrdHknLCAnY3J2JywgJ3gnLCAneScsICdlJywgJ24nKTtcblxuICBpZiAoaXNLZXlPYmplY3QocHJpdmF0ZUtleUlucHV0KSB8fCBqb3NlLmNyeXB0b1J1bnRpbWUgPT09ICdXZWJDcnlwdG9BUEknKSB7XG4gICAgandrQ2FjaGUuc2V0KHByaXZhdGVLZXlJbnB1dCwgandrKTtcbiAgfVxuXG4gIHJldHVybiBqd2s7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKGlzc3VlciwgYWFkSXNzVmFsaWRhdGlvbiA9IGZhbHNlKSA9PlxuICBjbGFzcyBDbGllbnQgZXh0ZW5kcyBCYXNlQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICBzdXBlcihpc3N1ZXIsIGFhZElzc1ZhbGlkYXRpb24sIC4uLmFyZ3MpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgaXNzdWVyKCkge1xuICAgICAgcmV0dXJuIGlzc3VlcjtcbiAgICB9XG4gIH07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2VDbGllbnQgPSBCYXNlQ2xpZW50O1xuIl0sIm5hbWVzIjpbImluc3BlY3QiLCJyZXF1aXJlIiwic3RkaHR0cCIsImNyeXB0byIsInN0cmljdCIsImFzc2VydCIsInF1ZXJ5c3RyaW5nIiwidXJsIiwiVVJMIiwiVVJMU2VhcmNoUGFyYW1zIiwiam9zZSIsInRva2VuSGFzaCIsImlzS2V5T2JqZWN0IiwiZGVjb2RlSldUIiwiYmFzZTY0dXJsIiwiZGVmYXVsdHMiLCJwYXJzZVd3d0F1dGhlbnRpY2F0ZSIsImFzc2VydFNpZ25pbmdBbGdWYWx1ZXNTdXBwb3J0IiwiYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbiIsInBpY2siLCJpc1BsYWluT2JqZWN0IiwicHJvY2Vzc1Jlc3BvbnNlIiwiVG9rZW5TZXQiLCJPUEVycm9yIiwiUlBFcnJvciIsIm5vdyIsInJhbmRvbSIsInJlcXVlc3QiLCJDTE9DS19UT0xFUkFOQ0UiLCJrZXlzdG9yZXMiLCJLZXlTdG9yZSIsImNsb25lIiwiYXV0aGVudGljYXRlZFBvc3QiLCJyZXNvbHZlUmVzcG9uc2VUeXBlIiwicmVzb2x2ZVJlZGlyZWN0VXJpIiwicXVlcnlLZXlTdG9yZSIsIkRldmljZUZsb3dIYW5kbGUiLCJtYWpvciIsIm1pbm9yIiwicHJvY2VzcyIsInZlcnNpb24iLCJzbGljZSIsInNwbGl0IiwibWFwIiwic3RyIiwicGFyc2VJbnQiLCJyc2FQc3NQYXJhbXMiLCJyZXRyeUF0dGVtcHQiLCJTeW1ib2wiLCJza2lwTm9uY2VDaGVjayIsInNraXBNYXhBZ2VDaGVjayIsInBpY2tDYiIsImlucHV0IiwiYXV0aG9yaXphdGlvbkhlYWRlclZhbHVlIiwidG9rZW4iLCJ0b2tlblR5cGUiLCJnZXRTZWFyY2hQYXJhbXMiLCJwYXJzZWQiLCJwYXJzZSIsInNlYXJjaCIsInN1YnN0cmluZyIsInZlcmlmeVByZXNlbmNlIiwicGF5bG9hZCIsImp3dCIsInByb3AiLCJ1bmRlZmluZWQiLCJtZXNzYWdlIiwiYXV0aG9yaXphdGlvblBhcmFtcyIsInBhcmFtcyIsImF1dGhQYXJhbXMiLCJjbGllbnRfaWQiLCJzY29wZSIsInJlc3BvbnNlX3R5cGUiLCJjYWxsIiwicmVkaXJlY3RfdXJpIiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJrZXkiLCJ2YWx1ZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJBcnJheSIsImlzQXJyYXkiLCJTdHJpbmciLCJnZXRLZXlzdG9yZSIsImp3a3MiLCJrZXlzIiwic29tZSIsImsiLCJUeXBlRXJyb3IiLCJmcm9tSldLUyIsIm9ubHlQcml2YXRlIiwiY2hlY2tCYXNpY1N1cHBvcnQiLCJjbGllbnQiLCJwcm9wZXJ0aWVzIiwic3VwcG9ydGVkIiwiaXNzdWVyIiwidG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2RzX3N1cHBvcnRlZCIsImluY2x1ZGVzIiwidG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2QiLCJlcnIiLCJoYW5kbGVDb21tb25NaXN0YWtlcyIsIm1ldGFkYXRhIiwicmVkaXJlY3RfdXJpcyIsInJlc3BvbnNlX3R5cGVzIiwiZ2V0RGVmYXVsdHNGb3JFbmRwb2ludCIsImVuZHBvaW50IiwidG9rZW5FbmRwb2ludEF1dGhNZXRob2QiLCJ0b2tlbkVuZHBvaW50QXV0aFNpZ25pbmdBbGciLCJ0b2tlbl9lbmRwb2ludF9hdXRoX3NpZ25pbmdfYWxnIiwiZWFtIiwiZWFzYSIsIkJhc2VDbGllbnQiLCJhYWRJc3NWYWxpZGF0aW9uIiwiYWRkaXRpb25hbEF1dGhvcml6ZWRQYXJ0aWVzIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiTWFwIiwiZ3JhbnRfdHlwZXMiLCJpZF90b2tlbl9zaWduZWRfcmVzcG9uc2VfYWxnIiwiYXV0aG9yaXphdGlvbl9zaWduZWRfcmVzcG9uc2VfYWxnIiwiZmFwaTEiLCJ0bHNfY2xpZW50X2NlcnRpZmljYXRlX2JvdW5kX2FjY2Vzc190b2tlbnMiLCJmYXBpMiIsImZhcGkiLCJkcG9wX2JvdW5kX2FjY2Vzc190b2tlbnMiLCJzZXQiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImVudW1lcmFibGUiLCJrZXlzdG9yZSIsImF1dGhvcml6YXRpb25VcmwiLCJ0YXJnZXQiLCJhdXRob3JpemF0aW9uX2VuZHBvaW50IiwibmFtZSIsInNlYXJjaFBhcmFtcyIsImRlbGV0ZSIsIm1lbWJlciIsImFwcGVuZCIsImhyZWYiLCJyZXBsYWNlIiwiYXV0aG9yaXphdGlvblBvc3QiLCJpbnB1dHMiLCJmb3JtSW5wdXRzIiwiam9pbiIsImVuZFNlc3Npb25VcmwiLCJwb3N0TG9nb3V0IiwibGVuZ3RoIiwicG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpcyIsInBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSIsImlkX3Rva2VuX2hpbnQiLCJpZF90b2tlbiIsImVuZF9zZXNzaW9uX2VuZHBvaW50IiwicXVlcnkiLCJmb3JtYXQiLCJjYWxsYmFja1BhcmFtcyIsImlzSW5jb21pbmdNZXNzYWdlIiwiSW5jb21pbmdNZXNzYWdlIiwibWV0aG9kIiwiaXNTdHJpbmciLCJib2R5IiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJ0b1N0cmluZyIsImNhbGxiYWNrIiwicmVkaXJlY3RVcmkiLCJwYXJhbWV0ZXJzIiwiY2hlY2tzIiwiZXhjaGFuZ2VCb2R5IiwiY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCIsIkRQb1AiLCJqYXJtIiwiZGVjcnlwdGVkIiwiZGVjcnlwdEpBUk0iLCJyZXNwb25zZSIsInZhbGlkYXRlSkFSTSIsImRlZmF1bHRfbWF4X2FnZSIsIm1heF9hZ2UiLCJzdGF0ZSIsInByaW50ZiIsImlzcyIsImF1dGhvcml6YXRpb25fcmVzcG9uc2VfaXNzX3BhcmFtZXRlcl9zdXBwb3J0ZWQiLCJlcnJvciIsIlJFU1BPTlNFX1RZUEVfUkVRVUlSRURfUEFSQU1TIiwiY29kZSIsInR5cGUiLCJhY2Nlc3NfdG9rZW4iLCJwYXJhbSIsInRva2Vuc2V0IiwiZGVjcnlwdElkVG9rZW4iLCJ2YWxpZGF0ZUlkVG9rZW4iLCJub25jZSIsImdyYW50IiwiZ3JhbnRfdHlwZSIsImNvZGVfdmVyaWZpZXIiLCJzZXNzaW9uX3N0YXRlIiwib2F1dGhDYWxsYmFjayIsImlkX3Rva2VuX2VuY3J5cHRlZF9yZXNwb25zZV9hbGciLCJpZFRva2VuIiwiZXhwZWN0ZWRBbGciLCJleHBlY3RlZEVuYyIsImlkX3Rva2VuX2VuY3J5cHRlZF9yZXNwb25zZV9lbmMiLCJyZXN1bHQiLCJkZWNyeXB0SldFIiwidmFsaWRhdGVKV1RVc2VyaW5mbyIsInVzZXJpbmZvX3NpZ25lZF9yZXNwb25zZV9hbGciLCJ2YWxpZGF0ZUpXVCIsImF1dGhvcml6YXRpb25fZW5jcnlwdGVkX3Jlc3BvbnNlX2FsZyIsImF1dGhvcml6YXRpb25fZW5jcnlwdGVkX3Jlc3BvbnNlX2VuYyIsImRlY3J5cHRKV1RVc2VyaW5mbyIsInVzZXJpbmZvX2VuY3J5cHRlZF9yZXNwb25zZV9hbGciLCJ1c2VyaW5mb19lbmNyeXB0ZWRfcmVzcG9uc2VfZW5jIiwiandlIiwiaGVhZGVyIiwiZGVjb2RlIiwiYWxnIiwiZW5jIiwiZ2V0UGxhaW50ZXh0IiwiVGV4dERlY29kZXIiLCJwbGFpbnRleHQiLCJtYXRjaCIsInByb3RlY3RlZEhlYWRlciIsImRlY29kZVByb3RlY3RlZEhlYWRlciIsImFsbCIsInVzZSIsImNvbXBhY3REZWNyeXB0Iiwia2V5T2JqZWN0IiwidGhlbiIsInNlY3JldEZvckFsZyIsInRva2VuU2V0IiwicmV0dXJuZWRCeSIsIm1heEFnZSIsImlzVG9rZW5TZXQiLCJ0aW1lc3RhbXAiLCJwcm90ZWN0ZWQiLCJyZXF1aXJlX2F1dGhfdGltZSIsImF1dGhfdGltZSIsInRvbGVyYW5jZSIsImF0X2hhc2giLCJjX2hhc2giLCJzX2hhc2giLCJ2YWxpZGF0ZSIsImNsYWltIiwic291cmNlIiwiandrIiwiY3J2IiwiaWF0IiwicmVxdWlyZWQiLCJpc1NlbGZJc3N1ZWQiLCJjb21wbGV0ZSIsImJpbmQiLCJleHBlY3RlZElzcyIsInRpZCIsIm5iZiIsImV4cCIsImF1ZCIsImF6cCIsInN1Yl9qd2siLCJpbXBvcnRKV0siLCJlcXVhbCIsImNhbGN1bGF0ZUp3a1RodW1icHJpbnQiLCJzdWIiLCJzdGFydHNXaXRoIiwidmVyaWZpZWQiLCJjb21wYWN0VmVyaWZ5IiwiVWludDhBcnJheSIsImNhdGNoIiwicmVmcmVzaCIsInJlZnJlc2hUb2tlbiIsInJlZnJlc2hfdG9rZW4iLCJleHBlY3RlZFN1YiIsImNsYWltcyIsImFjdHVhbFN1YiIsInJlcXVlc3RSZXNvdXJjZSIsInJlc291cmNlVXJsIiwiYWNjZXNzVG9rZW4iLCJoZWFkZXJzIiwidG9rZW5fdHlwZSIsInJldHJ5IiwicmVxdWVzdE9wdHMiLCJBdXRob3JpemF0aW9uIiwibVRMUyIsInJlc3BvbnNlVHlwZSIsInd3d0F1dGhlbnRpY2F0ZSIsInRvTG93ZXJDYXNlIiwidXNlcmluZm8iLCJ2aWEiLCJ0b1VwcGVyQ2FzZSIsIkFjY2VwdCIsInRhcmdldFVybCIsIm10bHNfZW5kcG9pbnRfYWxpYXNlcyIsInVzZXJpbmZvX2VuZHBvaW50IiwiYmVhcmVyIiwidGVzdCIsImVuY3J5cHRpb25TZWNyZXQiLCJsZW4iLCJoYXNoIiwiRXJyb3IiLCJjcmVhdGVIYXNoIiwidXBkYXRlIiwiY2xpZW50X3NlY3JldCIsImRpZ2VzdCIsIlJlZ0V4cCIsIiQxIiwiJDIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImZvcm0iLCJyZXNwb25zZUJvZHkiLCJkZXZpY2VBdXRob3JpemF0aW9uIiwiZW5kcG9pbnRBdXRoTWV0aG9kIiwicmV2b2tlIiwiaGludCIsInJldm9rZUJvZHkiLCJ0b2tlbl90eXBlX2hpbnQiLCJpbnRyb3NwZWN0IiwiaW50cm9zcGVjdEJvZHkiLCJyZWdpc3RlciIsImluaXRpYWxBY2Nlc3NUb2tlbiIsImNsaWVudE9wdGlvbnMiLCJqd2tzX3VyaSIsInRvSldLUyIsImpzb24iLCJyZWdpc3RyYXRpb25fZW5kcG9pbnQiLCJzdGF0dXNDb2RlIiwiZnJvbUVudHJpZXMiLCJmcm9tVXJpIiwicmVnaXN0cmF0aW9uQ2xpZW50VXJpIiwicmVnaXN0cmF0aW9uQWNjZXNzVG9rZW4iLCJyZXF1ZXN0T2JqZWN0Iiwic2lnbiIsInNpZ25pbmdBbGdvcml0aG0iLCJyZXF1ZXN0X29iamVjdF9zaWduaW5nX2FsZyIsImVuY3J5cHQiLCJlS2V5TWFuYWdlbWVudCIsInJlcXVlc3Rfb2JqZWN0X2VuY3J5cHRpb25fYWxnIiwiZUNvbnRlbnRFbmNyeXB0aW9uIiwicmVxdWVzdF9vYmplY3RfZW5jcnlwdGlvbl9lbmMiLCJzaWduZWQiLCJ1bml4IiwidHlwIiwianRpIiwic3ltbWV0cmljIiwiQ29tcGFjdFNpZ24iLCJzZXRQcm90ZWN0ZWRIZWFkZXIiLCJraWQiLCJmaWVsZHMiLCJjdHkiLCJhbGxvd011bHRpIiwiQ29tcGFjdEVuY3J5cHQiLCJwdXNoZWRBdXRob3JpemF0aW9uUmVxdWVzdCIsImV4cGlyZXNfaW4iLCJyZXF1ZXN0X3VyaSIsImN1c3RvbSIsImRlcHRoIiwiSW5maW5pdHkiLCJjb2xvcnMiLCJzdGRvdXQiLCJpc1RUWSIsImNvbXBhY3QiLCJzb3J0ZWQiLCJkcG9wUHJvb2YiLCJwcml2YXRlS2V5SW5wdXQiLCJwcml2YXRlS2V5IiwidG9TdHJpbmdUYWciLCJjcnlwdG9SdW50aW1lIiwiY3JlYXRlUHJpdmF0ZUtleSIsImRldGVybWluZURQb1BBbGdvcml0aG0iLCJTaWduSldUIiwiYXRoIiwiZ2V0SndrIiwic2V0SXNzdWVkQXQiLCJzZXRKdGkiLCJkZXRlcm1pbmVEUG9QQWxnb3JpdGhtRnJvbUNyeXB0b0tleSIsImNyeXB0b0tleSIsImFsZ29yaXRobSIsIm5hbWVkQ3VydmUiLCJhc3ltbWV0cmljS2V5VHlwZSIsImRldGVybWluZUVjQWxnb3JpdGhtIiwiZGV0ZXJtaW5lUnNhQWxnb3JpdGhtIiwiZHBvcF9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkIiwiUlNQUyIsInZhbHVlc1N1cHBvcnRlZCIsImNhbmRpZGF0ZXMiLCJmaWx0ZXIiLCJwcm90b3R5cGUiLCJmaW5kIiwicHJlZmVycmVkIiwicDI1NiIsImZyb20iLCJwMzg0IiwicDUyMSIsInNlY3AyNTZrMSIsImJ1ZiIsImV4cG9ydCIsImkiLCJjdXJ2ZU9pZCIsImVxdWFscyIsImp3a0NhY2hlIiwiV2Vha01hcCIsImhhcyIsImV4cG9ydEpXSyIsIm1vZHVsZSIsImV4cG9ydHMiLCJDbGllbnQiLCJhcmdzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/client.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/device_flow_handle.js":
/*!***************************************************************!*\
  !*** ../node_modules/openid-client/lib/device_flow_handle.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { inspect } = __webpack_require__(/*! util */ \"util\");\nconst { RPError, OPError } = __webpack_require__(/*! ./errors */ \"(rsc)/../node_modules/openid-client/lib/errors.js\");\nconst now = __webpack_require__(/*! ./helpers/unix_timestamp */ \"(rsc)/../node_modules/openid-client/lib/helpers/unix_timestamp.js\");\nclass DeviceFlowHandle {\n    #aborted;\n    #client;\n    #clientAssertionPayload;\n    #DPoP;\n    #exchangeBody;\n    #expires_at;\n    #interval;\n    #maxAge;\n    #response;\n    constructor({ client, exchangeBody, clientAssertionPayload, response, maxAge, DPoP }){\n        [\n            \"verification_uri\",\n            \"user_code\",\n            \"device_code\"\n        ].forEach((prop)=>{\n            if (typeof response[prop] !== \"string\" || !response[prop]) {\n                throw new RPError(`expected ${prop} string to be returned by Device Authorization Response, got %j`, response[prop]);\n            }\n        });\n        if (!Number.isSafeInteger(response.expires_in)) {\n            throw new RPError(\"expected expires_in number to be returned by Device Authorization Response, got %j\", response.expires_in);\n        }\n        this.#expires_at = now() + response.expires_in;\n        this.#client = client;\n        this.#DPoP = DPoP;\n        this.#maxAge = maxAge;\n        this.#exchangeBody = exchangeBody;\n        this.#clientAssertionPayload = clientAssertionPayload;\n        this.#response = response;\n        this.#interval = response.interval * 1000 || 5000;\n    }\n    abort() {\n        this.#aborted = true;\n    }\n    async poll({ signal } = {}) {\n        if (signal && signal.aborted || this.#aborted) {\n            throw new RPError(\"polling aborted\");\n        }\n        if (this.expired()) {\n            throw new RPError(\"the device code %j has expired and the device authorization session has concluded\", this.device_code);\n        }\n        await new Promise((resolve)=>setTimeout(resolve, this.#interval));\n        let tokenset;\n        try {\n            tokenset = await this.#client.grant({\n                ...this.#exchangeBody,\n                grant_type: \"urn:ietf:params:oauth:grant-type:device_code\",\n                device_code: this.device_code\n            }, {\n                clientAssertionPayload: this.#clientAssertionPayload,\n                DPoP: this.#DPoP\n            });\n        } catch (err) {\n            switch(err instanceof OPError && err.error){\n                case \"slow_down\":\n                    this.#interval += 5000;\n                case \"authorization_pending\":\n                    return this.poll({\n                        signal\n                    });\n                default:\n                    throw err;\n            }\n        }\n        if (\"id_token\" in tokenset) {\n            await this.#client.decryptIdToken(tokenset);\n            await this.#client.validateIdToken(tokenset, undefined, \"token\", this.#maxAge);\n        }\n        return tokenset;\n    }\n    get device_code() {\n        return this.#response.device_code;\n    }\n    get user_code() {\n        return this.#response.user_code;\n    }\n    get verification_uri() {\n        return this.#response.verification_uri;\n    }\n    get verification_uri_complete() {\n        return this.#response.verification_uri_complete;\n    }\n    get expires_in() {\n        return Math.max.apply(null, [\n            this.#expires_at - now(),\n            0\n        ]);\n    }\n    expired() {\n        return this.expires_in === 0;\n    }\n    /* istanbul ignore next */ [inspect.custom]() {\n        return `${this.constructor.name} ${inspect(this.#response, {\n            depth: Infinity,\n            colors: process.stdout.isTTY,\n            compact: false,\n            sorted: true\n        })}`;\n    }\n}\nmodule.exports = DeviceFlowHandle;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2RldmljZV9mbG93X2hhbmRsZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxFQUFFQSxPQUFPLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFFNUIsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUNyQyxNQUFNRyxNQUFNSCxtQkFBT0EsQ0FBQztBQUVwQixNQUFNSTtJQUNKLENBQUNDLE9BQU8sQ0FBQztJQUNULENBQUNDLE1BQU0sQ0FBQztJQUNSLENBQUNDLHNCQUFzQixDQUFDO0lBQ3hCLENBQUNDLElBQUksQ0FBQztJQUNOLENBQUNDLFlBQVksQ0FBQztJQUNkLENBQUNDLFVBQVUsQ0FBQztJQUNaLENBQUNDLFFBQVEsQ0FBQztJQUNWLENBQUNDLE1BQU0sQ0FBQztJQUNSLENBQUNDLFFBQVEsQ0FBQztJQUNWQyxZQUFZLEVBQUVSLE1BQU0sRUFBRUcsWUFBWSxFQUFFRixzQkFBc0IsRUFBRU0sUUFBUSxFQUFFRCxNQUFNLEVBQUVKLElBQUksRUFBRSxDQUFFO1FBQ3BGO1lBQUM7WUFBb0I7WUFBYTtTQUFjLENBQUNPLE9BQU8sQ0FBQyxDQUFDQztZQUN4RCxJQUFJLE9BQU9ILFFBQVEsQ0FBQ0csS0FBSyxLQUFLLFlBQVksQ0FBQ0gsUUFBUSxDQUFDRyxLQUFLLEVBQUU7Z0JBQ3pELE1BQU0sSUFBSWYsUUFDUixDQUFDLFNBQVMsRUFBRWUsS0FBSywrREFBK0QsQ0FBQyxFQUNqRkgsUUFBUSxDQUFDRyxLQUFLO1lBRWxCO1FBQ0Y7UUFFQSxJQUFJLENBQUNDLE9BQU9DLGFBQWEsQ0FBQ0wsU0FBU00sVUFBVSxHQUFHO1lBQzlDLE1BQU0sSUFBSWxCLFFBQ1Isc0ZBQ0FZLFNBQVNNLFVBQVU7UUFFdkI7UUFFQSxJQUFJLENBQUMsQ0FBQ1QsVUFBVSxHQUFHUCxRQUFRVSxTQUFTTSxVQUFVO1FBQzlDLElBQUksQ0FBQyxDQUFDYixNQUFNLEdBQUdBO1FBQ2YsSUFBSSxDQUFDLENBQUNFLElBQUksR0FBR0E7UUFDYixJQUFJLENBQUMsQ0FBQ0ksTUFBTSxHQUFHQTtRQUNmLElBQUksQ0FBQyxDQUFDSCxZQUFZLEdBQUdBO1FBQ3JCLElBQUksQ0FBQyxDQUFDRixzQkFBc0IsR0FBR0E7UUFDL0IsSUFBSSxDQUFDLENBQUNNLFFBQVEsR0FBR0E7UUFDakIsSUFBSSxDQUFDLENBQUNGLFFBQVEsR0FBR0UsU0FBU0YsUUFBUSxHQUFHLFFBQVE7SUFDL0M7SUFFQVMsUUFBUTtRQUNOLElBQUksQ0FBQyxDQUFDZixPQUFPLEdBQUc7SUFDbEI7SUFFQSxNQUFNZ0IsS0FBSyxFQUFFQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRTtRQUMxQixJQUFJLFVBQVdBLE9BQU9qQixPQUFPLElBQUssSUFBSSxDQUFDLENBQUNBLE9BQU8sRUFBRTtZQUMvQyxNQUFNLElBQUlKLFFBQVE7UUFDcEI7UUFFQSxJQUFJLElBQUksQ0FBQ3NCLE9BQU8sSUFBSTtZQUNsQixNQUFNLElBQUl0QixRQUNSLHFGQUNBLElBQUksQ0FBQ3VCLFdBQVc7UUFFcEI7UUFFQSxNQUFNLElBQUlDLFFBQVEsQ0FBQ0MsVUFBWUMsV0FBV0QsU0FBUyxJQUFJLENBQUMsQ0FBQ2YsUUFBUTtRQUVqRSxJQUFJaUI7UUFDSixJQUFJO1lBQ0ZBLFdBQVcsTUFBTSxJQUFJLENBQUMsQ0FBQ3RCLE1BQU0sQ0FBQ3VCLEtBQUssQ0FDakM7Z0JBQ0UsR0FBRyxJQUFJLENBQUMsQ0FBQ3BCLFlBQVk7Z0JBQ3JCcUIsWUFBWTtnQkFDWk4sYUFBYSxJQUFJLENBQUNBLFdBQVc7WUFDL0IsR0FDQTtnQkFBRWpCLHdCQUF3QixJQUFJLENBQUMsQ0FBQ0Esc0JBQXNCO2dCQUFFQyxNQUFNLElBQUksQ0FBQyxDQUFDQSxJQUFJO1lBQUM7UUFFN0UsRUFBRSxPQUFPdUIsS0FBSztZQUNaLE9BQVFBLGVBQWU3QixXQUFXNkIsSUFBSUMsS0FBSztnQkFDekMsS0FBSztvQkFDSCxJQUFJLENBQUMsQ0FBQ3JCLFFBQVEsSUFBSTtnQkFDcEIsS0FBSztvQkFDSCxPQUFPLElBQUksQ0FBQ1UsSUFBSSxDQUFDO3dCQUFFQztvQkFBTztnQkFDNUI7b0JBQ0UsTUFBTVM7WUFDVjtRQUNGO1FBRUEsSUFBSSxjQUFjSCxVQUFVO1lBQzFCLE1BQU0sSUFBSSxDQUFDLENBQUN0QixNQUFNLENBQUMyQixjQUFjLENBQUNMO1lBQ2xDLE1BQU0sSUFBSSxDQUFDLENBQUN0QixNQUFNLENBQUM0QixlQUFlLENBQUNOLFVBQVVPLFdBQVcsU0FBUyxJQUFJLENBQUMsQ0FBQ3ZCLE1BQU07UUFDL0U7UUFFQSxPQUFPZ0I7SUFDVDtJQUVBLElBQUlKLGNBQWM7UUFDaEIsT0FBTyxJQUFJLENBQUMsQ0FBQ1gsUUFBUSxDQUFDVyxXQUFXO0lBQ25DO0lBRUEsSUFBSVksWUFBWTtRQUNkLE9BQU8sSUFBSSxDQUFDLENBQUN2QixRQUFRLENBQUN1QixTQUFTO0lBQ2pDO0lBRUEsSUFBSUMsbUJBQW1CO1FBQ3JCLE9BQU8sSUFBSSxDQUFDLENBQUN4QixRQUFRLENBQUN3QixnQkFBZ0I7SUFDeEM7SUFFQSxJQUFJQyw0QkFBNEI7UUFDOUIsT0FBTyxJQUFJLENBQUMsQ0FBQ3pCLFFBQVEsQ0FBQ3lCLHlCQUF5QjtJQUNqRDtJQUVBLElBQUluQixhQUFhO1FBQ2YsT0FBT29CLEtBQUtDLEdBQUcsQ0FBQ0MsS0FBSyxDQUFDLE1BQU07WUFBQyxJQUFJLENBQUMsQ0FBQy9CLFVBQVUsR0FBR1A7WUFBTztTQUFFO0lBQzNEO0lBRUFvQixVQUFVO1FBQ1IsT0FBTyxJQUFJLENBQUNKLFVBQVUsS0FBSztJQUM3QjtJQUVBLHdCQUF3QixHQUN4QixDQUFDcEIsUUFBUTJDLE1BQU0sQ0FBQyxHQUFHO1FBQ2pCLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQzVCLFdBQVcsQ0FBQzZCLElBQUksQ0FBQyxDQUFDLEVBQUU1QyxRQUFRLElBQUksQ0FBQyxDQUFDYyxRQUFRLEVBQUU7WUFDekQrQixPQUFPQztZQUNQQyxRQUFRQyxRQUFRQyxNQUFNLENBQUNDLEtBQUs7WUFDNUJDLFNBQVM7WUFDVEMsUUFBUTtRQUNWLEdBQUcsQ0FBQztJQUNOO0FBQ0Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHakQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lZHN1LWhvdXNlLXB1YmxpYy8uLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvZGV2aWNlX2Zsb3dfaGFuZGxlLmpzPzJkMDAiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBpbnNwZWN0IH0gPSByZXF1aXJlKCd1dGlsJyk7XG5cbmNvbnN0IHsgUlBFcnJvciwgT1BFcnJvciB9ID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IG5vdyA9IHJlcXVpcmUoJy4vaGVscGVycy91bml4X3RpbWVzdGFtcCcpO1xuXG5jbGFzcyBEZXZpY2VGbG93SGFuZGxlIHtcbiAgI2Fib3J0ZWQ7XG4gICNjbGllbnQ7XG4gICNjbGllbnRBc3NlcnRpb25QYXlsb2FkO1xuICAjRFBvUDtcbiAgI2V4Y2hhbmdlQm9keTtcbiAgI2V4cGlyZXNfYXQ7XG4gICNpbnRlcnZhbDtcbiAgI21heEFnZTtcbiAgI3Jlc3BvbnNlO1xuICBjb25zdHJ1Y3Rvcih7IGNsaWVudCwgZXhjaGFuZ2VCb2R5LCBjbGllbnRBc3NlcnRpb25QYXlsb2FkLCByZXNwb25zZSwgbWF4QWdlLCBEUG9QIH0pIHtcbiAgICBbJ3ZlcmlmaWNhdGlvbl91cmknLCAndXNlcl9jb2RlJywgJ2RldmljZV9jb2RlJ10uZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiByZXNwb25zZVtwcm9wXSAhPT0gJ3N0cmluZycgfHwgIXJlc3BvbnNlW3Byb3BdKSB7XG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKFxuICAgICAgICAgIGBleHBlY3RlZCAke3Byb3B9IHN0cmluZyB0byBiZSByZXR1cm5lZCBieSBEZXZpY2UgQXV0aG9yaXphdGlvbiBSZXNwb25zZSwgZ290ICVqYCxcbiAgICAgICAgICByZXNwb25zZVtwcm9wXSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIocmVzcG9uc2UuZXhwaXJlc19pbikpIHtcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKFxuICAgICAgICAnZXhwZWN0ZWQgZXhwaXJlc19pbiBudW1iZXIgdG8gYmUgcmV0dXJuZWQgYnkgRGV2aWNlIEF1dGhvcml6YXRpb24gUmVzcG9uc2UsIGdvdCAlaicsXG4gICAgICAgIHJlc3BvbnNlLmV4cGlyZXNfaW4sXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuI2V4cGlyZXNfYXQgPSBub3coKSArIHJlc3BvbnNlLmV4cGlyZXNfaW47XG4gICAgdGhpcy4jY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMuI0RQb1AgPSBEUG9QO1xuICAgIHRoaXMuI21heEFnZSA9IG1heEFnZTtcbiAgICB0aGlzLiNleGNoYW5nZUJvZHkgPSBleGNoYW5nZUJvZHk7XG4gICAgdGhpcy4jY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCA9IGNsaWVudEFzc2VydGlvblBheWxvYWQ7XG4gICAgdGhpcy4jcmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB0aGlzLiNpbnRlcnZhbCA9IHJlc3BvbnNlLmludGVydmFsICogMTAwMCB8fCA1MDAwO1xuICB9XG5cbiAgYWJvcnQoKSB7XG4gICAgdGhpcy4jYWJvcnRlZCA9IHRydWU7XG4gIH1cblxuICBhc3luYyBwb2xsKHsgc2lnbmFsIH0gPSB7fSkge1xuICAgIGlmICgoc2lnbmFsICYmIHNpZ25hbC5hYm9ydGVkKSB8fCB0aGlzLiNhYm9ydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcigncG9sbGluZyBhYm9ydGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZXhwaXJlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcihcbiAgICAgICAgJ3RoZSBkZXZpY2UgY29kZSAlaiBoYXMgZXhwaXJlZCBhbmQgdGhlIGRldmljZSBhdXRob3JpemF0aW9uIHNlc3Npb24gaGFzIGNvbmNsdWRlZCcsXG4gICAgICAgIHRoaXMuZGV2aWNlX2NvZGUsXG4gICAgICApO1xuICAgIH1cblxuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRoaXMuI2ludGVydmFsKSk7XG5cbiAgICBsZXQgdG9rZW5zZXQ7XG4gICAgdHJ5IHtcbiAgICAgIHRva2Vuc2V0ID0gYXdhaXQgdGhpcy4jY2xpZW50LmdyYW50KFxuICAgICAgICB7XG4gICAgICAgICAgLi4udGhpcy4jZXhjaGFuZ2VCb2R5LFxuICAgICAgICAgIGdyYW50X3R5cGU6ICd1cm46aWV0ZjpwYXJhbXM6b2F1dGg6Z3JhbnQtdHlwZTpkZXZpY2VfY29kZScsXG4gICAgICAgICAgZGV2aWNlX2NvZGU6IHRoaXMuZGV2aWNlX2NvZGUsXG4gICAgICAgIH0sXG4gICAgICAgIHsgY2xpZW50QXNzZXJ0aW9uUGF5bG9hZDogdGhpcy4jY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCwgRFBvUDogdGhpcy4jRFBvUCB9LFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHN3aXRjaCAoZXJyIGluc3RhbmNlb2YgT1BFcnJvciAmJiBlcnIuZXJyb3IpIHtcbiAgICAgICAgY2FzZSAnc2xvd19kb3duJzpcbiAgICAgICAgICB0aGlzLiNpbnRlcnZhbCArPSA1MDAwO1xuICAgICAgICBjYXNlICdhdXRob3JpemF0aW9uX3BlbmRpbmcnOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBvbGwoeyBzaWduYWwgfSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgnaWRfdG9rZW4nIGluIHRva2Vuc2V0KSB7XG4gICAgICBhd2FpdCB0aGlzLiNjbGllbnQuZGVjcnlwdElkVG9rZW4odG9rZW5zZXQpO1xuICAgICAgYXdhaXQgdGhpcy4jY2xpZW50LnZhbGlkYXRlSWRUb2tlbih0b2tlbnNldCwgdW5kZWZpbmVkLCAndG9rZW4nLCB0aGlzLiNtYXhBZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiB0b2tlbnNldDtcbiAgfVxuXG4gIGdldCBkZXZpY2VfY29kZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVzcG9uc2UuZGV2aWNlX2NvZGU7XG4gIH1cblxuICBnZXQgdXNlcl9jb2RlKCkge1xuICAgIHJldHVybiB0aGlzLiNyZXNwb25zZS51c2VyX2NvZGU7XG4gIH1cblxuICBnZXQgdmVyaWZpY2F0aW9uX3VyaSgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVzcG9uc2UudmVyaWZpY2F0aW9uX3VyaTtcbiAgfVxuXG4gIGdldCB2ZXJpZmljYXRpb25fdXJpX2NvbXBsZXRlKCkge1xuICAgIHJldHVybiB0aGlzLiNyZXNwb25zZS52ZXJpZmljYXRpb25fdXJpX2NvbXBsZXRlO1xuICB9XG5cbiAgZ2V0IGV4cGlyZXNfaW4oKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIFt0aGlzLiNleHBpcmVzX2F0IC0gbm93KCksIDBdKTtcbiAgfVxuXG4gIGV4cGlyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhwaXJlc19pbiA9PT0gMDtcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIFtpbnNwZWN0LmN1c3RvbV0oKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gJHtpbnNwZWN0KHRoaXMuI3Jlc3BvbnNlLCB7XG4gICAgICBkZXB0aDogSW5maW5pdHksXG4gICAgICBjb2xvcnM6IHByb2Nlc3Muc3Rkb3V0LmlzVFRZLFxuICAgICAgY29tcGFjdDogZmFsc2UsXG4gICAgICBzb3J0ZWQ6IHRydWUsXG4gICAgfSl9YDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERldmljZUZsb3dIYW5kbGU7XG4iXSwibmFtZXMiOlsiaW5zcGVjdCIsInJlcXVpcmUiLCJSUEVycm9yIiwiT1BFcnJvciIsIm5vdyIsIkRldmljZUZsb3dIYW5kbGUiLCJhYm9ydGVkIiwiY2xpZW50IiwiY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCIsIkRQb1AiLCJleGNoYW5nZUJvZHkiLCJleHBpcmVzX2F0IiwiaW50ZXJ2YWwiLCJtYXhBZ2UiLCJyZXNwb25zZSIsImNvbnN0cnVjdG9yIiwiZm9yRWFjaCIsInByb3AiLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiZXhwaXJlc19pbiIsImFib3J0IiwicG9sbCIsInNpZ25hbCIsImV4cGlyZWQiLCJkZXZpY2VfY29kZSIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsInRva2Vuc2V0IiwiZ3JhbnQiLCJncmFudF90eXBlIiwiZXJyIiwiZXJyb3IiLCJkZWNyeXB0SWRUb2tlbiIsInZhbGlkYXRlSWRUb2tlbiIsInVuZGVmaW5lZCIsInVzZXJfY29kZSIsInZlcmlmaWNhdGlvbl91cmkiLCJ2ZXJpZmljYXRpb25fdXJpX2NvbXBsZXRlIiwiTWF0aCIsIm1heCIsImFwcGx5IiwiY3VzdG9tIiwibmFtZSIsImRlcHRoIiwiSW5maW5pdHkiLCJjb2xvcnMiLCJwcm9jZXNzIiwic3Rkb3V0IiwiaXNUVFkiLCJjb21wYWN0Iiwic29ydGVkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/device_flow_handle.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/errors.js":
/*!***************************************************!*\
  !*** ../node_modules/openid-client/lib/errors.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { format } = __webpack_require__(/*! util */ \"util\");\nclass OPError extends Error {\n    constructor({ error_description, error, error_uri, session_state, state, scope }, response){\n        super(!error_description ? error : `${error} (${error_description})`);\n        Object.assign(this, {\n            error\n        }, error_description && {\n            error_description\n        }, error_uri && {\n            error_uri\n        }, state && {\n            state\n        }, scope && {\n            scope\n        }, session_state && {\n            session_state\n        });\n        if (response) {\n            Object.defineProperty(this, \"response\", {\n                value: response\n            });\n        }\n        this.name = this.constructor.name;\n        Error.captureStackTrace(this, this.constructor);\n    }\n}\nclass RPError extends Error {\n    constructor(...args){\n        if (typeof args[0] === \"string\") {\n            super(format(...args));\n        } else {\n            const { message, printf, response, ...rest } = args[0];\n            if (printf) {\n                super(format(...printf));\n            } else {\n                super(message);\n            }\n            Object.assign(this, rest);\n            if (response) {\n                Object.defineProperty(this, \"response\", {\n                    value: response\n                });\n            }\n        }\n        this.name = this.constructor.name;\n        Error.captureStackTrace(this, this.constructor);\n    }\n}\nmodule.exports = {\n    OPError,\n    RPError\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxFQUFFQSxNQUFNLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFFM0IsTUFBTUMsZ0JBQWdCQztJQUNwQkMsWUFBWSxFQUFFQyxpQkFBaUIsRUFBRUMsS0FBSyxFQUFFQyxTQUFTLEVBQUVDLGFBQWEsRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUUsRUFBRUMsUUFBUSxDQUFFO1FBQzFGLEtBQUssQ0FBQyxDQUFDTixvQkFBb0JDLFFBQVEsQ0FBQyxFQUFFQSxNQUFNLEVBQUUsRUFBRUQsa0JBQWtCLENBQUMsQ0FBQztRQUVwRU8sT0FBT0MsTUFBTSxDQUNYLElBQUksRUFDSjtZQUFFUDtRQUFNLEdBQ1JELHFCQUFxQjtZQUFFQTtRQUFrQixHQUN6Q0UsYUFBYTtZQUFFQTtRQUFVLEdBQ3pCRSxTQUFTO1lBQUVBO1FBQU0sR0FDakJDLFNBQVM7WUFBRUE7UUFBTSxHQUNqQkYsaUJBQWlCO1lBQUVBO1FBQWM7UUFHbkMsSUFBSUcsVUFBVTtZQUNaQyxPQUFPRSxjQUFjLENBQUMsSUFBSSxFQUFFLFlBQVk7Z0JBQ3RDQyxPQUFPSjtZQUNUO1FBQ0Y7UUFFQSxJQUFJLENBQUNLLElBQUksR0FBRyxJQUFJLENBQUNaLFdBQVcsQ0FBQ1ksSUFBSTtRQUNqQ2IsTUFBTWMsaUJBQWlCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQ2IsV0FBVztJQUNoRDtBQUNGO0FBRUEsTUFBTWMsZ0JBQWdCZjtJQUNwQkMsWUFBWSxHQUFHZSxJQUFJLENBQUU7UUFDbkIsSUFBSSxPQUFPQSxJQUFJLENBQUMsRUFBRSxLQUFLLFVBQVU7WUFDL0IsS0FBSyxDQUFDbkIsVUFBVW1CO1FBQ2xCLE9BQU87WUFDTCxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsTUFBTSxFQUFFVixRQUFRLEVBQUUsR0FBR1csTUFBTSxHQUFHSCxJQUFJLENBQUMsRUFBRTtZQUN0RCxJQUFJRSxRQUFRO2dCQUNWLEtBQUssQ0FBQ3JCLFVBQVVxQjtZQUNsQixPQUFPO2dCQUNMLEtBQUssQ0FBQ0Q7WUFDUjtZQUNBUixPQUFPQyxNQUFNLENBQUMsSUFBSSxFQUFFUztZQUNwQixJQUFJWCxVQUFVO2dCQUNaQyxPQUFPRSxjQUFjLENBQUMsSUFBSSxFQUFFLFlBQVk7b0JBQ3RDQyxPQUFPSjtnQkFDVDtZQUNGO1FBQ0Y7UUFFQSxJQUFJLENBQUNLLElBQUksR0FBRyxJQUFJLENBQUNaLFdBQVcsQ0FBQ1ksSUFBSTtRQUNqQ2IsTUFBTWMsaUJBQWlCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQ2IsV0FBVztJQUNoRDtBQUNGO0FBRUFtQixPQUFPQyxPQUFPLEdBQUc7SUFDZnRCO0lBQ0FnQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWRzdS1ob3VzZS1wdWJsaWMvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2Vycm9ycy5qcz82MWQyIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgZm9ybWF0IH0gPSByZXF1aXJlKCd1dGlsJyk7XG5cbmNsYXNzIE9QRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHsgZXJyb3JfZGVzY3JpcHRpb24sIGVycm9yLCBlcnJvcl91cmksIHNlc3Npb25fc3RhdGUsIHN0YXRlLCBzY29wZSB9LCByZXNwb25zZSkge1xuICAgIHN1cGVyKCFlcnJvcl9kZXNjcmlwdGlvbiA/IGVycm9yIDogYCR7ZXJyb3J9ICgke2Vycm9yX2Rlc2NyaXB0aW9ufSlgKTtcblxuICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICB0aGlzLFxuICAgICAgeyBlcnJvciB9LFxuICAgICAgZXJyb3JfZGVzY3JpcHRpb24gJiYgeyBlcnJvcl9kZXNjcmlwdGlvbiB9LFxuICAgICAgZXJyb3JfdXJpICYmIHsgZXJyb3JfdXJpIH0sXG4gICAgICBzdGF0ZSAmJiB7IHN0YXRlIH0sXG4gICAgICBzY29wZSAmJiB7IHNjb3BlIH0sXG4gICAgICBzZXNzaW9uX3N0YXRlICYmIHsgc2Vzc2lvbl9zdGF0ZSB9LFxuICAgICk7XG5cbiAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVzcG9uc2UnLCB7XG4gICAgICAgIHZhbHVlOiByZXNwb25zZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfVxufVxuXG5jbGFzcyBSUEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgc3VwZXIoZm9ybWF0KC4uLmFyZ3MpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeyBtZXNzYWdlLCBwcmludGYsIHJlc3BvbnNlLCAuLi5yZXN0IH0gPSBhcmdzWzBdO1xuICAgICAgaWYgKHByaW50Zikge1xuICAgICAgICBzdXBlcihmb3JtYXQoLi4ucHJpbnRmKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgcmVzdCk7XG4gICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyZXNwb25zZScsIHtcbiAgICAgICAgICB2YWx1ZTogcmVzcG9uc2UsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgT1BFcnJvcixcbiAgUlBFcnJvcixcbn07XG4iXSwibmFtZXMiOlsiZm9ybWF0IiwicmVxdWlyZSIsIk9QRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwiZXJyb3JfZGVzY3JpcHRpb24iLCJlcnJvciIsImVycm9yX3VyaSIsInNlc3Npb25fc3RhdGUiLCJzdGF0ZSIsInNjb3BlIiwicmVzcG9uc2UiLCJPYmplY3QiLCJhc3NpZ24iLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwibmFtZSIsImNhcHR1cmVTdGFja1RyYWNlIiwiUlBFcnJvciIsImFyZ3MiLCJtZXNzYWdlIiwicHJpbnRmIiwicmVzdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/errors.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/assert.js":
/*!***********************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/assert.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("\nfunction assertSigningAlgValuesSupport(endpoint, issuer, properties) {\n    if (!issuer[`${endpoint}_endpoint`]) return;\n    const eam = `${endpoint}_endpoint_auth_method`;\n    const easa = `${endpoint}_endpoint_auth_signing_alg`;\n    const easavs = `${endpoint}_endpoint_auth_signing_alg_values_supported`;\n    if (properties[eam] && properties[eam].endsWith(\"_jwt\") && !properties[easa] && !issuer[easavs]) {\n        throw new TypeError(`${easavs} must be configured on the issuer if ${easa} is not defined on a client`);\n    }\n}\nfunction assertIssuerConfiguration(issuer, endpoint) {\n    if (!issuer[endpoint]) {\n        throw new TypeError(`${endpoint} must be configured on the issuer`);\n    }\n}\nmodule.exports = {\n    assertSigningAlgValuesSupport,\n    assertIssuerConfiguration\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxTQUFTQSw4QkFBOEJDLFFBQVEsRUFBRUMsTUFBTSxFQUFFQyxVQUFVO0lBQ2pFLElBQUksQ0FBQ0QsTUFBTSxDQUFDLENBQUMsRUFBRUQsU0FBUyxTQUFTLENBQUMsQ0FBQyxFQUFFO0lBRXJDLE1BQU1HLE1BQU0sQ0FBQyxFQUFFSCxTQUFTLHFCQUFxQixDQUFDO0lBQzlDLE1BQU1JLE9BQU8sQ0FBQyxFQUFFSixTQUFTLDBCQUEwQixDQUFDO0lBQ3BELE1BQU1LLFNBQVMsQ0FBQyxFQUFFTCxTQUFTLDJDQUEyQyxDQUFDO0lBRXZFLElBQUlFLFVBQVUsQ0FBQ0MsSUFBSSxJQUFJRCxVQUFVLENBQUNDLElBQUksQ0FBQ0csUUFBUSxDQUFDLFdBQVcsQ0FBQ0osVUFBVSxDQUFDRSxLQUFLLElBQUksQ0FBQ0gsTUFBTSxDQUFDSSxPQUFPLEVBQUU7UUFDL0YsTUFBTSxJQUFJRSxVQUNSLENBQUMsRUFBRUYsT0FBTyxxQ0FBcUMsRUFBRUQsS0FBSywyQkFBMkIsQ0FBQztJQUV0RjtBQUNGO0FBRUEsU0FBU0ksMEJBQTBCUCxNQUFNLEVBQUVELFFBQVE7SUFDakQsSUFBSSxDQUFDQyxNQUFNLENBQUNELFNBQVMsRUFBRTtRQUNyQixNQUFNLElBQUlPLFVBQVUsQ0FBQyxFQUFFUCxTQUFTLGlDQUFpQyxDQUFDO0lBQ3BFO0FBQ0Y7QUFFQVMsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZYO0lBQ0FTO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lZHN1LWhvdXNlLXB1YmxpYy8uLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9hc3NlcnQuanM/YTRlOSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBhc3NlcnRTaWduaW5nQWxnVmFsdWVzU3VwcG9ydChlbmRwb2ludCwgaXNzdWVyLCBwcm9wZXJ0aWVzKSB7XG4gIGlmICghaXNzdWVyW2Ake2VuZHBvaW50fV9lbmRwb2ludGBdKSByZXR1cm47XG5cbiAgY29uc3QgZWFtID0gYCR7ZW5kcG9pbnR9X2VuZHBvaW50X2F1dGhfbWV0aG9kYDtcbiAgY29uc3QgZWFzYSA9IGAke2VuZHBvaW50fV9lbmRwb2ludF9hdXRoX3NpZ25pbmdfYWxnYDtcbiAgY29uc3QgZWFzYXZzID0gYCR7ZW5kcG9pbnR9X2VuZHBvaW50X2F1dGhfc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZGA7XG5cbiAgaWYgKHByb3BlcnRpZXNbZWFtXSAmJiBwcm9wZXJ0aWVzW2VhbV0uZW5kc1dpdGgoJ19qd3QnKSAmJiAhcHJvcGVydGllc1tlYXNhXSAmJiAhaXNzdWVyW2Vhc2F2c10pIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgYCR7ZWFzYXZzfSBtdXN0IGJlIGNvbmZpZ3VyZWQgb24gdGhlIGlzc3VlciBpZiAke2Vhc2F9IGlzIG5vdCBkZWZpbmVkIG9uIGEgY2xpZW50YCxcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydElzc3VlckNvbmZpZ3VyYXRpb24oaXNzdWVyLCBlbmRwb2ludCkge1xuICBpZiAoIWlzc3VlcltlbmRwb2ludF0pIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2VuZHBvaW50fSBtdXN0IGJlIGNvbmZpZ3VyZWQgb24gdGhlIGlzc3VlcmApO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhc3NlcnRTaWduaW5nQWxnVmFsdWVzU3VwcG9ydCxcbiAgYXNzZXJ0SXNzdWVyQ29uZmlndXJhdGlvbixcbn07XG4iXSwibmFtZXMiOlsiYXNzZXJ0U2lnbmluZ0FsZ1ZhbHVlc1N1cHBvcnQiLCJlbmRwb2ludCIsImlzc3VlciIsInByb3BlcnRpZXMiLCJlYW0iLCJlYXNhIiwiZWFzYXZzIiwiZW5kc1dpdGgiLCJUeXBlRXJyb3IiLCJhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/assert.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/base64url.js":
/*!**************************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/base64url.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\nlet encode;\nif (Buffer.isEncoding(\"base64url\")) {\n    encode = (input, encoding = \"utf8\")=>Buffer.from(input, encoding).toString(\"base64url\");\n} else {\n    const fromBase64 = (base64)=>base64.replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n    encode = (input, encoding = \"utf8\")=>fromBase64(Buffer.from(input, encoding).toString(\"base64\"));\n}\nconst decode = (input)=>Buffer.from(input, \"base64\");\nmodule.exports.decode = decode;\nmodule.exports.encode = encode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvYmFzZTY0dXJsLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxJQUFJQTtBQUNKLElBQUlDLE9BQU9DLFVBQVUsQ0FBQyxjQUFjO0lBQ2xDRixTQUFTLENBQUNHLE9BQU9DLFdBQVcsTUFBTSxHQUFLSCxPQUFPSSxJQUFJLENBQUNGLE9BQU9DLFVBQVVFLFFBQVEsQ0FBQztBQUMvRSxPQUFPO0lBQ0wsTUFBTUMsYUFBYSxDQUFDQyxTQUFXQSxPQUFPQyxPQUFPLENBQUMsTUFBTSxJQUFJQSxPQUFPLENBQUMsT0FBTyxLQUFLQSxPQUFPLENBQUMsT0FBTztJQUMzRlQsU0FBUyxDQUFDRyxPQUFPQyxXQUFXLE1BQU0sR0FDaENHLFdBQVdOLE9BQU9JLElBQUksQ0FBQ0YsT0FBT0MsVUFBVUUsUUFBUSxDQUFDO0FBQ3JEO0FBRUEsTUFBTUksU0FBUyxDQUFDUCxRQUFVRixPQUFPSSxJQUFJLENBQUNGLE9BQU87QUFFN0NRLHFCQUFxQixHQUFHRDtBQUN4QkMscUJBQXFCLEdBQUdYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWRzdS1ob3VzZS1wdWJsaWMvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvYmFzZTY0dXJsLmpzP2I1ZjciXSwic291cmNlc0NvbnRlbnQiOlsibGV0IGVuY29kZTtcbmlmIChCdWZmZXIuaXNFbmNvZGluZygnYmFzZTY0dXJsJykpIHtcbiAgZW5jb2RlID0gKGlucHV0LCBlbmNvZGluZyA9ICd1dGY4JykgPT4gQnVmZmVyLmZyb20oaW5wdXQsIGVuY29kaW5nKS50b1N0cmluZygnYmFzZTY0dXJsJyk7XG59IGVsc2Uge1xuICBjb25zdCBmcm9tQmFzZTY0ID0gKGJhc2U2NCkgPT4gYmFzZTY0LnJlcGxhY2UoLz0vZywgJycpLnJlcGxhY2UoL1xcKy9nLCAnLScpLnJlcGxhY2UoL1xcLy9nLCAnXycpO1xuICBlbmNvZGUgPSAoaW5wdXQsIGVuY29kaW5nID0gJ3V0ZjgnKSA9PlxuICAgIGZyb21CYXNlNjQoQnVmZmVyLmZyb20oaW5wdXQsIGVuY29kaW5nKS50b1N0cmluZygnYmFzZTY0JykpO1xufVxuXG5jb25zdCBkZWNvZGUgPSAoaW5wdXQpID0+IEJ1ZmZlci5mcm9tKGlucHV0LCAnYmFzZTY0Jyk7XG5cbm1vZHVsZS5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbm1vZHVsZS5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbiJdLCJuYW1lcyI6WyJlbmNvZGUiLCJCdWZmZXIiLCJpc0VuY29kaW5nIiwiaW5wdXQiLCJlbmNvZGluZyIsImZyb20iLCJ0b1N0cmluZyIsImZyb21CYXNlNjQiLCJiYXNlNjQiLCJyZXBsYWNlIiwiZGVjb2RlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/base64url.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/client.js":
/*!***********************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/client.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst jose = __webpack_require__(/*! jose */ \"(rsc)/../node_modules/jose/dist/node/cjs/index.js\");\nconst { RPError } = __webpack_require__(/*! ../errors */ \"(rsc)/../node_modules/openid-client/lib/errors.js\");\nconst { assertIssuerConfiguration } = __webpack_require__(/*! ./assert */ \"(rsc)/../node_modules/openid-client/lib/helpers/assert.js\");\nconst { random } = __webpack_require__(/*! ./generators */ \"(rsc)/../node_modules/openid-client/lib/helpers/generators.js\");\nconst now = __webpack_require__(/*! ./unix_timestamp */ \"(rsc)/../node_modules/openid-client/lib/helpers/unix_timestamp.js\");\nconst request = __webpack_require__(/*! ./request */ \"(rsc)/../node_modules/openid-client/lib/helpers/request.js\");\nconst { keystores } = __webpack_require__(/*! ./weak_cache */ \"(rsc)/../node_modules/openid-client/lib/helpers/weak_cache.js\");\nconst merge = __webpack_require__(/*! ./merge */ \"(rsc)/../node_modules/openid-client/lib/helpers/merge.js\");\n// TODO: in v6.x additionally encode the `- _ . ! ~ * ' ( )` characters\n// https://github.com/panva/node-openid-client/commit/5a2ea80ef5e59ec0c03dbd97d82f551e24a9d348\nconst formUrlEncode = (value)=>encodeURIComponent(value).replace(/%20/g, \"+\");\nasync function clientAssertion(endpoint, payload) {\n    let alg = this[`${endpoint}_endpoint_auth_signing_alg`];\n    if (!alg) {\n        assertIssuerConfiguration(this.issuer, `${endpoint}_endpoint_auth_signing_alg_values_supported`);\n    }\n    if (this[`${endpoint}_endpoint_auth_method`] === \"client_secret_jwt\") {\n        if (!alg) {\n            const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];\n            alg = Array.isArray(supported) && supported.find((signAlg)=>/^HS(?:256|384|512)/.test(signAlg));\n        }\n        if (!alg) {\n            throw new RPError(`failed to determine a JWS Algorithm to use for ${this[`${endpoint}_endpoint_auth_method`]} Client Assertion`);\n        }\n        return new jose.CompactSign(Buffer.from(JSON.stringify(payload))).setProtectedHeader({\n            alg\n        }).sign(this.secretForAlg(alg));\n    }\n    const keystore = await keystores.get(this);\n    if (!keystore) {\n        throw new TypeError(\"no client jwks provided for signing a client assertion with\");\n    }\n    if (!alg) {\n        const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];\n        alg = Array.isArray(supported) && supported.find((signAlg)=>keystore.get({\n                alg: signAlg,\n                use: \"sig\"\n            }));\n    }\n    if (!alg) {\n        throw new RPError(`failed to determine a JWS Algorithm to use for ${this[`${endpoint}_endpoint_auth_method`]} Client Assertion`);\n    }\n    const key = keystore.get({\n        alg,\n        use: \"sig\"\n    });\n    if (!key) {\n        throw new RPError(`no key found in client jwks to sign a client assertion with using alg ${alg}`);\n    }\n    return new jose.CompactSign(Buffer.from(JSON.stringify(payload))).setProtectedHeader({\n        alg,\n        kid: key.jwk && key.jwk.kid\n    }).sign(await key.keyObject(alg));\n}\nasync function authFor(endpoint, { clientAssertionPayload } = {}) {\n    const authMethod = this[`${endpoint}_endpoint_auth_method`];\n    switch(authMethod){\n        case \"self_signed_tls_client_auth\":\n        case \"tls_client_auth\":\n        case \"none\":\n            return {\n                form: {\n                    client_id: this.client_id\n                }\n            };\n        case \"client_secret_post\":\n            if (typeof this.client_secret !== \"string\") {\n                throw new TypeError(\"client_secret_post client authentication method requires a client_secret\");\n            }\n            return {\n                form: {\n                    client_id: this.client_id,\n                    client_secret: this.client_secret\n                }\n            };\n        case \"private_key_jwt\":\n        case \"client_secret_jwt\":\n            {\n                const timestamp = now();\n                const assertion = await clientAssertion.call(this, endpoint, {\n                    iat: timestamp,\n                    exp: timestamp + 60,\n                    jti: random(),\n                    iss: this.client_id,\n                    sub: this.client_id,\n                    aud: this.issuer.issuer,\n                    ...clientAssertionPayload\n                });\n                return {\n                    form: {\n                        client_id: this.client_id,\n                        client_assertion: assertion,\n                        client_assertion_type: \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\"\n                    }\n                };\n            }\n        case \"client_secret_basic\":\n            {\n                // This is correct behaviour, see https://tools.ietf.org/html/rfc6749#section-2.3.1 and the\n                // related appendix. (also https://github.com/panva/node-openid-client/pull/91)\n                // > The client identifier is encoded using the\n                // > \"application/x-www-form-urlencoded\" encoding algorithm per\n                // > Appendix B, and the encoded value is used as the username; the client\n                // > password is encoded using the same algorithm and used as the\n                // > password.\n                if (typeof this.client_secret !== \"string\") {\n                    throw new TypeError(\"client_secret_basic client authentication method requires a client_secret\");\n                }\n                const encoded = `${formUrlEncode(this.client_id)}:${formUrlEncode(this.client_secret)}`;\n                const value = Buffer.from(encoded).toString(\"base64\");\n                return {\n                    headers: {\n                        Authorization: `Basic ${value}`\n                    }\n                };\n            }\n        default:\n            {\n                throw new TypeError(`missing, or unsupported, ${endpoint}_endpoint_auth_method`);\n            }\n    }\n}\nfunction resolveResponseType() {\n    const { length, 0: value } = this.response_types;\n    if (length === 1) {\n        return value;\n    }\n    return undefined;\n}\nfunction resolveRedirectUri() {\n    const { length, 0: value } = this.redirect_uris || [];\n    if (length === 1) {\n        return value;\n    }\n    return undefined;\n}\nasync function authenticatedPost(endpoint, opts, { clientAssertionPayload, endpointAuthMethod = endpoint, DPoP } = {}) {\n    const auth = await authFor.call(this, endpointAuthMethod, {\n        clientAssertionPayload\n    });\n    const requestOpts = merge(opts, auth);\n    const mTLS = this[`${endpointAuthMethod}_endpoint_auth_method`].includes(\"tls_client_auth\") || endpoint === \"token\" && this.tls_client_certificate_bound_access_tokens;\n    let targetUrl;\n    if (mTLS && this.issuer.mtls_endpoint_aliases) {\n        targetUrl = this.issuer.mtls_endpoint_aliases[`${endpoint}_endpoint`];\n    }\n    targetUrl = targetUrl || this.issuer[`${endpoint}_endpoint`];\n    if (\"form\" in requestOpts) {\n        for (const [key, value] of Object.entries(requestOpts.form)){\n            if (typeof value === \"undefined\") {\n                delete requestOpts.form[key];\n            }\n        }\n    }\n    return request.call(this, {\n        ...requestOpts,\n        method: \"POST\",\n        url: targetUrl,\n        headers: {\n            ...endpoint !== \"revocation\" ? {\n                Accept: \"application/json\"\n            } : undefined,\n            ...requestOpts.headers\n        }\n    }, {\n        mTLS,\n        DPoP\n    });\n}\nmodule.exports = {\n    resolveResponseType,\n    resolveRedirectUri,\n    authFor,\n    authenticatedPost\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNQSxPQUFPQyxtQkFBT0EsQ0FBQztBQUVyQixNQUFNLEVBQUVDLE9BQU8sRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQztBQUU1QixNQUFNLEVBQUVFLHlCQUF5QixFQUFFLEdBQUdGLG1CQUFPQSxDQUFDO0FBQzlDLE1BQU0sRUFBRUcsTUFBTSxFQUFFLEdBQUdILG1CQUFPQSxDQUFDO0FBQzNCLE1BQU1JLE1BQU1KLG1CQUFPQSxDQUFDO0FBQ3BCLE1BQU1LLFVBQVVMLG1CQUFPQSxDQUFDO0FBQ3hCLE1BQU0sRUFBRU0sU0FBUyxFQUFFLEdBQUdOLG1CQUFPQSxDQUFDO0FBQzlCLE1BQU1PLFFBQVFQLG1CQUFPQSxDQUFDO0FBRXRCLHVFQUF1RTtBQUN2RSw4RkFBOEY7QUFDOUYsTUFBTVEsZ0JBQWdCLENBQUNDLFFBQVVDLG1CQUFtQkQsT0FBT0UsT0FBTyxDQUFDLFFBQVE7QUFFM0UsZUFBZUMsZ0JBQWdCQyxRQUFRLEVBQUVDLE9BQU87SUFDOUMsSUFBSUMsTUFBTSxJQUFJLENBQUMsQ0FBQyxFQUFFRixTQUFTLDBCQUEwQixDQUFDLENBQUM7SUFDdkQsSUFBSSxDQUFDRSxLQUFLO1FBQ1JiLDBCQUNFLElBQUksQ0FBQ2MsTUFBTSxFQUNYLENBQUMsRUFBRUgsU0FBUywyQ0FBMkMsQ0FBQztJQUU1RDtJQUVBLElBQUksSUFBSSxDQUFDLENBQUMsRUFBRUEsU0FBUyxxQkFBcUIsQ0FBQyxDQUFDLEtBQUsscUJBQXFCO1FBQ3BFLElBQUksQ0FBQ0UsS0FBSztZQUNSLE1BQU1FLFlBQVksSUFBSSxDQUFDRCxNQUFNLENBQUMsQ0FBQyxFQUFFSCxTQUFTLDJDQUEyQyxDQUFDLENBQUM7WUFDdkZFLE1BQ0VHLE1BQU1DLE9BQU8sQ0FBQ0YsY0FBY0EsVUFBVUcsSUFBSSxDQUFDLENBQUNDLFVBQVkscUJBQXFCQyxJQUFJLENB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b3VyY2VzIjpbIndlYnBhY2s6Ly9lZHN1LWhvdXNlLXB1YmxpYy8uLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9jbGllbnQuanM/OGI1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBqb3NlID0gcmVxdWlyZSgnam9zZScpO1xuXG5jb25zdCB7IFJQRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuXG5jb25zdCB7IGFzc2VydElzc3VlckNvbmZpZ3VyYXRpb24gfSA9IHJlcXVpcmUoJy4vYXNzZXJ0Jyk7XG5jb25zdCB7IHJhbmRvbSB9ID0gcmVxdWlyZSgnLi9nZW5lcmF0b3JzJyk7XG5jb25zdCBub3cgPSByZXF1aXJlKCcuL3VuaXhfdGltZXN0YW1wJyk7XG5jb25zdCByZXF1ZXN0ID0gcmVxdWlyZSgnLi9yZXF1ZXN0Jyk7XG5jb25zdCB7IGtleXN0b3JlcyB9ID0gcmVxdWlyZSgnLi93ZWFrX2NhY2hlJyk7XG5jb25zdCBtZXJnZSA9IHJlcXVpcmUoJy4vbWVyZ2UnKTtcblxuLy8gVE9ETzogaW4gdjYueCBhZGRpdGlvbmFsbHkgZW5jb2RlIHRoZSBgLSBfIC4gISB+ICogJyAoIClgIGNoYXJhY3RlcnNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wYW52YS9ub2RlLW9wZW5pZC1jbGllbnQvY29tbWl0LzVhMmVhODBlZjVlNTllYzBjMDNkYmQ5N2Q4MmY1NTFlMjRhOWQzNDhcbmNvbnN0IGZvcm1VcmxFbmNvZGUgPSAodmFsdWUpID0+IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkucmVwbGFjZSgvJTIwL2csICcrJyk7XG5cbmFzeW5jIGZ1bmN0aW9uIGNsaWVudEFzc2VydGlvbihlbmRwb2ludCwgcGF5bG9hZCkge1xuICBsZXQgYWxnID0gdGhpc1tgJHtlbmRwb2ludH1fZW5kcG9pbnRfYXV0aF9zaWduaW5nX2FsZ2BdO1xuICBpZiAoIWFsZykge1xuICAgIGFzc2VydElzc3VlckNvbmZpZ3VyYXRpb24oXG4gICAgICB0aGlzLmlzc3VlcixcbiAgICAgIGAke2VuZHBvaW50fV9lbmRwb2ludF9hdXRoX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWRgLFxuICAgICk7XG4gIH1cblxuICBpZiAodGhpc1tgJHtlbmRwb2ludH1fZW5kcG9pbnRfYXV0aF9tZXRob2RgXSA9PT0gJ2NsaWVudF9zZWNyZXRfand0Jykge1xuICAgIGlmICghYWxnKSB7XG4gICAgICBjb25zdCBzdXBwb3J0ZWQgPSB0aGlzLmlzc3VlcltgJHtlbmRwb2ludH1fZW5kcG9pbnRfYXV0aF9zaWduaW5nX2FsZ192YWx1ZXNfc3VwcG9ydGVkYF07XG4gICAgICBhbGcgPVxuICAgICAgICBBcnJheS5pc0FycmF5KHN1cHBvcnRlZCkgJiYgc3VwcG9ydGVkLmZpbmQoKHNpZ25BbGcpID0+IC9eSFMoPzoyNTZ8Mzg0fDUxMikvLnRlc3Qoc2lnbkFsZykpO1xuICAgIH1cblxuICAgIGlmICghYWxnKSB7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcihcbiAgICAgICAgYGZhaWxlZCB0byBkZXRlcm1pbmUgYSBKV1MgQWxnb3JpdGhtIHRvIHVzZSBmb3IgJHtcbiAgICAgICAgICB0aGlzW2Ake2VuZHBvaW50fV9lbmRwb2ludF9hdXRoX21ldGhvZGBdXG4gICAgICAgIH0gQ2xpZW50IEFzc2VydGlvbmAsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgam9zZS5Db21wYWN0U2lnbihCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeShwYXlsb2FkKSkpXG4gICAgICAuc2V0UHJvdGVjdGVkSGVhZGVyKHsgYWxnIH0pXG4gICAgICAuc2lnbih0aGlzLnNlY3JldEZvckFsZyhhbGcpKTtcbiAgfVxuXG4gIGNvbnN0IGtleXN0b3JlID0gYXdhaXQga2V5c3RvcmVzLmdldCh0aGlzKTtcblxuICBpZiAoIWtleXN0b3JlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm8gY2xpZW50IGp3a3MgcHJvdmlkZWQgZm9yIHNpZ25pbmcgYSBjbGllbnQgYXNzZXJ0aW9uIHdpdGgnKTtcbiAgfVxuXG4gIGlmICghYWxnKSB7XG4gICAgY29uc3Qgc3VwcG9ydGVkID0gdGhpcy5pc3N1ZXJbYCR7ZW5kcG9pbnR9X2VuZHBvaW50X2F1dGhfc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZGBdO1xuICAgIGFsZyA9XG4gICAgICBBcnJheS5pc0FycmF5KHN1cHBvcnRlZCkgJiZcbiAgICAgIHN1cHBvcnRlZC5maW5kKChzaWduQWxnKSA9PiBrZXlzdG9yZS5nZXQoeyBhbGc6IHNpZ25BbGcsIHVzZTogJ3NpZycgfSkpO1xuICB9XG5cbiAgaWYgKCFhbGcpIHtcbiAgICB0aHJvdyBuZXcgUlBFcnJvcihcbiAgICAgIGBmYWlsZWQgdG8gZGV0ZXJtaW5lIGEgSldTIEFsZ29yaXRobSB0byB1c2UgZm9yICR7XG4gICAgICAgIHRoaXNbYCR7ZW5kcG9pbnR9X2VuZHBvaW50X2F1dGhfbWV0aG9kYF1cbiAgICAgIH0gQ2xpZW50IEFzc2VydGlvbmAsXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IGtleSA9IGtleXN0b3JlLmdldCh7IGFsZywgdXNlOiAnc2lnJyB9KTtcbiAgaWYgKCFrZXkpIHtcbiAgICB0aHJvdyBuZXcgUlBFcnJvcihcbiAgICAgIGBubyBrZXkgZm91bmQgaW4gY2xpZW50IGp3a3MgdG8gc2lnbiBhIGNsaWVudCBhc3NlcnRpb24gd2l0aCB1c2luZyBhbGcgJHthbGd9YCxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBqb3NlLkNvbXBhY3RTaWduKEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKSlcbiAgICAuc2V0UHJvdGVjdGVkSGVhZGVyKHsgYWxnLCBraWQ6IGtleS5qd2sgJiYga2V5Lmp3ay5raWQgfSlcbiAgICAuc2lnbihhd2FpdCBrZXkua2V5T2JqZWN0KGFsZykpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBhdXRoRm9yKGVuZHBvaW50LCB7IGNsaWVudEFzc2VydGlvblBheWxvYWQgfSA9IHt9KSB7XG4gIGNvbnN0IGF1dGhNZXRob2QgPSB0aGlzW2Ake2VuZHBvaW50fV9lbmRwb2ludF9hdXRoX21ldGhvZGBdO1xuICBzd2l0Y2ggKGF1dGhNZXRob2QpIHtcbiAgICBjYXNlICdzZWxmX3NpZ25lZF90bHNfY2xpZW50X2F1dGgnOlxuICAgIGNhc2UgJ3Rsc19jbGllbnRfYXV0aCc6XG4gICAgY2FzZSAnbm9uZSc6XG4gICAgICByZXR1cm4geyBmb3JtOiB7IGNsaWVudF9pZDogdGhpcy5jbGllbnRfaWQgfSB9O1xuICAgIGNhc2UgJ2NsaWVudF9zZWNyZXRfcG9zdCc6XG4gICAgICBpZiAodHlwZW9mIHRoaXMuY2xpZW50X3NlY3JldCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnY2xpZW50X3NlY3JldF9wb3N0IGNsaWVudCBhdXRoZW50aWNhdGlvbiBtZXRob2QgcmVxdWlyZXMgYSBjbGllbnRfc2VjcmV0JyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGZvcm06IHsgY2xpZW50X2lkOiB0aGlzLmNsaWVudF9pZCwgY2xpZW50X3NlY3JldDogdGhpcy5jbGllbnRfc2VjcmV0IH0gfTtcbiAgICBjYXNlICdwcml2YXRlX2tleV9qd3QnOlxuICAgIGNhc2UgJ2NsaWVudF9zZWNyZXRfand0Jzoge1xuICAgICAgY29uc3QgdGltZXN0YW1wID0gbm93KCk7XG5cbiAgICAgIGNvbnN0IGFzc2VydGlvbiA9IGF3YWl0IGNsaWVudEFzc2VydGlvbi5jYWxsKHRoaXMsIGVuZHBvaW50LCB7XG4gICAgICAgIGlhdDogdGltZXN0YW1wLFxuICAgICAgICBleHA6IHRpbWVzdGFtcCArIDYwLFxuICAgICAgICBqdGk6IHJhbmRvbSgpLFxuICAgICAgICBpc3M6IHRoaXMuY2xpZW50X2lkLFxuICAgICAgICBzdWI6IHRoaXMuY2xpZW50X2lkLFxuICAgICAgICBhdWQ6IHRoaXMuaXNzdWVyLmlzc3VlcixcbiAgICAgICAgLi4uY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBmb3JtOiB7XG4gICAgICAgICAgY2xpZW50X2lkOiB0aGlzLmNsaWVudF9pZCxcbiAgICAgICAgICBjbGllbnRfYXNzZXJ0aW9uOiBhc3NlcnRpb24sXG4gICAgICAgICAgY2xpZW50X2Fzc2VydGlvbl90eXBlOiAndXJuOmlldGY6cGFyYW1zOm9hdXRoOmNsaWVudC1hc3NlcnRpb24tdHlwZTpqd3QtYmVhcmVyJyxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgJ2NsaWVudF9zZWNyZXRfYmFzaWMnOiB7XG4gICAgICAvLyBUaGlzIGlzIGNvcnJlY3QgYmVoYXZpb3VyLCBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY3NDkjc2VjdGlvbi0yLjMuMSBhbmQgdGhlXG4gICAgICAvLyByZWxhdGVkIGFwcGVuZGl4LiAoYWxzbyBodHRwczovL2dpdGh1Yi5jb20vcGFudmEvbm9kZS1vcGVuaWQtY2xpZW50L3B1bGwvOTEpXG4gICAgICAvLyA+IFRoZSBjbGllbnQgaWRlbnRpZmllciBpcyBlbmNvZGVkIHVzaW5nIHRoZVxuICAgICAgLy8gPiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiIGVuY29kaW5nIGFsZ29yaXRobSBwZXJcbiAgICAgIC8vID4gQXBwZW5kaXggQiwgYW5kIHRoZSBlbmNvZGVkIHZhbHVlIGlzIHVzZWQgYXMgdGhlIHVzZXJuYW1lOyB0aGUgY2xpZW50XG4gICAgICAvLyA+IHBhc3N3b3JkIGlzIGVuY29kZWQgdXNpbmcgdGhlIHNhbWUgYWxnb3JpdGhtIGFuZCB1c2VkIGFzIHRoZVxuICAgICAgLy8gPiBwYXNzd29yZC5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5jbGllbnRfc2VjcmV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdjbGllbnRfc2VjcmV0X2Jhc2ljIGNsaWVudCBhdXRoZW50aWNhdGlvbiBtZXRob2QgcmVxdWlyZXMgYSBjbGllbnRfc2VjcmV0JyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVuY29kZWQgPSBgJHtmb3JtVXJsRW5jb2RlKHRoaXMuY2xpZW50X2lkKX06JHtmb3JtVXJsRW5jb2RlKHRoaXMuY2xpZW50X3NlY3JldCl9YDtcbiAgICAgIGNvbnN0IHZhbHVlID0gQnVmZmVyLmZyb20oZW5jb2RlZCkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgcmV0dXJuIHsgaGVhZGVyczogeyBBdXRob3JpemF0aW9uOiBgQmFzaWMgJHt2YWx1ZX1gIH0gfTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgbWlzc2luZywgb3IgdW5zdXBwb3J0ZWQsICR7ZW5kcG9pbnR9X2VuZHBvaW50X2F1dGhfbWV0aG9kYCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVSZXNwb25zZVR5cGUoKSB7XG4gIGNvbnN0IHsgbGVuZ3RoLCAwOiB2YWx1ZSB9ID0gdGhpcy5yZXNwb25zZV90eXBlcztcblxuICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVJlZGlyZWN0VXJpKCkge1xuICBjb25zdCB7IGxlbmd0aCwgMDogdmFsdWUgfSA9IHRoaXMucmVkaXJlY3RfdXJpcyB8fCBbXTtcblxuICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gYXV0aGVudGljYXRlZFBvc3QoXG4gIGVuZHBvaW50LFxuICBvcHRzLFxuICB7IGNsaWVudEFzc2VydGlvblBheWxvYWQsIGVuZHBvaW50QXV0aE1ldGhvZCA9IGVuZHBvaW50LCBEUG9QIH0gPSB7fSxcbikge1xuICBjb25zdCBhdXRoID0gYXdhaXQgYXV0aEZvci5jYWxsKHRoaXMsIGVuZHBvaW50QXV0aE1ldGhvZCwgeyBjbGllbnRBc3NlcnRpb25QYXlsb2FkIH0pO1xuICBjb25zdCByZXF1ZXN0T3B0cyA9IG1lcmdlKG9wdHMsIGF1dGgpO1xuXG4gIGNvbnN0IG1UTFMgPVxuICAgIHRoaXNbYCR7ZW5kcG9pbnRBdXRoTWV0aG9kfV9lbmRwb2ludF9hdXRoX21ldGhvZGBdLmluY2x1ZGVzKCd0bHNfY2xpZW50X2F1dGgnKSB8fFxuICAgIChlbmRwb2ludCA9PT0gJ3Rva2VuJyAmJiB0aGlzLnRsc19jbGllbnRfY2VydGlmaWNhdGVfYm91bmRfYWNjZXNzX3Rva2Vucyk7XG5cbiAgbGV0IHRhcmdldFVybDtcbiAgaWYgKG1UTFMgJiYgdGhpcy5pc3N1ZXIubXRsc19lbmRwb2ludF9hbGlhc2VzKSB7XG4gICAgdGFyZ2V0VXJsID0gdGhpcy5pc3N1ZXIubXRsc19lbmRwb2ludF9hbGlhc2VzW2Ake2VuZHBvaW50fV9lbmRwb2ludGBdO1xuICB9XG5cbiAgdGFyZ2V0VXJsID0gdGFyZ2V0VXJsIHx8IHRoaXMuaXNzdWVyW2Ake2VuZHBvaW50fV9lbmRwb2ludGBdO1xuXG4gIGlmICgnZm9ybScgaW4gcmVxdWVzdE9wdHMpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyZXF1ZXN0T3B0cy5mb3JtKSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZGVsZXRlIHJlcXVlc3RPcHRzLmZvcm1ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVxdWVzdC5jYWxsKFxuICAgIHRoaXMsXG4gICAge1xuICAgICAgLi4ucmVxdWVzdE9wdHMsXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIHVybDogdGFyZ2V0VXJsLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi4oZW5kcG9pbnQgIT09ICdyZXZvY2F0aW9uJ1xuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IHVuZGVmaW5lZCksXG4gICAgICAgIC4uLnJlcXVlc3RPcHRzLmhlYWRlcnMsXG4gICAgICB9LFxuICAgIH0sXG4gICAgeyBtVExTLCBEUG9QIH0sXG4gICk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZXNvbHZlUmVzcG9uc2VUeXBlLFxuICByZXNvbHZlUmVkaXJlY3RVcmksXG4gIGF1dGhGb3IsXG4gIGF1dGhlbnRpY2F0ZWRQb3N0LFxufTtcbiJdLCJuYW1lcyI6WyJqb3NlIiwicmVxdWlyZSIsIlJQRXJyb3IiLCJhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uIiwicmFuZG9tIiwibm93IiwicmVxdWVzdCIsImtleXN0b3JlcyIsIm1lcmdlIiwiZm9ybVVybEVuY29kZSIsInZhbHVlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVwbGFjZSIsImNsaWVudEFzc2VydGlvbiIsImVuZHBvaW50IiwicGF5bG9hZCIsImFsZyIsImlzc3VlciIsInN1cHBvcnRlZCIsIkFycmF5IiwiaXNBcnJheSIsImZpbmQiLCJzaWduQWxnIiwidGVzdCIsIkNvbXBhY3RTaWduIiwiQnVmZmVyIiwiZnJvbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJzZXRQcm90ZWN0ZWRIZWFkZXIiLCJzaWduIiwic2VjcmV0Rm9yQWxnIiwia2V5c3RvcmUiLCJnZXQiLCJUeXBlRXJyb3IiLCJ1c2UiLCJrZXkiLCJraWQiLCJqd2siLCJrZXlPYmplY3QiLCJhdXRoRm9yIiwiY2xpZW50QXNzZXJ0aW9uUGF5bG9hZCIsImF1dGhNZXRob2QiLCJmb3JtIiwiY2xpZW50X2lkIiwiY2xpZW50X3NlY3JldCIsInRpbWVzdGFtcCIsImFzc2VydGlvbiIsImNhbGwiLCJpYXQiLCJleHAiLCJqdGkiLCJpc3MiLCJzdWIiLCJhdWQiLCJjbGllbnRfYXNzZXJ0aW9uIiwiY2xpZW50X2Fzc2VydGlvbl90eXBlIiwiZW5jb2RlZCIsInRvU3RyaW5nIiwiaGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJyZXNvbHZlUmVzcG9uc2VUeXBlIiwibGVuZ3RoIiwicmVzcG9uc2VfdHlwZXMiLCJ1bmRlZmluZWQiLCJyZXNvbHZlUmVkaXJlY3RVcmkiLCJyZWRpcmVjdF91cmlzIiwiYXV0aGVudGljYXRlZFBvc3QiLCJvcHRzIiwiZW5kcG9pbnRBdXRoTWV0aG9kIiwiRFBvUCIsImF1dGgiLCJyZXF1ZXN0T3B0cyIsIm1UTFMiLCJpbmNsdWRlcyIsInRsc19jbGllbnRfY2VydGlmaWNhdGVfYm91bmRfYWNjZXNzX3Rva2VucyIsInRhcmdldFVybCIsIm10bHNfZW5kcG9pbnRfYWxpYXNlcyIsIk9iamVjdCIsImVudHJpZXMiLCJtZXRob2QiLCJ1cmwiLCJBY2NlcHQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/client.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/consts.js":
/*!***********************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/consts.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("\nconst HTTP_OPTIONS = Symbol();\nconst CLOCK_TOLERANCE = Symbol();\nmodule.exports = {\n    CLOCK_TOLERANCE,\n    HTTP_OPTIONS\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvY29uc3RzLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNQSxlQUFlQztBQUNyQixNQUFNQyxrQkFBa0JEO0FBRXhCRSxPQUFPQyxPQUFPLEdBQUc7SUFDZkY7SUFDQUY7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2Vkc3UtaG91c2UtcHVibGljLy4uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL2NvbnN0cy5qcz9lZjVmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEhUVFBfT1BUSU9OUyA9IFN5bWJvbCgpO1xuY29uc3QgQ0xPQ0tfVE9MRVJBTkNFID0gU3ltYm9sKCk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBDTE9DS19UT0xFUkFOQ0UsXG4gIEhUVFBfT1BUSU9OUyxcbn07XG4iXSwibmFtZXMiOlsiSFRUUF9PUFRJT05TIiwiU3ltYm9sIiwiQ0xPQ0tfVE9MRVJBTkNFIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/consts.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/decode_jwt.js":
/*!***************************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/decode_jwt.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst base64url = __webpack_require__(/*! ./base64url */ \"(rsc)/../node_modules/openid-client/lib/helpers/base64url.js\");\nmodule.exports = (token)=>{\n    if (typeof token !== \"string\" || !token) {\n        throw new TypeError(\"JWT must be a string\");\n    }\n    const { 0: header, 1: payload, 2: signature, length } = token.split(\".\");\n    if (length === 5) {\n        throw new TypeError(\"encrypted JWTs cannot be decoded\");\n    }\n    if (length !== 3) {\n        throw new Error(\"JWTs must have three components\");\n    }\n    try {\n        return {\n            header: JSON.parse(base64url.decode(header)),\n            payload: JSON.parse(base64url.decode(payload)),\n            signature\n        };\n    } catch (err) {\n        throw new Error(\"JWT is malformed\");\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvZGVjb2RlX2p3dC5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTUEsWUFBWUMsbUJBQU9BLENBQUM7QUFFMUJDLE9BQU9DLE9BQU8sR0FBRyxDQUFDQztJQUNoQixJQUFJLE9BQU9BLFVBQVUsWUFBWSxDQUFDQSxPQUFPO1FBQ3ZDLE1BQU0sSUFBSUMsVUFBVTtJQUN0QjtJQUVBLE1BQU0sRUFBRSxHQUFHQyxNQUFNLEVBQUUsR0FBR0MsT0FBTyxFQUFFLEdBQUdDLFNBQVMsRUFBRUMsTUFBTSxFQUFFLEdBQUdMLE1BQU1NLEtBQUssQ0FBQztJQUVwRSxJQUFJRCxXQUFXLEdBQUc7UUFDaEIsTUFBTSxJQUFJSixVQUFVO0lBQ3RCO0lBRUEsSUFBSUksV0FBVyxHQUFHO1FBQ2hCLE1BQU0sSUFBSUUsTUFBTTtJQUNsQjtJQUVBLElBQUk7UUFDRixPQUFPO1lBQ0xMLFFBQVFNLEtBQUtDLEtBQUssQ0FBQ2IsVUFBVWMsTUFBTSxDQUFDUjtZQUNwQ0MsU0FBU0ssS0FBS0MsS0FBSyxDQUFDYixVQUFVYyxNQUFNLENBQUNQO1lBQ3JDQztRQUNGO0lBQ0YsRUFBRSxPQUFPTyxLQUFLO1FBQ1osTUFBTSxJQUFJSixNQUFNO0lBQ2xCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lZHN1LWhvdXNlLXB1YmxpYy8uLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9kZWNvZGVfand0LmpzPzY5ZmMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYmFzZTY0dXJsID0gcmVxdWlyZSgnLi9iYXNlNjR1cmwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAodG9rZW4pID0+IHtcbiAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ3N0cmluZycgfHwgIXRva2VuKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSldUIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIGNvbnN0IHsgMDogaGVhZGVyLCAxOiBwYXlsb2FkLCAyOiBzaWduYXR1cmUsIGxlbmd0aCB9ID0gdG9rZW4uc3BsaXQoJy4nKTtcblxuICBpZiAobGVuZ3RoID09PSA1KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jcnlwdGVkIEpXVHMgY2Fubm90IGJlIGRlY29kZWQnKTtcbiAgfVxuXG4gIGlmIChsZW5ndGggIT09IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0pXVHMgbXVzdCBoYXZlIHRocmVlIGNvbXBvbmVudHMnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhlYWRlcjogSlNPTi5wYXJzZShiYXNlNjR1cmwuZGVjb2RlKGhlYWRlcikpLFxuICAgICAgcGF5bG9hZDogSlNPTi5wYXJzZShiYXNlNjR1cmwuZGVjb2RlKHBheWxvYWQpKSxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICB9O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0pXVCBpcyBtYWxmb3JtZWQnKTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6WyJiYXNlNjR1cmwiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyIsInRva2VuIiwiVHlwZUVycm9yIiwiaGVhZGVyIiwicGF5bG9hZCIsInNpZ25hdHVyZSIsImxlbmd0aCIsInNwbGl0IiwiRXJyb3IiLCJKU09OIiwicGFyc2UiLCJkZWNvZGUiLCJlcnIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/decode_jwt.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/deep_clone.js":
/*!***************************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/deep_clone.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\nmodule.exports = globalThis.structuredClone || ((obj)=>JSON.parse(JSON.stringify(obj)));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvZGVlcF9jbG9uZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUFBLE9BQU9DLE9BQU8sR0FBR0MsV0FBV0MsZUFBZSxJQUFLLEVBQUNDLE1BQVFDLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsU0FBUyxDQUFDSCxLQUFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWRzdS1ob3VzZS1wdWJsaWMvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvZGVlcF9jbG9uZS5qcz9hM2Y0Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsVGhpcy5zdHJ1Y3R1cmVkQ2xvbmUgfHwgKChvYmopID0+IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSkpO1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJnbG9iYWxUaGlzIiwic3RydWN0dXJlZENsb25lIiwib2JqIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/deep_clone.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/defaults.js":
/*!*************************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/defaults.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst isPlainObject = __webpack_require__(/*! ./is_plain_object */ \"(rsc)/../node_modules/openid-client/lib/helpers/is_plain_object.js\");\nfunction defaults(deep, target, ...sources) {\n    for (const source of sources){\n        if (!isPlainObject(source)) {\n            continue;\n        }\n        for (const [key, value] of Object.entries(source)){\n            /* istanbul ignore if */ if (key === \"__proto__\" || key === \"constructor\") {\n                continue;\n            }\n            if (typeof target[key] === \"undefined\" && typeof value !== \"undefined\") {\n                target[key] = value;\n            }\n            if (deep && isPlainObject(target[key]) && isPlainObject(value)) {\n                defaults(true, target[key], value);\n            }\n        }\n    }\n    return target;\n}\nmodule.exports = defaults.bind(undefined, false);\nmodule.exports.deep = defaults.bind(undefined, true);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvZGVmYXVsdHMuanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU1BLGdCQUFnQkMsbUJBQU9BLENBQUM7QUFFOUIsU0FBU0MsU0FBU0MsSUFBSSxFQUFFQyxNQUFNLEVBQUUsR0FBR0MsT0FBTztJQUN4QyxLQUFLLE1BQU1DLFVBQVVELFFBQVM7UUFDNUIsSUFBSSxDQUFDTCxjQUFjTSxTQUFTO1lBQzFCO1FBQ0Y7UUFDQSxLQUFLLE1BQU0sQ0FBQ0MsS0FBS0MsTUFBTSxJQUFJQyxPQUFPQyxPQUFPLENBQUNKLFFBQVM7WUFDakQsc0JBQXNCLEdBQ3RCLElBQUlDLFFBQVEsZUFBZUEsUUFBUSxlQUFlO2dCQUNoRDtZQUNGO1lBQ0EsSUFBSSxPQUFPSCxNQUFNLENBQUNHLElBQUksS0FBSyxlQUFlLE9BQU9DLFVBQVUsYUFBYTtnQkFDdEVKLE1BQU0sQ0FBQ0csSUFBSSxHQUFHQztZQUNoQjtZQUVBLElBQUlMLFFBQVFILGNBQWNJLE1BQU0sQ0FBQ0csSUFBSSxLQUFLUCxjQUFjUSxRQUFRO2dCQUM5RE4sU0FBUyxNQUFNRSxNQUFNLENBQUNHLElBQUksRUFBRUM7WUFDOUI7UUFDRjtJQUNGO0lBRUEsT0FBT0o7QUFDVDtBQUVBTyxPQUFPQyxPQUFPLEdBQUdWLFNBQVNXLElBQUksQ0FBQ0MsV0FBVztBQUMxQ0gsbUJBQW1CLEdBQUdULFNBQVNXLElBQUksQ0FBQ0MsV0FBVyIsInNvdXJjZXMiOlsid2VicGFjazovL2Vkc3UtaG91c2UtcHVibGljLy4uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL2RlZmF1bHRzLmpzP2I2YmEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vaXNfcGxhaW5fb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIGRlZmF1bHRzKGRlZXAsIHRhcmdldCwgLi4uc291cmNlcykge1xuICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzb3VyY2UpKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nIHx8IGtleSA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdGFyZ2V0W2tleV0gPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlZXAgJiYgaXNQbGFpbk9iamVjdCh0YXJnZXRba2V5XSkgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgZGVmYXVsdHModHJ1ZSwgdGFyZ2V0W2tleV0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzLmJpbmQodW5kZWZpbmVkLCBmYWxzZSk7XG5tb2R1bGUuZXhwb3J0cy5kZWVwID0gZGVmYXVsdHMuYmluZCh1bmRlZmluZWQsIHRydWUpO1xuIl0sIm5hbWVzIjpbImlzUGxhaW5PYmplY3QiLCJyZXF1aXJlIiwiZGVmYXVsdHMiLCJkZWVwIiwidGFyZ2V0Iiwic291cmNlcyIsInNvdXJjZSIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJiaW5kIiwidW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/defaults.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/generators.js":
/*!***************************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/generators.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { createHash, randomBytes } = __webpack_require__(/*! crypto */ \"crypto\");\nconst base64url = __webpack_require__(/*! ./base64url */ \"(rsc)/../node_modules/openid-client/lib/helpers/base64url.js\");\nconst random = (bytes = 32)=>base64url.encode(randomBytes(bytes));\nmodule.exports = {\n    random,\n    state: random,\n    nonce: random,\n    codeVerifier: random,\n    codeChallenge: (codeVerifier)=>base64url.encode(createHash(\"sha256\").update(codeVerifier).digest())\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvZ2VuZXJhdG9ycy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxFQUFFQSxVQUFVLEVBQUVDLFdBQVcsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUU1QyxNQUFNQyxZQUFZRCxtQkFBT0EsQ0FBQztBQUUxQixNQUFNRSxTQUFTLENBQUNDLFFBQVEsRUFBRSxHQUFLRixVQUFVRyxNQUFNLENBQUNMLFlBQVlJO0FBRTVERSxPQUFPQyxPQUFPLEdBQUc7SUFDZko7SUFDQUssT0FBT0w7SUFDUE0sT0FBT047SUFDUE8sY0FBY1A7SUFDZFEsZUFBZSxDQUFDRCxlQUNkUixVQUFVRyxNQUFNLENBQUNOLFdBQVcsVUFBVWEsTUFBTSxDQUFDRixjQUFjRyxNQUFNO0FBQ3JFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWRzdS1ob3VzZS1wdWJsaWMvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvZ2VuZXJhdG9ycy5qcz9lMTJlIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgY3JlYXRlSGFzaCwgcmFuZG9tQnl0ZXMgfSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG5jb25zdCBiYXNlNjR1cmwgPSByZXF1aXJlKCcuL2Jhc2U2NHVybCcpO1xuXG5jb25zdCByYW5kb20gPSAoYnl0ZXMgPSAzMikgPT4gYmFzZTY0dXJsLmVuY29kZShyYW5kb21CeXRlcyhieXRlcykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmFuZG9tLFxuICBzdGF0ZTogcmFuZG9tLFxuICBub25jZTogcmFuZG9tLFxuICBjb2RlVmVyaWZpZXI6IHJhbmRvbSxcbiAgY29kZUNoYWxsZW5nZTogKGNvZGVWZXJpZmllcikgPT5cbiAgICBiYXNlNjR1cmwuZW5jb2RlKGNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShjb2RlVmVyaWZpZXIpLmRpZ2VzdCgpKSxcbn07XG4iXSwibmFtZXMiOlsiY3JlYXRlSGFzaCIsInJhbmRvbUJ5dGVzIiwicmVxdWlyZSIsImJhc2U2NHVybCIsInJhbmRvbSIsImJ5dGVzIiwiZW5jb2RlIiwibW9kdWxlIiwiZXhwb3J0cyIsInN0YXRlIiwibm9uY2UiLCJjb2RlVmVyaWZpZXIiLCJjb2RlQ2hhbGxlbmdlIiwidXBkYXRlIiwiZGlnZXN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/generators.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/is_key_object.js":
/*!******************************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/is_key_object.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst util = __webpack_require__(/*! util */ \"util\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nmodule.exports = util.types.isKeyObject || ((obj)=>obj && obj instanceof crypto.KeyObject);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvaXNfa2V5X29iamVjdC5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTUEsT0FBT0MsbUJBQU9BLENBQUM7QUFDckIsTUFBTUMsU0FBU0QsbUJBQU9BLENBQUM7QUFFdkJFLE9BQU9DLE9BQU8sR0FBR0osS0FBS0ssS0FBSyxDQUFDQyxXQUFXLElBQUssRUFBQ0MsTUFBUUEsT0FBT0EsZUFBZUwsT0FBT00sU0FBUSIsInNvdXJjZXMiOlsid2VicGFjazovL2Vkc3UtaG91c2UtcHVibGljLy4uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL2lzX2tleV9vYmplY3QuanM/ODFmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gdXRpbC50eXBlcy5pc0tleU9iamVjdCB8fCAoKG9iaikgPT4gb2JqICYmIG9iaiBpbnN0YW5jZW9mIGNyeXB0by5LZXlPYmplY3QpO1xuIl0sIm5hbWVzIjpbInV0aWwiLCJyZXF1aXJlIiwiY3J5cHRvIiwibW9kdWxlIiwiZXhwb3J0cyIsInR5cGVzIiwiaXNLZXlPYmplY3QiLCJvYmoiLCJLZXlPYmplY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/is_key_object.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/is_plain_object.js":
/*!********************************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/is_plain_object.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("\nmodule.exports = (a)=>!!a && a.constructor === Object;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvaXNfcGxhaW5fb2JqZWN0LmpzIiwibWFwcGluZ3MiOiI7QUFBQUEsT0FBT0MsT0FBTyxHQUFHLENBQUNDLElBQU0sQ0FBQyxDQUFDQSxLQUFLQSxFQUFFQyxXQUFXLEtBQUtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWRzdS1ob3VzZS1wdWJsaWMvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvaXNfcGxhaW5fb2JqZWN0LmpzPzgzOTkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSAoYSkgPT4gISFhICYmIGEuY29uc3RydWN0b3IgPT09IE9iamVjdDtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiYSIsImNvbnN0cnVjdG9yIiwiT2JqZWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/is_plain_object.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/issuer.js":
/*!***********************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/issuer.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst objectHash = __webpack_require__(/*! object-hash */ \"(rsc)/../node_modules/object-hash/index.js\");\nconst LRU = __webpack_require__(/*! lru-cache */ \"(rsc)/../node_modules/lru-cache/index.js\");\nconst { RPError } = __webpack_require__(/*! ../errors */ \"(rsc)/../node_modules/openid-client/lib/errors.js\");\nconst { assertIssuerConfiguration } = __webpack_require__(/*! ./assert */ \"(rsc)/../node_modules/openid-client/lib/helpers/assert.js\");\nconst KeyStore = __webpack_require__(/*! ./keystore */ \"(rsc)/../node_modules/openid-client/lib/helpers/keystore.js\");\nconst { keystores } = __webpack_require__(/*! ./weak_cache */ \"(rsc)/../node_modules/openid-client/lib/helpers/weak_cache.js\");\nconst processResponse = __webpack_require__(/*! ./process_response */ \"(rsc)/../node_modules/openid-client/lib/helpers/process_response.js\");\nconst request = __webpack_require__(/*! ./request */ \"(rsc)/../node_modules/openid-client/lib/helpers/request.js\");\nconst inFlight = new WeakMap();\nconst caches = new WeakMap();\nconst lrus = (ctx)=>{\n    if (!caches.has(ctx)) {\n        caches.set(ctx, new LRU({\n            max: 100\n        }));\n    }\n    return caches.get(ctx);\n};\nasync function getKeyStore(reload = false) {\n    assertIssuerConfiguration(this, \"jwks_uri\");\n    const keystore = keystores.get(this);\n    const cache = lrus(this);\n    if (reload || !keystore) {\n        if (inFlight.has(this)) {\n            return inFlight.get(this);\n        }\n        cache.reset();\n        inFlight.set(this, (async ()=>{\n            const response = await request.call(this, {\n                method: \"GET\",\n                responseType: \"json\",\n                url: this.jwks_uri,\n                headers: {\n                    Accept: \"application/json, application/jwk-set+json\"\n                }\n            }).finally(()=>{\n                inFlight.delete(this);\n            });\n            const jwks = processResponse(response);\n            const joseKeyStore = KeyStore.fromJWKS(jwks, {\n                onlyPublic: true\n            });\n            cache.set(\"throttle\", true, 60 * 1000);\n            keystores.set(this, joseKeyStore);\n            return joseKeyStore;\n        })());\n        return inFlight.get(this);\n    }\n    return keystore;\n}\nasync function queryKeyStore({ kid, kty, alg, use }, { allowMulti = false } = {}) {\n    const cache = lrus(this);\n    const def = {\n        kid,\n        kty,\n        alg,\n        use\n    };\n    const defHash = objectHash(def, {\n        algorithm: \"sha256\",\n        ignoreUnknown: true,\n        unorderedArrays: true,\n        unorderedSets: true,\n        respectType: false\n    });\n    // refresh keystore on every unknown key but also only upto once every minute\n    const freshJwksUri = cache.get(defHash) || cache.get(\"throttle\");\n    const keystore = await getKeyStore.call(this, !freshJwksUri);\n    const keys = keystore.all(def);\n    delete def.use;\n    if (keys.length === 0) {\n        throw new RPError({\n            printf: [\n                \"no valid key found in issuer's jwks_uri for key parameters %j\",\n                def\n            ],\n            jwks: keystore\n        });\n    }\n    if (!allowMulti && keys.length > 1 && !kid) {\n        throw new RPError({\n            printf: [\n                \"multiple matching keys found in issuer's jwks_uri for key parameters %j, kid must be provided in this case\",\n                def\n            ],\n            jwks: keystore\n        });\n    }\n    cache.set(defHash, true);\n    return keys;\n}\nmodule.exports.queryKeyStore = queryKeyStore;\nmodule.exports.keystore = getKeyStore;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvaXNzdWVyLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNQSxhQUFhQyxtQkFBT0EsQ0FBQztBQUMzQixNQUFNQyxNQUFNRCxtQkFBT0EsQ0FBQztBQUVwQixNQUFNLEVBQUVFLE9BQU8sRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUU1QixNQUFNLEVBQUVHLHlCQUF5QixFQUFFLEdBQUdILG1CQUFPQSxDQUFDO0FBQzlDLE1BQU1JLFdBQVdKLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU0sRUFBRUssU0FBUyxFQUFFLEdBQUdMLG1CQUFPQSxDQUFDO0FBQzlCLE1BQU1NLGtCQUFrQk4sbUJBQU9BLENBQUM7QUFDaEMsTUFBTU8sVUFBVVAsbUJBQU9BLENBQUM7QUFFeEIsTUFBTVEsV0FBVyxJQUFJQztBQUNyQixNQUFNQyxTQUFTLElBQUlEO0FBQ25CLE1BQU1FLE9BQU8sQ0FBQ0M7SUFDWixJQUFJLENBQUNGLE9BQU9HLEdBQUcsQ0FBQ0QsTUFBTTtRQUNwQkYsT0FBT0ksR0FBRyxDQUFDRixLQUFLLElBQUlYLElBQUk7WUFBRWMsS0FBSztRQUFJO0lBQ3JDO0lBQ0EsT0FBT0wsT0FBT00sR0FBRyxDQUFDSjtBQUNwQjtBQUVBLGVBQWVLLFlBQVlDLFNBQVMsS0FBSztJQUN2Q2YsMEJBQTBCLElBQUksRUFBRTtJQUVoQyxNQUFNZ0IsV0FBV2QsVUFBVVcsR0FBRyxDQUFDLElBQUk7SUFDbkMsTUFBTUksUUFBUVQsS0FBSyxJQUFJO0lBRXZCLElBQUlPLFVBQVUsQ0FBQ0MsVUFBVTtRQUN2QixJQUFJWCxTQUFTSyxHQUFHLENBQUMsSUFBSSxHQUFHO1lBQ3RCLE9BQU9MLFNBQVNRLEdBQUcsQ0FBQyxJQUFJO1FBQzFCO1FBQ0FJLE1BQU1DLEtBQUs7UUFDWGIsU0FBU00sR0FBRyxDQUNWLElBQUksRUFDSixDQUFDO1lBQ0MsTUFBTVEsV0FBVyxNQUFNZixRQUNwQmdCLElBQUksQ0FBQyxJQUFJLEVBQUU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JDLGNBQWM7Z0JBQ2RDLEtBQUssSUFBSSxDQUFDQyxRQUFRO2dCQUNsQkMsU0FBUztvQkFDUEMsUUFBUTtnQkFDVjtZQUNGLEdBQ0NDLE9BQU8sQ0FBQztnQkFDUHRCLFNBQVN1QixNQUFNLENBQUMsSUFBSTtZQUN0QjtZQUNGLE1BQU1DLE9BQU8xQixnQkFBZ0JnQjtZQUU3QixNQUFNVyxlQUFlN0IsU0FBUzhCLFFBQVEsQ0FBQ0YsTUFBTTtnQkFBRUcsWUFBWTtZQUFLO1lBQ2hFZixNQUFNTixHQUFHLENBQUMsWUFBWSxNQUFNLEtBQUs7WUFDakNULFVBQVVTLEdBQUcsQ0FBQyxJQUFJLEVBQUVtQjtZQUVwQixPQUFPQTtRQUNUO1FBR0YsT0FBT3pCLFNBQVNRLEdBQUcsQ0FBQyxJQUFJO0lBQzFCO0lBRUEsT0FBT0c7QUFDVDtBQUVBLGVBQWVpQixjQUFjLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRSxFQUFFLEVBQUVDLGFBQWEsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQzlFLE1BQU1yQixRQUFRVCxLQUFLLElBQUk7SUFFdkIsTUFBTStCLE1BQU07UUFDVkw7UUFDQUM7UUFDQUM7UUFDQUM7SUFDRjtJQUVBLE1BQU1HLFVBQVU1QyxXQUFXMkMsS0FBSztRQUM5QkUsV0FBVztRQUNYQyxlQUFlO1FBQ2ZDLGlCQUFpQjtRQUNqQkMsZUFBZTtRQUNmQyxhQUFhO0lBQ2Y7SUFFQSw2RUFBNkU7SUFDN0UsTUFBTUMsZUFBZTdCLE1BQU1KLEdBQUcsQ0FBQzJCLFlBQVl2QixNQUFNSixHQUFHLENBQUM7SUFFckQsTUFBTUcsV0FBVyxNQUFNRixZQUFZTSxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMwQjtJQUMvQyxNQUFNQyxPQUFPL0IsU0FBU2dDLEdBQUcsQ0FBQ1Q7SUFFMUIsT0FBT0EsSUFBSUYsR0FBRztJQUNkLElBQUlVLEtBQUtFLE1BQU0sS0FBSyxHQUFHO1FBQ3JCLE1BQU0sSUFBSWxELFFBQVE7WUFDaEJtRCxRQUFRO2dCQUFDO2dCQUFpRVg7YUFBSTtZQUM5RVYsTUFBTWI7UUFDUjtJQUNGO0lBRUEsSUFBSSxDQUFDc0IsY0FBY1MsS0FBS0UsTUFBTSxHQUFHLEtBQUssQ0FBQ2YsS0FBSztRQUMxQyxNQUFNLElBQUluQyxRQUFRO1lBQ2hCbUQsUUFBUTtnQkFDTjtnQkFDQVg7YUFDRDtZQUNEVixNQUFNYjtRQUNSO0lBQ0Y7SUFFQUMsTUFBTU4sR0FBRyxDQUFDNkIsU0FBUztJQUVuQixPQUFPTztBQUNUO0FBRUFJLDRCQUE0QixHQUFHbEI7QUFDL0JrQix1QkFBdUIsR0FBR3JDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWRzdS1ob3VzZS1wdWJsaWMvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvaXNzdWVyLmpzPzA1NGMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgb2JqZWN0SGFzaCA9IHJlcXVpcmUoJ29iamVjdC1oYXNoJyk7XG5jb25zdCBMUlUgPSByZXF1aXJlKCdscnUtY2FjaGUnKTtcblxuY29uc3QgeyBSUEVycm9yIH0gPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcblxuY29uc3QgeyBhc3NlcnRJc3N1ZXJDb25maWd1cmF0aW9uIH0gPSByZXF1aXJlKCcuL2Fzc2VydCcpO1xuY29uc3QgS2V5U3RvcmUgPSByZXF1aXJlKCcuL2tleXN0b3JlJyk7XG5jb25zdCB7IGtleXN0b3JlcyB9ID0gcmVxdWlyZSgnLi93ZWFrX2NhY2hlJyk7XG5jb25zdCBwcm9jZXNzUmVzcG9uc2UgPSByZXF1aXJlKCcuL3Byb2Nlc3NfcmVzcG9uc2UnKTtcbmNvbnN0IHJlcXVlc3QgPSByZXF1aXJlKCcuL3JlcXVlc3QnKTtcblxuY29uc3QgaW5GbGlnaHQgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgY2FjaGVzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGxydXMgPSAoY3R4KSA9PiB7XG4gIGlmICghY2FjaGVzLmhhcyhjdHgpKSB7XG4gICAgY2FjaGVzLnNldChjdHgsIG5ldyBMUlUoeyBtYXg6IDEwMCB9KSk7XG4gIH1cbiAgcmV0dXJuIGNhY2hlcy5nZXQoY3R4KTtcbn07XG5cbmFzeW5jIGZ1bmN0aW9uIGdldEtleVN0b3JlKHJlbG9hZCA9IGZhbHNlKSB7XG4gIGFzc2VydElzc3VlckNvbmZpZ3VyYXRpb24odGhpcywgJ2p3a3NfdXJpJyk7XG5cbiAgY29uc3Qga2V5c3RvcmUgPSBrZXlzdG9yZXMuZ2V0KHRoaXMpO1xuICBjb25zdCBjYWNoZSA9IGxydXModGhpcyk7XG5cbiAgaWYgKHJlbG9hZCB8fCAha2V5c3RvcmUpIHtcbiAgICBpZiAoaW5GbGlnaHQuaGFzKHRoaXMpKSB7XG4gICAgICByZXR1cm4gaW5GbGlnaHQuZ2V0KHRoaXMpO1xuICAgIH1cbiAgICBjYWNoZS5yZXNldCgpO1xuICAgIGluRmxpZ2h0LnNldChcbiAgICAgIHRoaXMsXG4gICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RcbiAgICAgICAgICAuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICAgICAgICB1cmw6IHRoaXMuandrc191cmksXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24sIGFwcGxpY2F0aW9uL2p3ay1zZXQranNvbicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgaW5GbGlnaHQuZGVsZXRlKHRoaXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICBjb25zdCBqd2tzID0gcHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlKTtcblxuICAgICAgICBjb25zdCBqb3NlS2V5U3RvcmUgPSBLZXlTdG9yZS5mcm9tSldLUyhqd2tzLCB7IG9ubHlQdWJsaWM6IHRydWUgfSk7XG4gICAgICAgIGNhY2hlLnNldCgndGhyb3R0bGUnLCB0cnVlLCA2MCAqIDEwMDApO1xuICAgICAgICBrZXlzdG9yZXMuc2V0KHRoaXMsIGpvc2VLZXlTdG9yZSk7XG5cbiAgICAgICAgcmV0dXJuIGpvc2VLZXlTdG9yZTtcbiAgICAgIH0pKCksXG4gICAgKTtcblxuICAgIHJldHVybiBpbkZsaWdodC5nZXQodGhpcyk7XG4gIH1cblxuICByZXR1cm4ga2V5c3RvcmU7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHF1ZXJ5S2V5U3RvcmUoeyBraWQsIGt0eSwgYWxnLCB1c2UgfSwgeyBhbGxvd011bHRpID0gZmFsc2UgfSA9IHt9KSB7XG4gIGNvbnN0IGNhY2hlID0gbHJ1cyh0aGlzKTtcblxuICBjb25zdCBkZWYgPSB7XG4gICAga2lkLFxuICAgIGt0eSxcbiAgICBhbGcsXG4gICAgdXNlLFxuICB9O1xuXG4gIGNvbnN0IGRlZkhhc2ggPSBvYmplY3RIYXNoKGRlZiwge1xuICAgIGFsZ29yaXRobTogJ3NoYTI1NicsXG4gICAgaWdub3JlVW5rbm93bjogdHJ1ZSxcbiAgICB1bm9yZGVyZWRBcnJheXM6IHRydWUsXG4gICAgdW5vcmRlcmVkU2V0czogdHJ1ZSxcbiAgICByZXNwZWN0VHlwZTogZmFsc2UsXG4gIH0pO1xuXG4gIC8vIHJlZnJlc2gga2V5c3RvcmUgb24gZXZlcnkgdW5rbm93biBrZXkgYnV0IGFsc28gb25seSB1cHRvIG9uY2UgZXZlcnkgbWludXRlXG4gIGNvbnN0IGZyZXNoSndrc1VyaSA9IGNhY2hlLmdldChkZWZIYXNoKSB8fCBjYWNoZS5nZXQoJ3Rocm90dGxlJyk7XG5cbiAgY29uc3Qga2V5c3RvcmUgPSBhd2FpdCBnZXRLZXlTdG9yZS5jYWxsKHRoaXMsICFmcmVzaEp3a3NVcmkpO1xuICBjb25zdCBrZXlzID0ga2V5c3RvcmUuYWxsKGRlZik7XG5cbiAgZGVsZXRlIGRlZi51c2U7XG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgIHByaW50ZjogW1wibm8gdmFsaWQga2V5IGZvdW5kIGluIGlzc3VlcidzIGp3a3NfdXJpIGZvciBrZXkgcGFyYW1ldGVycyAlalwiLCBkZWZdLFxuICAgICAgandrczoga2V5c3RvcmUsXG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWFsbG93TXVsdGkgJiYga2V5cy5sZW5ndGggPiAxICYmICFraWQpIHtcbiAgICB0aHJvdyBuZXcgUlBFcnJvcih7XG4gICAgICBwcmludGY6IFtcbiAgICAgICAgXCJtdWx0aXBsZSBtYXRjaGluZyBrZXlzIGZvdW5kIGluIGlzc3VlcidzIGp3a3NfdXJpIGZvciBrZXkgcGFyYW1ldGVycyAlaiwga2lkIG11c3QgYmUgcHJvdmlkZWQgaW4gdGhpcyBjYXNlXCIsXG4gICAgICAgIGRlZixcbiAgICAgIF0sXG4gICAgICBqd2tzOiBrZXlzdG9yZSxcbiAgICB9KTtcbiAgfVxuXG4gIGNhY2hlLnNldChkZWZIYXNoLCB0cnVlKTtcblxuICByZXR1cm4ga2V5cztcbn1cblxubW9kdWxlLmV4cG9ydHMucXVlcnlLZXlTdG9yZSA9IHF1ZXJ5S2V5U3RvcmU7XG5tb2R1bGUuZXhwb3J0cy5rZXlzdG9yZSA9IGdldEtleVN0b3JlO1xuIl0sIm5hbWVzIjpbIm9iamVjdEhhc2giLCJyZXF1aXJlIiwiTFJVIiwiUlBFcnJvciIsImFzc2VydElzc3VlckNvbmZpZ3VyYXRpb24iLCJLZXlTdG9yZSIsImtleXN0b3JlcyIsInByb2Nlc3NSZXNwb25zZSIsInJlcXVlc3QiLCJpbkZsaWdodCIsIldlYWtNYXAiLCJjYWNoZXMiLCJscnVzIiwiY3R4IiwiaGFzIiwic2V0IiwibWF4IiwiZ2V0IiwiZ2V0S2V5U3RvcmUiLCJyZWxvYWQiLCJrZXlzdG9yZSIsImNhY2hlIiwicmVzZXQiLCJyZXNwb25zZSIsImNhbGwiLCJtZXRob2QiLCJyZXNwb25zZVR5cGUiLCJ1cmwiLCJqd2tzX3VyaSIsImhlYWRlcnMiLCJBY2NlcHQiLCJmaW5hbGx5IiwiZGVsZXRlIiwiandrcyIsImpvc2VLZXlTdG9yZSIsImZyb21KV0tTIiwib25seVB1YmxpYyIsInF1ZXJ5S2V5U3RvcmUiLCJraWQiLCJrdHkiLCJhbGciLCJ1c2UiLCJhbGxvd011bHRpIiwiZGVmIiwiZGVmSGFzaCIsImFsZ29yaXRobSIsImlnbm9yZVVua25vd24iLCJ1bm9yZGVyZWRBcnJheXMiLCJ1bm9yZGVyZWRTZXRzIiwicmVzcGVjdFR5cGUiLCJmcmVzaEp3a3NVcmkiLCJrZXlzIiwiYWxsIiwibGVuZ3RoIiwicHJpbnRmIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/issuer.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/keystore.js":
/*!*************************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/keystore.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst jose = __webpack_require__(/*! jose */ \"(rsc)/../node_modules/jose/dist/node/cjs/index.js\");\nconst clone = __webpack_require__(/*! ./deep_clone */ \"(rsc)/../node_modules/openid-client/lib/helpers/deep_clone.js\");\nconst isPlainObject = __webpack_require__(/*! ./is_plain_object */ \"(rsc)/../node_modules/openid-client/lib/helpers/is_plain_object.js\");\nconst internal = Symbol();\nconst keyscore = (key, { alg, use })=>{\n    let score = 0;\n    if (alg && key.alg) {\n        score++;\n    }\n    if (use && key.use) {\n        score++;\n    }\n    return score;\n};\nfunction getKtyFromAlg(alg) {\n    switch(typeof alg === \"string\" && alg.slice(0, 2)){\n        case \"RS\":\n        case \"PS\":\n            return \"RSA\";\n        case \"ES\":\n            return \"EC\";\n        case \"Ed\":\n            return \"OKP\";\n        default:\n            return undefined;\n    }\n}\nfunction getAlgorithms(use, alg, kty, crv) {\n    // Ed25519, Ed448, and secp256k1 always have \"alg\"\n    // OKP always has \"use\"\n    if (alg) {\n        return new Set([\n            alg\n        ]);\n    }\n    switch(kty){\n        case \"EC\":\n            {\n                let algs = [];\n                if (use === \"enc\" || use === undefined) {\n                    algs = algs.concat([\n                        \"ECDH-ES\",\n                        \"ECDH-ES+A128KW\",\n                        \"ECDH-ES+A192KW\",\n                        \"ECDH-ES+A256KW\"\n                    ]);\n                }\n                if (use === \"sig\" || use === undefined) {\n                    switch(crv){\n                        case \"P-256\":\n                        case \"P-384\":\n                            algs = algs.concat([\n                                `ES${crv.slice(-3)}`\n                            ]);\n                            break;\n                        case \"P-521\":\n                            algs = algs.concat([\n                                \"ES512\"\n                            ]);\n                            break;\n                        case \"secp256k1\":\n                            if (jose.cryptoRuntime === \"node:crypto\") {\n                                algs = algs.concat([\n                                    \"ES256K\"\n                                ]);\n                            }\n                            break;\n                    }\n                }\n                return new Set(algs);\n            }\n        case \"OKP\":\n            {\n                return new Set([\n                    \"ECDH-ES\",\n                    \"ECDH-ES+A128KW\",\n                    \"ECDH-ES+A192KW\",\n                    \"ECDH-ES+A256KW\"\n                ]);\n            }\n        case \"RSA\":\n            {\n                let algs = [];\n                if (use === \"enc\" || use === undefined) {\n                    algs = algs.concat([\n                        \"RSA-OAEP\",\n                        \"RSA-OAEP-256\",\n                        \"RSA-OAEP-384\",\n                        \"RSA-OAEP-512\"\n                    ]);\n                    if (jose.cryptoRuntime === \"node:crypto\") {\n                        algs = algs.concat([\n                            \"RSA1_5\"\n                        ]);\n                    }\n                }\n                if (use === \"sig\" || use === undefined) {\n                    algs = algs.concat([\n                        \"PS256\",\n                        \"PS384\",\n                        \"PS512\",\n                        \"RS256\",\n                        \"RS384\",\n                        \"RS512\"\n                    ]);\n                }\n                return new Set(algs);\n            }\n        default:\n            throw new Error(\"unreachable\");\n    }\n}\nmodule.exports = class KeyStore {\n    #keys;\n    constructor(i, keys){\n        if (i !== internal) throw new Error(\"invalid constructor call\");\n        this.#keys = keys;\n    }\n    toJWKS() {\n        return {\n            keys: this.map(({ jwk: { d, p, q, dp, dq, qi, ...jwk } })=>jwk)\n        };\n    }\n    all({ alg, kid, use } = {}) {\n        if (!use || !alg) {\n            throw new Error();\n        }\n        const kty = getKtyFromAlg(alg);\n        const search = {\n            alg,\n            use\n        };\n        return this.filter((key)=>{\n            let candidate = true;\n            if (candidate && kty !== undefined && key.jwk.kty !== kty) {\n                candidate = false;\n            }\n            if (candidate && kid !== undefined && key.jwk.kid !== kid) {\n                candidate = false;\n            }\n            if (candidate && use !== undefined && key.jwk.use !== undefined && key.jwk.use !== use) {\n                candidate = false;\n            }\n            if (candidate && key.jwk.alg && key.jwk.alg !== alg) {\n                candidate = false;\n            } else if (!key.algorithms.has(alg)) {\n                candidate = false;\n            }\n            return candidate;\n        }).sort((first, second)=>keyscore(second, search) - keyscore(first, search));\n    }\n    get(...args) {\n        return this.all(...args)[0];\n    }\n    static async fromJWKS(jwks, { onlyPublic = false, onlyPrivate = false } = {}) {\n        if (!isPlainObject(jwks) || !Array.isArray(jwks.keys) || jwks.keys.some((k)=>!isPlainObject(k) || !(\"kty\" in k))) {\n            throw new TypeError(\"jwks must be a JSON Web Key Set formatted object\");\n        }\n        const keys = [];\n        for (let jwk of jwks.keys){\n            jwk = clone(jwk);\n            const { kty, kid, crv } = jwk;\n            let { alg, use } = jwk;\n            if (typeof kty !== \"string\" || !kty) {\n                continue;\n            }\n            if (use !== undefined && use !== \"sig\" && use !== \"enc\") {\n                continue;\n            }\n            if (typeof alg !== \"string\" && alg !== undefined) {\n                continue;\n            }\n            if (typeof kid !== \"string\" && kid !== undefined) {\n                continue;\n            }\n            if (kty === \"EC\" && use === \"sig\") {\n                switch(crv){\n                    case \"P-256\":\n                        alg = \"ES256\";\n                        break;\n                    case \"P-384\":\n                        alg = \"ES384\";\n                        break;\n                    case \"P-521\":\n                        alg = \"ES512\";\n                        break;\n                    default:\n                        break;\n                }\n            }\n            if (crv === \"secp256k1\") {\n                use = \"sig\";\n                alg = \"ES256K\";\n            }\n            if (kty === \"OKP\") {\n                switch(crv){\n                    case \"Ed25519\":\n                    case \"Ed448\":\n                        use = \"sig\";\n                        alg = \"EdDSA\";\n                        break;\n                    case \"X25519\":\n                    case \"X448\":\n                        use = \"enc\";\n                        break;\n                    default:\n                        break;\n                }\n            }\n            if (alg && !use) {\n                switch(true){\n                    case alg.startsWith(\"ECDH\"):\n                        use = \"enc\";\n                        break;\n                    case alg.startsWith(\"RSA\"):\n                        use = \"enc\";\n                        break;\n                    default:\n                        break;\n                }\n            }\n            if (onlyPrivate && (jwk.kty === \"oct\" || !jwk.d)) {\n                throw new Error(\"jwks must only contain private keys\");\n            }\n            if (onlyPublic && (jwk.d || jwk.k)) {\n                continue;\n            }\n            keys.push({\n                jwk: {\n                    ...jwk,\n                    alg,\n                    use\n                },\n                async keyObject (alg) {\n                    if (this[alg]) {\n                        return this[alg];\n                    }\n                    const keyObject = await jose.importJWK(this.jwk, alg);\n                    this[alg] = keyObject;\n                    return keyObject;\n                },\n                get algorithms () {\n                    Object.defineProperty(this, \"algorithms\", {\n                        value: getAlgorithms(this.jwk.use, this.jwk.alg, this.jwk.kty, this.jwk.crv),\n                        enumerable: true,\n                        configurable: false\n                    });\n                    return this.algorithms;\n                }\n            });\n        }\n        return new this(internal, keys);\n    }\n    filter(...args) {\n        return this.#keys.filter(...args);\n    }\n    find(...args) {\n        return this.#keys.find(...args);\n    }\n    every(...args) {\n        return this.#keys.every(...args);\n    }\n    some(...args) {\n        return this.#keys.some(...args);\n    }\n    map(...args) {\n        return this.#keys.map(...args);\n    }\n    forEach(...args) {\n        return this.#keys.forEach(...args);\n    }\n    reduce(...args) {\n        return this.#keys.reduce(...args);\n    }\n    sort(...args) {\n        return this.#keys.sort(...args);\n    }\n    *[Symbol.iterator]() {\n        for (const key of this.#keys){\n            yield key;\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMva2V5c3RvcmUuanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU1BLE9BQU9DLG1CQUFPQSxDQUFDO0FBRXJCLE1BQU1DLFFBQVFELG1CQUFPQSxDQUFDO0FBQ3RCLE1BQU1FLGdCQUFnQkYsbUJBQU9BLENBQUM7QUFFOUIsTUFBTUcsV0FBV0M7QUFFakIsTUFBTUMsV0FBVyxDQUFDQyxLQUFLLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFO0lBQ2pDLElBQUlDLFFBQVE7SUFFWixJQUFJRixPQUFPRCxJQUFJQyxHQUFHLEVBQUU7UUFDbEJFO0lBQ0Y7SUFFQSxJQUFJRCxPQUFPRixJQUFJRSxHQUFHLEVBQUU7UUFDbEJDO0lBQ0Y7SUFFQSxPQUFPQTtBQUNUO0FBRUEsU0FBU0MsY0FBY0gsR0FBRztJQUN4QixPQUFRLE9BQU9BLFFBQVEsWUFBWUEsSUFBSUksS0FBSyxDQUFDLEdBQUc7UUFDOUMsS0FBSztRQUNMLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNUO1lBQ0UsT0FBT0M7SUFDWDtBQUNGO0FBRUEsU0FBU0MsY0FBY0wsR0FBRyxFQUFFRCxHQUFHLEVBQUVPLEdBQUcsRUFBRUMsR0FBRztJQUN2QyxrREFBa0Q7SUFDbEQsdUJBQXVCO0lBQ3ZCLElBQUlSLEtBQUs7UUFDUCxPQUFPLElBQUlTLElBQUk7WUFBQ1Q7U0FBSTtJQUN0QjtJQUVBLE9BQVFPO1FBQ04sS0FBSztZQUFNO2dCQUNULElBQUlHLE9BQU8sRUFBRTtnQkFFYixJQUFJVCxRQUFRLFNBQVNBLFFBQVFJLFdBQVc7b0JBQ3RDSyxPQUFPQSxLQUFLQyxNQUFNLENBQUM7d0JBQUM7d0JBQVc7d0JBQWtCO3dCQUFrQjtxQkFBaUI7Z0JBQ3RGO2dCQUVBLElBQUlWLFFBQVEsU0FBU0EsUUFBUUksV0FBVztvQkFDdEMsT0FBUUc7d0JBQ04sS0FBSzt3QkFD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LElBQUksQ0FBQzZDLE1BQU0sSUFBSXRCO0lBQzlCO0lBRUFKLEtBQUssR0FBR0ksSUFBSSxFQUFFO1FBQ1osT0FBTyxJQUFJLENBQUMsQ0FBQ3ZCLElBQUksQ0FBQ21CLElBQUksSUFBSUk7SUFDNUI7SUFFQSxDQUFDLENBQUMzQyxPQUFPa0UsUUFBUSxDQUFDLEdBQUc7UUFDbkIsS0FBSyxNQUFNaEUsT0FBTyxJQUFJLENBQUMsQ0FBQ2tCLElBQUksQ0FBRTtZQUM1QixNQUFNbEI7UUFDUjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lZHN1LWhvdXNlLXB1YmxpYy8uLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9rZXlzdG9yZS5qcz9hNTUzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGpvc2UgPSByZXF1aXJlKCdqb3NlJyk7XG5cbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi9kZWVwX2Nsb25lJyk7XG5jb25zdCBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi9pc19wbGFpbl9vYmplY3QnKTtcblxuY29uc3QgaW50ZXJuYWwgPSBTeW1ib2woKTtcblxuY29uc3Qga2V5c2NvcmUgPSAoa2V5LCB7IGFsZywgdXNlIH0pID0+IHtcbiAgbGV0IHNjb3JlID0gMDtcblxuICBpZiAoYWxnICYmIGtleS5hbGcpIHtcbiAgICBzY29yZSsrO1xuICB9XG5cbiAgaWYgKHVzZSAmJiBrZXkudXNlKSB7XG4gICAgc2NvcmUrKztcbiAgfVxuXG4gIHJldHVybiBzY29yZTtcbn07XG5cbmZ1bmN0aW9uIGdldEt0eUZyb21BbGcoYWxnKSB7XG4gIHN3aXRjaCAodHlwZW9mIGFsZyA9PT0gJ3N0cmluZycgJiYgYWxnLnNsaWNlKDAsIDIpKSB7XG4gICAgY2FzZSAnUlMnOlxuICAgIGNhc2UgJ1BTJzpcbiAgICAgIHJldHVybiAnUlNBJztcbiAgICBjYXNlICdFUyc6XG4gICAgICByZXR1cm4gJ0VDJztcbiAgICBjYXNlICdFZCc6XG4gICAgICByZXR1cm4gJ09LUCc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QWxnb3JpdGhtcyh1c2UsIGFsZywga3R5LCBjcnYpIHtcbiAgLy8gRWQyNTUxOSwgRWQ0NDgsIGFuZCBzZWNwMjU2azEgYWx3YXlzIGhhdmUgXCJhbGdcIlxuICAvLyBPS1AgYWx3YXlzIGhhcyBcInVzZVwiXG4gIGlmIChhbGcpIHtcbiAgICByZXR1cm4gbmV3IFNldChbYWxnXSk7XG4gIH1cblxuICBzd2l0Y2ggKGt0eSkge1xuICAgIGNhc2UgJ0VDJzoge1xuICAgICAgbGV0IGFsZ3MgPSBbXTtcblxuICAgICAgaWYgKHVzZSA9PT0gJ2VuYycgfHwgdXNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYWxncyA9IGFsZ3MuY29uY2F0KFsnRUNESC1FUycsICdFQ0RILUVTK0ExMjhLVycsICdFQ0RILUVTK0ExOTJLVycsICdFQ0RILUVTK0EyNTZLVyddKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHVzZSA9PT0gJ3NpZycgfHwgdXNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3dpdGNoIChjcnYpIHtcbiAgICAgICAgICBjYXNlICdQLTI1Nic6XG4gICAgICAgICAgY2FzZSAnUC0zODQnOlxuICAgICAgICAgICAgYWxncyA9IGFsZ3MuY29uY2F0KFtgRVMke2Nydi5zbGljZSgtMyl9YF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnUC01MjEnOlxuICAgICAgICAgICAgYWxncyA9IGFsZ3MuY29uY2F0KFsnRVM1MTInXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzZWNwMjU2azEnOlxuICAgICAgICAgICAgaWYgKGpvc2UuY3J5cHRvUnVudGltZSA9PT0gJ25vZGU6Y3J5cHRvJykge1xuICAgICAgICAgICAgICBhbGdzID0gYWxncy5jb25jYXQoWydFUzI1NksnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFNldChhbGdzKTtcbiAgICB9XG4gICAgY2FzZSAnT0tQJzoge1xuICAgICAgcmV0dXJuIG5ldyBTZXQoWydFQ0RILUVTJywgJ0VDREgtRVMrQTEyOEtXJywgJ0VDREgtRVMrQTE5MktXJywgJ0VDREgtRVMrQTI1NktXJ10pO1xuICAgIH1cbiAgICBjYXNlICdSU0EnOiB7XG4gICAgICBsZXQgYWxncyA9IFtdO1xuXG4gICAgICBpZiAodXNlID09PSAnZW5jJyB8fCB1c2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhbGdzID0gYWxncy5jb25jYXQoWydSU0EtT0FFUCcsICdSU0EtT0FFUC0yNTYnLCAnUlNBLU9BRVAtMzg0JywgJ1JTQS1PQUVQLTUxMiddKTtcbiAgICAgICAgaWYgKGpvc2UuY3J5cHRvUnVudGltZSA9PT0gJ25vZGU6Y3J5cHRvJykge1xuICAgICAgICAgIGFsZ3MgPSBhbGdzLmNvbmNhdChbJ1JTQTFfNSddKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodXNlID09PSAnc2lnJyB8fCB1c2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhbGdzID0gYWxncy5jb25jYXQoWydQUzI1NicsICdQUzM4NCcsICdQUzUxMicsICdSUzI1NicsICdSUzM4NCcsICdSUzUxMiddKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBTZXQoYWxncyk7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlJyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBLZXlTdG9yZSB7XG4gICNrZXlzO1xuXG4gIGNvbnN0cnVjdG9yKGksIGtleXMpIHtcbiAgICBpZiAoaSAhPT0gaW50ZXJuYWwpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBjb25zdHJ1Y3RvciBjYWxsJyk7XG4gICAgdGhpcy4ja2V5cyA9IGtleXM7XG4gIH1cblxuICB0b0pXS1MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleXM6IHRoaXMubWFwKCh7IGp3azogeyBkLCBwLCBxLCBkcCwgZHEsIHFpLCAuLi5qd2sgfSB9KSA9PiBqd2spLFxuICAgIH07XG4gIH1cblxuICBhbGwoeyBhbGcsIGtpZCwgdXNlIH0gPSB7fSkge1xuICAgIGlmICghdXNlIHx8ICFhbGcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH1cblxuICAgIGNvbnN0IGt0eSA9IGdldEt0eUZyb21BbGcoYWxnKTtcblxuICAgIGNvbnN0IHNlYXJjaCA9IHsgYWxnLCB1c2UgfTtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIoKGtleSkgPT4ge1xuICAgICAgbGV0IGNhbmRpZGF0ZSA9IHRydWU7XG5cbiAgICAgIGlmIChjYW5kaWRhdGUgJiYga3R5ICE9PSB1bmRlZmluZWQgJiYga2V5Lmp3ay5rdHkgIT09IGt0eSkge1xuICAgICAgICBjYW5kaWRhdGUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbmRpZGF0ZSAmJiBraWQgIT09IHVuZGVmaW5lZCAmJiBrZXkuandrLmtpZCAhPT0ga2lkKSB7XG4gICAgICAgIGNhbmRpZGF0ZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FuZGlkYXRlICYmIHVzZSAhPT0gdW5kZWZpbmVkICYmIGtleS5qd2sudXNlICE9PSB1bmRlZmluZWQgJiYga2V5Lmp3ay51c2UgIT09IHVzZSkge1xuICAgICAgICBjYW5kaWRhdGUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbmRpZGF0ZSAmJiBrZXkuandrLmFsZyAmJiBrZXkuandrLmFsZyAhPT0gYWxnKSB7XG4gICAgICAgIGNhbmRpZGF0ZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICgha2V5LmFsZ29yaXRobXMuaGFzKGFsZykpIHtcbiAgICAgICAgY2FuZGlkYXRlID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYW5kaWRhdGU7XG4gICAgfSkuc29ydCgoZmlyc3QsIHNlY29uZCkgPT4ga2V5c2NvcmUoc2Vjb25kLCBzZWFyY2gpIC0ga2V5c2NvcmUoZmlyc3QsIHNlYXJjaCkpO1xuICB9XG5cbiAgZ2V0KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5hbGwoLi4uYXJncylbMF07XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgZnJvbUpXS1MoandrcywgeyBvbmx5UHVibGljID0gZmFsc2UsIG9ubHlQcml2YXRlID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgaWYgKFxuICAgICAgIWlzUGxhaW5PYmplY3QoandrcykgfHxcbiAgICAgICFBcnJheS5pc0FycmF5KGp3a3Mua2V5cykgfHxcbiAgICAgIGp3a3Mua2V5cy5zb21lKChrKSA9PiAhaXNQbGFpbk9iamVjdChrKSB8fCAhKCdrdHknIGluIGspKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignandrcyBtdXN0IGJlIGEgSlNPTiBXZWIgS2V5IFNldCBmb3JtYXR0ZWQgb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5cyA9IFtdO1xuXG4gICAgZm9yIChsZXQgandrIG9mIGp3a3Mua2V5cykge1xuICAgICAgandrID0gY2xvbmUoandrKTtcbiAgICAgIGNvbnN0IHsga3R5LCBraWQsIGNydiB9ID0gandrO1xuXG4gICAgICBsZXQgeyBhbGcsIHVzZSB9ID0gandrO1xuXG4gICAgICBpZiAodHlwZW9mIGt0eSAhPT0gJ3N0cmluZycgfHwgIWt0eSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHVzZSAhPT0gdW5kZWZpbmVkICYmIHVzZSAhPT0gJ3NpZycgJiYgdXNlICE9PSAnZW5jJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBhbGcgIT09ICdzdHJpbmcnICYmIGFsZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGtpZCAhPT0gJ3N0cmluZycgJiYga2lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChrdHkgPT09ICdFQycgJiYgdXNlID09PSAnc2lnJykge1xuICAgICAgICBzd2l0Y2ggKGNydikge1xuICAgICAgICAgIGNhc2UgJ1AtMjU2JzpcbiAgICAgICAgICAgIGFsZyA9ICdFUzI1Nic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdQLTM4NCc6XG4gICAgICAgICAgICBhbGcgPSAnRVMzODQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnUC01MjEnOlxuICAgICAgICAgICAgYWxnID0gJ0VTNTEyJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY3J2ID09PSAnc2VjcDI1NmsxJykge1xuICAgICAgICB1c2UgPSAnc2lnJztcbiAgICAgICAgYWxnID0gJ0VTMjU2Syc7XG4gICAgICB9XG5cbiAgICAgIGlmIChrdHkgPT09ICdPS1AnKSB7XG4gICAgICAgIHN3aXRjaCAoY3J2KSB7XG4gICAgICAgICAgY2FzZSAnRWQyNTUxOSc6XG4gICAgICAgICAgY2FzZSAnRWQ0NDgnOlxuICAgICAgICAgICAgdXNlID0gJ3NpZyc7XG4gICAgICAgICAgICBhbGcgPSAnRWREU0EnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnWDI1NTE5JzpcbiAgICAgICAgICBjYXNlICdYNDQ4JzpcbiAgICAgICAgICAgIHVzZSA9ICdlbmMnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhbGcgJiYgIXVzZSkge1xuICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICBjYXNlIGFsZy5zdGFydHNXaXRoKCdFQ0RIJyk6XG4gICAgICAgICAgICB1c2UgPSAnZW5jJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgYWxnLnN0YXJ0c1dpdGgoJ1JTQScpOlxuICAgICAgICAgICAgdXNlID0gJ2VuYyc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9ubHlQcml2YXRlICYmIChqd2sua3R5ID09PSAnb2N0JyB8fCAhandrLmQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignandrcyBtdXN0IG9ubHkgY29udGFpbiBwcml2YXRlIGtleXMnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9ubHlQdWJsaWMgJiYgKGp3ay5kIHx8IGp3ay5rKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgandrOiB7IC4uLmp3aywgYWxnLCB1c2UgfSxcbiAgICAgICAgYXN5bmMga2V5T2JqZWN0KGFsZykge1xuICAgICAgICAgIGlmICh0aGlzW2FsZ10pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW2FsZ107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qga2V5T2JqZWN0ID0gYXdhaXQgam9zZS5pbXBvcnRKV0sodGhpcy5qd2ssIGFsZyk7XG4gICAgICAgICAgdGhpc1thbGddID0ga2V5T2JqZWN0O1xuICAgICAgICAgIHJldHVybiBrZXlPYmplY3Q7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBhbGdvcml0aG1zKCkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYWxnb3JpdGhtcycsIHtcbiAgICAgICAgICAgIHZhbHVlOiBnZXRBbGdvcml0aG1zKHRoaXMuandrLnVzZSwgdGhpcy5qd2suYWxnLCB0aGlzLmp3ay5rdHksIHRoaXMuandrLmNydiksXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hbGdvcml0aG1zO1xuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyB0aGlzKGludGVybmFsLCBrZXlzKTtcbiAgfVxuXG4gIGZpbHRlciguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuI2tleXMuZmlsdGVyKC4uLmFyZ3MpO1xuICB9XG5cbiAgZmluZCguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuI2tleXMuZmluZCguLi5hcmdzKTtcbiAgfVxuXG4gIGV2ZXJ5KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy4ja2V5cy5ldmVyeSguLi5hcmdzKTtcbiAgfVxuXG4gIHNvbWUoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLiNrZXlzLnNvbWUoLi4uYXJncyk7XG4gIH1cblxuICBtYXAoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLiNrZXlzLm1hcCguLi5hcmdzKTtcbiAgfVxuXG4gIGZvckVhY2goLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLiNrZXlzLmZvckVhY2goLi4uYXJncyk7XG4gIH1cblxuICByZWR1Y2UoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLiNrZXlzLnJlZHVjZSguLi5hcmdzKTtcbiAgfVxuXG4gIHNvcnQoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLiNrZXlzLnNvcnQoLi4uYXJncyk7XG4gIH1cblxuICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy4ja2V5cykge1xuICAgICAgeWllbGQga2V5O1xuICAgIH1cbiAgfVxufTtcbiJdLCJuYW1lcyI6WyJqb3NlIiwicmVxdWlyZSIsImNsb25lIiwiaXNQbGFpbk9iamVjdCIsImludGVybmFsIiwiU3ltYm9sIiwia2V5c2NvcmUiLCJrZXkiLCJhbGciLCJ1c2UiLCJzY29yZSIsImdldEt0eUZyb21BbGciLCJzbGljZSIsInVuZGVmaW5lZCIsImdldEFsZ29yaXRobXMiLCJrdHkiLCJjcnYiLCJTZXQiLCJhbGdzIiwiY29uY2F0IiwiY3J5cHRvUnVudGltZSIsIkVycm9yIiwibW9kdWxlIiwiZXhwb3J0cyIsIktleVN0b3JlIiwia2V5cyIsImNvbnN0cnVjdG9yIiwiaSIsInRvSldLUyIsIm1hcCIsImp3ayIsImQiLCJwIiwicSIsImRwIiwiZHEiLCJxaSIsImFsbCIsImtpZCIsInNlYXJjaCIsImZpbHRlciIsImNhbmRpZGF0ZSIsImFsZ29yaXRobXMiLCJoYXMiLCJzb3J0IiwiZmlyc3QiLCJzZWNvbmQiLCJnZXQiLCJhcmdzIiwiZnJvbUpXS1MiLCJqd2tzIiwib25seVB1YmxpYyIsIm9ubHlQcml2YXRlIiwiQXJyYXkiLCJpc0FycmF5Iiwic29tZSIsImsiLCJUeXBlRXJyb3IiLCJzdGFydHNXaXRoIiwicHVzaCIsImtleU9iamVjdCIsImltcG9ydEpXSyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwiZmluZCIsImV2ZXJ5IiwiZm9yRWFjaCIsInJlZHVjZSIsIml0ZXJhdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/keystore.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/merge.js":
/*!**********************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/merge.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst isPlainObject = __webpack_require__(/*! ./is_plain_object */ \"(rsc)/../node_modules/openid-client/lib/helpers/is_plain_object.js\");\nfunction merge(target, ...sources) {\n    for (const source of sources){\n        if (!isPlainObject(source)) {\n            continue;\n        }\n        for (const [key, value] of Object.entries(source)){\n            /* istanbul ignore if */ if (key === \"__proto__\" || key === \"constructor\") {\n                continue;\n            }\n            if (isPlainObject(target[key]) && isPlainObject(value)) {\n                target[key] = merge(target[key], value);\n            } else if (typeof value !== \"undefined\") {\n                target[key] = value;\n            }\n        }\n    }\n    return target;\n}\nmodule.exports = merge;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvbWVyZ2UuanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU1BLGdCQUFnQkMsbUJBQU9BLENBQUM7QUFFOUIsU0FBU0MsTUFBTUMsTUFBTSxFQUFFLEdBQUdDLE9BQU87SUFDL0IsS0FBSyxNQUFNQyxVQUFVRCxRQUFTO1FBQzVCLElBQUksQ0FBQ0osY0FBY0ssU0FBUztZQUMxQjtRQUNGO1FBQ0EsS0FBSyxNQUFNLENBQUNDLEtBQUtDLE1BQU0sSUFBSUMsT0FBT0MsT0FBTyxDQUFDSixRQUFTO1lBQ2pELHNCQUFzQixHQUN0QixJQUFJQyxRQUFRLGVBQWVBLFFBQVEsZUFBZTtnQkFDaEQ7WUFDRjtZQUNBLElBQUlOLGNBQWNHLE1BQU0sQ0FBQ0csSUFBSSxLQUFLTixjQUFjTyxRQUFRO2dCQUN0REosTUFBTSxDQUFDRyxJQUFJLEdBQUdKLE1BQU1DLE1BQU0sQ0FBQ0csSUFBSSxFQUFFQztZQUNuQyxPQUFPLElBQUksT0FBT0EsVUFBVSxhQUFhO2dCQUN2Q0osTUFBTSxDQUFDRyxJQUFJLEdBQUdDO1lBQ2hCO1FBQ0Y7SUFDRjtJQUVBLE9BQU9KO0FBQ1Q7QUFFQU8sT0FBT0MsT0FBTyxHQUFHVCIsInNvdXJjZXMiOlsid2VicGFjazovL2Vkc3UtaG91c2UtcHVibGljLy4uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL21lcmdlLmpzPzcwOGEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vaXNfcGxhaW5fb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgLi4uc291cmNlcykge1xuICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzb3VyY2UpKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nIHx8IGtleSA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KHRhcmdldFtrZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IG1lcmdlKHRhcmdldFtrZXldLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lcmdlO1xuIl0sIm5hbWVzIjpbImlzUGxhaW5PYmplY3QiLCJyZXF1aXJlIiwibWVyZ2UiLCJ0YXJnZXQiLCJzb3VyY2VzIiwic291cmNlIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJlbnRyaWVzIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/merge.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/pick.js":
/*!*********************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/pick.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("\nmodule.exports = function pick(object, ...paths) {\n    const obj = {};\n    for (const path of paths){\n        if (object[path] !== undefined) {\n            obj[path] = object[path];\n        }\n    }\n    return obj;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvcGljay5qcyIsIm1hcHBpbmdzIjoiO0FBQUFBLE9BQU9DLE9BQU8sR0FBRyxTQUFTQyxLQUFLQyxNQUFNLEVBQUUsR0FBR0MsS0FBSztJQUM3QyxNQUFNQyxNQUFNLENBQUM7SUFDYixLQUFLLE1BQU1DLFFBQVFGLE1BQU87UUFDeEIsSUFBSUQsTUFBTSxDQUFDRyxLQUFLLEtBQUtDLFdBQVc7WUFDOUJGLEdBQUcsQ0FBQ0MsS0FBSyxHQUFHSCxNQUFNLENBQUNHLEtBQUs7UUFDMUI7SUFDRjtJQUNBLE9BQU9EO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lZHN1LWhvdXNlLXB1YmxpYy8uLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9waWNrLmpzP2YwYWUiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwaWNrKG9iamVjdCwgLi4ucGF0aHMpIHtcbiAgY29uc3Qgb2JqID0ge307XG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIGlmIChvYmplY3RbcGF0aF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgb2JqW3BhdGhdID0gb2JqZWN0W3BhdGhdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqO1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicGljayIsIm9iamVjdCIsInBhdGhzIiwib2JqIiwicGF0aCIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/pick.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/process_response.js":
/*!*********************************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/process_response.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { STATUS_CODES } = __webpack_require__(/*! http */ \"http\");\nconst { format } = __webpack_require__(/*! util */ \"util\");\nconst { OPError } = __webpack_require__(/*! ../errors */ \"(rsc)/../node_modules/openid-client/lib/errors.js\");\nconst parseWwwAuthenticate = __webpack_require__(/*! ./www_authenticate_parser */ \"(rsc)/../node_modules/openid-client/lib/helpers/www_authenticate_parser.js\");\nconst throwAuthenticateErrors = (response)=>{\n    const params = parseWwwAuthenticate(response.headers[\"www-authenticate\"]);\n    if (params.error) {\n        throw new OPError(params, response);\n    }\n};\nconst isStandardBodyError = (response)=>{\n    let result = false;\n    try {\n        let jsonbody;\n        if (typeof response.body !== \"object\" || Buffer.isBuffer(response.body)) {\n            jsonbody = JSON.parse(response.body);\n        } else {\n            jsonbody = response.body;\n        }\n        result = typeof jsonbody.error === \"string\" && jsonbody.error.length;\n        if (result) Object.defineProperty(response, \"body\", {\n            value: jsonbody,\n            configurable: true\n        });\n    } catch (err) {}\n    return result;\n};\nfunction processResponse(response, { statusCode = 200, body = true, bearer = false } = {}) {\n    if (response.statusCode !== statusCode) {\n        if (bearer) {\n            throwAuthenticateErrors(response);\n        }\n        if (isStandardBodyError(response)) {\n            throw new OPError(response.body, response);\n        }\n        throw new OPError({\n            error: format(\"expected %i %s, got: %i %s\", statusCode, STATUS_CODES[statusCode], response.statusCode, STATUS_CODES[response.statusCode])\n        }, response);\n    }\n    if (body && !response.body) {\n        throw new OPError({\n            error: format(\"expected %i %s with body but no body was returned\", statusCode, STATUS_CODES[statusCode])\n        }, response);\n    }\n    return response.body;\n}\nmodule.exports = processResponse;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvcHJvY2Vzc19yZXNwb25zZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxFQUFFQSxZQUFZLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDakMsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFFM0IsTUFBTSxFQUFFRSxPQUFPLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFDNUIsTUFBTUcsdUJBQXVCSCxtQkFBT0EsQ0FBQztBQUVyQyxNQUFNSSwwQkFBMEIsQ0FBQ0M7SUFDL0IsTUFBTUMsU0FBU0gscUJBQXFCRSxTQUFTRSxPQUFPLENBQUMsbUJBQW1CO0lBRXhFLElBQUlELE9BQU9FLEtBQUssRUFBRTtRQUNoQixNQUFNLElBQUlOLFFBQVFJLFFBQVFEO0lBQzVCO0FBQ0Y7QUFFQSxNQUFNSSxzQkFBc0IsQ0FBQ0o7SUFDM0IsSUFBSUssU0FBUztJQUNiLElBQUk7UUFDRixJQUFJQztRQUNKLElBQUksT0FBT04sU0FBU08sSUFBSSxLQUFLLFlBQVlDLE9BQU9DLFFBQVEsQ0FBQ1QsU0FBU08sSUFBSSxHQUFHO1lBQ3ZFRCxXQUFXSSxLQUFLQyxLQUFLLENBQUNYLFNBQVNPLElBQUk7UUFDckMsT0FBTztZQUNMRCxXQUFXTixTQUFTTyxJQUFJO1FBQzFCO1FBQ0FGLFNBQVMsT0FBT0MsU0FBU0gsS0FBSyxLQUFLLFlBQVlHLFNBQVNILEtBQUssQ0FBQ1MsTUFBTTtRQUNwRSxJQUFJUCxRQUFRUSxPQUFPQyxjQUFjLENBQUNkLFVBQVUsUUFBUTtZQUFFZSxPQUFPVDtZQUFVVSxjQUFjO1FBQUs7SUFDNUYsRUFBRSxPQUFPQyxLQUFLLENBQUM7SUFFZixPQUFPWjtBQUNUO0FBRUEsU0FBU2EsZ0JBQWdCbEIsUUFBUSxFQUFFLEVBQUVtQixhQUFhLEdBQUcsRUFBRVosT0FBTyxJQUFJLEVBQUVhLFNBQVMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3ZGLElBQUlwQixTQUFTbUIsVUFBVSxLQUFLQSxZQUFZO1FBQ3RDLElBQUlDLFFBQVE7WUFDVnJCLHdCQUF3QkM7UUFDMUI7UUFFQSxJQUFJSSxvQkFBb0JKLFdBQVc7WUFDakMsTUFBTSxJQUFJSCxRQUFRRyxTQUFTTyxJQUFJLEVBQUVQO1FBQ25DO1FBRUEsTUFBTSxJQUFJSCxRQUNSO1lBQ0VNLE9BQU9QLE9BQ0wsOEJBQ0F1QixZQUNBekIsWUFBWSxDQUFDeUIsV0FBVyxFQUN4Qm5CLFNBQVNtQixVQUFVLEVBQ25CekIsWUFBWSxDQUFDTSxTQUFTbUIsVUFBVSxDQUFDO1FBRXJDLEdBQ0FuQjtJQUVKO0lBRUEsSUFBSU8sUUFBUSxDQUFDUCxTQUFTTyxJQUFJLEVBQUU7UUFDMUIsTUFBTSxJQUFJVixRQUNSO1lBQ0VNLE9BQU9QLE9BQ0wscURBQ0F1QixZQUNBekIsWUFBWSxDQUFDeUIsV0FBVztRQUU1QixHQUNBbkI7SUFFSjtJQUVBLE9BQU9BLFNBQVNPLElBQUk7QUFDdEI7QUFFQWMsT0FBT0MsT0FBTyxHQUFHSiIsInNvdXJjZXMiOlsid2VicGFjazovL2Vkc3UtaG91c2UtcHVibGljLy4uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9oZWxwZXJzL3Byb2Nlc3NfcmVzcG9uc2UuanM/YzU3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IFNUQVRVU19DT0RFUyB9ID0gcmVxdWlyZSgnaHR0cCcpO1xuY29uc3QgeyBmb3JtYXQgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuY29uc3QgeyBPUEVycm9yIH0gPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IHBhcnNlV3d3QXV0aGVudGljYXRlID0gcmVxdWlyZSgnLi93d3dfYXV0aGVudGljYXRlX3BhcnNlcicpO1xuXG5jb25zdCB0aHJvd0F1dGhlbnRpY2F0ZUVycm9ycyA9IChyZXNwb25zZSkgPT4ge1xuICBjb25zdCBwYXJhbXMgPSBwYXJzZVd3d0F1dGhlbnRpY2F0ZShyZXNwb25zZS5oZWFkZXJzWyd3d3ctYXV0aGVudGljYXRlJ10pO1xuXG4gIGlmIChwYXJhbXMuZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgT1BFcnJvcihwYXJhbXMsIHJlc3BvbnNlKTtcbiAgfVxufTtcblxuY29uc3QgaXNTdGFuZGFyZEJvZHlFcnJvciA9IChyZXNwb25zZSkgPT4ge1xuICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgbGV0IGpzb25ib2R5O1xuICAgIGlmICh0eXBlb2YgcmVzcG9uc2UuYm9keSAhPT0gJ29iamVjdCcgfHwgQnVmZmVyLmlzQnVmZmVyKHJlc3BvbnNlLmJvZHkpKSB7XG4gICAgICBqc29uYm9keSA9IEpTT04ucGFyc2UocmVzcG9uc2UuYm9keSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGpzb25ib2R5ID0gcmVzcG9uc2UuYm9keTtcbiAgICB9XG4gICAgcmVzdWx0ID0gdHlwZW9mIGpzb25ib2R5LmVycm9yID09PSAnc3RyaW5nJyAmJiBqc29uYm9keS5lcnJvci5sZW5ndGg7XG4gICAgaWYgKHJlc3VsdCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3BvbnNlLCAnYm9keScsIHsgdmFsdWU6IGpzb25ib2R5LCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gIH0gY2F0Y2ggKGVycikge31cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gcHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlLCB7IHN0YXR1c0NvZGUgPSAyMDAsIGJvZHkgPSB0cnVlLCBiZWFyZXIgPSBmYWxzZSB9ID0ge30pIHtcbiAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgIT09IHN0YXR1c0NvZGUpIHtcbiAgICBpZiAoYmVhcmVyKSB7XG4gICAgICB0aHJvd0F1dGhlbnRpY2F0ZUVycm9ycyhyZXNwb25zZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzU3RhbmRhcmRCb2R5RXJyb3IocmVzcG9uc2UpKSB7XG4gICAgICB0aHJvdyBuZXcgT1BFcnJvcihyZXNwb25zZS5ib2R5LCByZXNwb25zZSk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IE9QRXJyb3IoXG4gICAgICB7XG4gICAgICAgIGVycm9yOiBmb3JtYXQoXG4gICAgICAgICAgJ2V4cGVjdGVkICVpICVzLCBnb3Q6ICVpICVzJyxcbiAgICAgICAgICBzdGF0dXNDb2RlLFxuICAgICAgICAgIFNUQVRVU19DT0RFU1tzdGF0dXNDb2RlXSxcbiAgICAgICAgICByZXNwb25zZS5zdGF0dXNDb2RlLFxuICAgICAgICAgIFNUQVRVU19DT0RFU1tyZXNwb25zZS5zdGF0dXNDb2RlXSxcbiAgICAgICAgKSxcbiAgICAgIH0sXG4gICAgICByZXNwb25zZSxcbiAgICApO1xuICB9XG5cbiAgaWYgKGJvZHkgJiYgIXJlc3BvbnNlLmJvZHkpIHtcbiAgICB0aHJvdyBuZXcgT1BFcnJvcihcbiAgICAgIHtcbiAgICAgICAgZXJyb3I6IGZvcm1hdChcbiAgICAgICAgICAnZXhwZWN0ZWQgJWkgJXMgd2l0aCBib2R5IGJ1dCBubyBib2R5IHdhcyByZXR1cm5lZCcsXG4gICAgICAgICAgc3RhdHVzQ29kZSxcbiAgICAgICAgICBTVEFUVVNfQ09ERVNbc3RhdHVzQ29kZV0sXG4gICAgICAgICksXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2UsXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiByZXNwb25zZS5ib2R5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3NSZXNwb25zZTtcbiJdLCJuYW1lcyI6WyJTVEFUVVNfQ09ERVMiLCJyZXF1aXJlIiwiZm9ybWF0IiwiT1BFcnJvciIsInBhcnNlV3d3QXV0aGVudGljYXRlIiwidGhyb3dBdXRoZW50aWNhdGVFcnJvcnMiLCJyZXNwb25zZSIsInBhcmFtcyIsImhlYWRlcnMiLCJlcnJvciIsImlzU3RhbmRhcmRCb2R5RXJyb3IiLCJyZXN1bHQiLCJqc29uYm9keSIsImJvZHkiLCJCdWZmZXIiLCJpc0J1ZmZlciIsIkpTT04iLCJwYXJzZSIsImxlbmd0aCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJjb25maWd1cmFibGUiLCJlcnIiLCJwcm9jZXNzUmVzcG9uc2UiLCJzdGF0dXNDb2RlIiwiYmVhcmVyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/process_response.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/request.js":
/*!************************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/request.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst { once } = __webpack_require__(/*! events */ \"events\");\nconst { URL } = __webpack_require__(/*! url */ \"url\");\nconst LRU = __webpack_require__(/*! lru-cache */ \"(rsc)/../node_modules/lru-cache/index.js\");\nconst pkg = __webpack_require__(/*! ../../package.json */ \"(rsc)/../node_modules/openid-client/package.json\");\nconst { RPError } = __webpack_require__(/*! ../errors */ \"(rsc)/../node_modules/openid-client/lib/errors.js\");\nconst pick = __webpack_require__(/*! ./pick */ \"(rsc)/../node_modules/openid-client/lib/helpers/pick.js\");\nconst { deep: defaultsDeep } = __webpack_require__(/*! ./defaults */ \"(rsc)/../node_modules/openid-client/lib/helpers/defaults.js\");\nconst { HTTP_OPTIONS } = __webpack_require__(/*! ./consts */ \"(rsc)/../node_modules/openid-client/lib/helpers/consts.js\");\nlet DEFAULT_HTTP_OPTIONS;\nconst NQCHAR = /^[\\x21\\x23-\\x5B\\x5D-\\x7E]+$/;\nconst allowed = [\n    \"agent\",\n    \"ca\",\n    \"cert\",\n    \"crl\",\n    \"headers\",\n    \"key\",\n    \"lookup\",\n    \"passphrase\",\n    \"pfx\",\n    \"timeout\"\n];\nconst setDefaults = (props, options)=>{\n    DEFAULT_HTTP_OPTIONS = defaultsDeep({}, props.length ? pick(options, ...props) : options, DEFAULT_HTTP_OPTIONS);\n};\nsetDefaults([], {\n    headers: {\n        \"User-Agent\": `${pkg.name}/${pkg.version} (${pkg.homepage})`,\n        \"Accept-Encoding\": \"identity\"\n    },\n    timeout: 3500\n});\nfunction send(req, body, contentType) {\n    if (contentType) {\n        req.removeHeader(\"content-type\");\n        req.setHeader(\"content-type\", contentType);\n    }\n    if (body) {\n        req.removeHeader(\"content-length\");\n        req.setHeader(\"content-length\", Buffer.byteLength(body));\n        req.write(body);\n    }\n    req.end();\n}\nconst nonces = new LRU({\n    max: 100\n});\nmodule.exports = async function request(options, { accessToken, mTLS = false, DPoP } = {}) {\n    let url;\n    try {\n        url = new URL(options.url);\n        delete options.url;\n        assert(/^(https?:)$/.test(url.protocol));\n    } catch (err) {\n        throw new TypeError(\"only valid absolute URLs can be requested\");\n    }\n    const optsFn = this[HTTP_OPTIONS];\n    let opts = options;\n    const nonceKey = `${url.origin}${url.pathname}`;\n    if (DPoP && \"dpopProof\" in this) {\n        opts.headers = opts.headers || {};\n        opts.headers.DPoP = await this.dpopProof({\n            htu: `${url.origin}${url.pathname}`,\n            htm: options.method || \"GET\",\n            nonce: nonces.get(nonceKey)\n        }, DPoP, accessToken);\n    }\n    let userOptions;\n    if (optsFn) {\n        userOptions = pick(optsFn.call(this, url, defaultsDeep({}, opts, DEFAULT_HTTP_OPTIONS)), ...allowed);\n    }\n    opts = defaultsDeep({}, userOptions, opts, DEFAULT_HTTP_OPTIONS);\n    if (mTLS && !opts.pfx && !(opts.key && opts.cert)) {\n        throw new TypeError(\"mutual-TLS certificate and key not set\");\n    }\n    if (opts.searchParams) {\n        for (const [key, value] of Object.entries(opts.searchParams)){\n            url.searchParams.delete(key);\n            url.searchParams.set(key, value);\n        }\n    }\n    let responseType;\n    let form;\n    let json;\n    let body;\n    ({ form, responseType, json, body, ...opts } = opts);\n    for (const [key, value] of Object.entries(opts.headers || {})){\n        if (value === undefined) {\n            delete opts.headers[key];\n        }\n    }\n    let response;\n    const req = (url.protocol === \"https:\" ? https.request : http.request)(url.href, opts);\n    return (async ()=>{\n        if (json) {\n            send(req, JSON.stringify(json), \"application/json\");\n        } else if (form) {\n            send(req, querystring.stringify(form), \"application/x-www-form-urlencoded\");\n        } else if (body) {\n            send(req, body);\n        } else {\n            send(req);\n        }\n        [response] = await Promise.race([\n            once(req, \"response\"),\n            once(req, \"timeout\")\n        ]);\n        // timeout reached\n        if (!response) {\n            req.destroy();\n            throw new RPError(`outgoing request timed out after ${opts.timeout}ms`);\n        }\n        const parts = [];\n        for await (const part of response){\n            parts.push(part);\n        }\n        if (parts.length) {\n            switch(responseType){\n                case \"json\":\n                    {\n                        Object.defineProperty(response, \"body\", {\n                            get () {\n                                let value = Buffer.concat(parts);\n                                try {\n                                    value = JSON.parse(value);\n                                } catch (err) {\n                                    Object.defineProperty(err, \"response\", {\n                                        value: response\n                                    });\n                                    throw err;\n                                } finally{\n                                    Object.defineProperty(response, \"body\", {\n                                        value,\n                                        configurable: true\n                                    });\n                                }\n                                return value;\n                            },\n                            configurable: true\n                        });\n                        break;\n                    }\n                case undefined:\n                case \"buffer\":\n                    {\n                        Object.defineProperty(response, \"body\", {\n                            get () {\n                                const value = Buffer.concat(parts);\n                                Object.defineProperty(response, \"body\", {\n                                    value,\n                                    configurable: true\n                                });\n                                return value;\n                            },\n                            configurable: true\n                        });\n                        break;\n                    }\n                default:\n                    throw new TypeError(\"unsupported responseType request option\");\n            }\n        }\n        return response;\n    })().catch((err)=>{\n        if (response) Object.defineProperty(err, \"response\", {\n            value: response\n        });\n        throw err;\n    }).finally(()=>{\n        const dpopNonce = response && response.headers[\"dpop-nonce\"];\n        if (dpopNonce && NQCHAR.test(dpopNonce)) {\n            nonces.set(nonceKey, dpopNonce);\n        }\n    });\n};\nmodule.exports.setDefaults = setDefaults.bind(undefined, allowed);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvcmVxdWVzdC5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDdkIsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUM7QUFDNUIsTUFBTUUsT0FBT0YsbUJBQU9BLENBQUM7QUFDckIsTUFBTUcsUUFBUUgsbUJBQU9BLENBQUM7QUFDdEIsTUFBTSxFQUFFSSxJQUFJLEVBQUUsR0FBR0osbUJBQU9BLENBQUM7QUFDekIsTUFBTSxFQUFFSyxHQUFHLEVBQUUsR0FBR0wsbUJBQU9BLENBQUM7QUFFeEIsTUFBTU0sTUFBTU4sbUJBQU9BLENBQUM7QUFFcEIsTUFBTU8sTUFBTVAsbUJBQU9BLENBQUM7QUFDcEIsTUFBTSxFQUFFUSxPQUFPLEVBQUUsR0FBR1IsbUJBQU9BLENBQUM7QUFFNUIsTUFBTVMsT0FBT1QsbUJBQU9BLENBQUM7QUFDckIsTUFBTSxFQUFFVSxNQUFNQyxZQUFZLEVBQUUsR0FBR1gsbUJBQU9BLENBQUM7QUFDdkMsTUFBTSxFQUFFWSxZQUFZLEVBQUUsR0FBR1osbUJBQU9BLENBQUM7QUFFakMsSUFBSWE7QUFDSixNQUFNQyxTQUFTO0FBRWYsTUFBTUMsVUFBVTtJQUNkO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFRCxNQUFNQyxjQUFjLENBQUNDLE9BQU9DO0lBQzFCTCx1QkFBdUJGLGFBQ3JCLENBQUMsR0FDRE0sTUFBTUUsTUFBTSxHQUFHVixLQUFLUyxZQUFZRCxTQUFTQyxTQUN6Q0w7QUFFSjtBQUVBRyxZQUFZLEVBQUUsRUFBRTtJQUNkSSxTQUFTO1FBQ1AsY0FBYyxDQUFDLEVBQUViLElBQUljLElBQUksQ0FBQyxDQUFDLEVBQUVkLElBQUllLE9BQU8sQ0FBQyxFQUFFLEVBQUVmLElBQUlnQixRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQzVELG1CQUFtQjtJQUNyQjtJQUNBQyxT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d0NBQUVUO3dDQUFPc0IsY0FBYztvQ0FBSztnQ0FDdEU7Z0NBQ0EsT0FBT3RCOzRCQUNUOzRCQUNBc0IsY0FBYzt3QkFDaEI7d0JBQ0E7b0JBQ0Y7Z0JBQ0EsS0FBS2Q7Z0JBQ0wsS0FBSztvQkFBVTt3QkFDYlAsT0FBT2tCLGNBQWMsQ0FBQ1YsVUFBVSxRQUFROzRCQUN0Q2hCO2dDQUNFLE1BQU1PLFFBQVFsQyxPQUFPc0QsTUFBTSxDQUFDSjtnQ0FDNUJmLE9BQU9rQixjQUFjLENBQUNWLFVBQVUsUUFBUTtvQ0FBRVQ7b0NBQU9zQixjQUFjO2dDQUFLO2dDQUNwRSxPQUFPdEI7NEJBQ1Q7NEJBQ0FzQixjQUFjO3dCQUNoQjt3QkFDQTtvQkFDRjtnQkFDQTtvQkFDRSxNQUFNLElBQUl4QyxVQUFVO1lBQ3hCO1FBQ0Y7UUFFQSxPQUFPMkI7SUFDVCxLQUNHYyxLQUFLLENBQUMsQ0FBQzFDO1FBQ04sSUFBSTRCLFVBQVVSLE9BQU9rQixjQUFjLENBQUN0QyxLQUFLLFlBQVk7WUFBRW1CLE9BQU9TO1FBQVM7UUFDdkUsTUFBTTVCO0lBQ1IsR0FDQzJDLE9BQU8sQ0FBQztRQUNQLE1BQU1DLFlBQVloQixZQUFZQSxTQUFTdEQsT0FBTyxDQUFDLGFBQWE7UUFDNUQsSUFBSXNFLGFBQWE1RSxPQUFPOEIsSUFBSSxDQUFDOEMsWUFBWTtZQUN2Q3ZELE9BQU9rQyxHQUFHLENBQUNuQixVQUFVd0M7UUFDdkI7SUFDRjtBQUNKO0FBRUFyRCwwQkFBMEIsR0FBR3JCLFlBQVkyRSxJQUFJLENBQUNsQixXQUFXMUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lZHN1LWhvdXNlLXB1YmxpYy8uLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy9yZXF1ZXN0LmpzPzJlYTEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5jb25zdCBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuY29uc3QgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xuY29uc3QgeyBvbmNlIH0gPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IHsgVVJMIH0gPSByZXF1aXJlKCd1cmwnKTtcblxuY29uc3QgTFJVID0gcmVxdWlyZSgnbHJ1LWNhY2hlJyk7XG5cbmNvbnN0IHBrZyA9IHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpO1xuY29uc3QgeyBSUEVycm9yIH0gPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcblxuY29uc3QgcGljayA9IHJlcXVpcmUoJy4vcGljaycpO1xuY29uc3QgeyBkZWVwOiBkZWZhdWx0c0RlZXAgfSA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcbmNvbnN0IHsgSFRUUF9PUFRJT05TIH0gPSByZXF1aXJlKCcuL2NvbnN0cycpO1xuXG5sZXQgREVGQVVMVF9IVFRQX09QVElPTlM7XG5jb25zdCBOUUNIQVIgPSAvXltcXHgyMVxceDIzLVxceDVCXFx4NUQtXFx4N0VdKyQvO1xuXG5jb25zdCBhbGxvd2VkID0gW1xuICAnYWdlbnQnLFxuICAnY2EnLFxuICAnY2VydCcsXG4gICdjcmwnLFxuICAnaGVhZGVycycsXG4gICdrZXknLFxuICAnbG9va3VwJyxcbiAgJ3Bhc3NwaHJhc2UnLFxuICAncGZ4JyxcbiAgJ3RpbWVvdXQnLFxuXTtcblxuY29uc3Qgc2V0RGVmYXVsdHMgPSAocHJvcHMsIG9wdGlvbnMpID0+IHtcbiAgREVGQVVMVF9IVFRQX09QVElPTlMgPSBkZWZhdWx0c0RlZXAoXG4gICAge30sXG4gICAgcHJvcHMubGVuZ3RoID8gcGljayhvcHRpb25zLCAuLi5wcm9wcykgOiBvcHRpb25zLFxuICAgIERFRkFVTFRfSFRUUF9PUFRJT05TLFxuICApO1xufTtcblxuc2V0RGVmYXVsdHMoW10sIHtcbiAgaGVhZGVyczoge1xuICAgICdVc2VyLUFnZW50JzogYCR7cGtnLm5hbWV9LyR7cGtnLnZlcnNpb259ICgke3BrZy5ob21lcGFnZX0pYCxcbiAgICAnQWNjZXB0LUVuY29kaW5nJzogJ2lkZW50aXR5JyxcbiAgfSxcbiAgdGltZW91dDogMzUwMCxcbn0pO1xuXG5mdW5jdGlvbiBzZW5kKHJlcSwgYm9keSwgY29udGVudFR5cGUpIHtcbiAgaWYgKGNvbnRlbnRUeXBlKSB7XG4gICAgcmVxLnJlbW92ZUhlYWRlcignY29udGVudC10eXBlJyk7XG4gICAgcmVxLnNldEhlYWRlcignY29udGVudC10eXBlJywgY29udGVudFR5cGUpO1xuICB9XG4gIGlmIChib2R5KSB7XG4gICAgcmVxLnJlbW92ZUhlYWRlcignY29udGVudC1sZW5ndGgnKTtcbiAgICByZXEuc2V0SGVhZGVyKCdjb250ZW50LWxlbmd0aCcsIEJ1ZmZlci5ieXRlTGVuZ3RoKGJvZHkpKTtcbiAgICByZXEud3JpdGUoYm9keSk7XG4gIH1cbiAgcmVxLmVuZCgpO1xufVxuXG5jb25zdCBub25jZXMgPSBuZXcgTFJVKHsgbWF4OiAxMDAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXN5bmMgZnVuY3Rpb24gcmVxdWVzdChvcHRpb25zLCB7IGFjY2Vzc1Rva2VuLCBtVExTID0gZmFsc2UsIERQb1AgfSA9IHt9KSB7XG4gIGxldCB1cmw7XG4gIHRyeSB7XG4gICAgdXJsID0gbmV3IFVSTChvcHRpb25zLnVybCk7XG4gICAgZGVsZXRlIG9wdGlvbnMudXJsO1xuICAgIGFzc2VydCgvXihodHRwcz86KSQvLnRlc3QodXJsLnByb3RvY29sKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29ubHkgdmFsaWQgYWJzb2x1dGUgVVJMcyBjYW4gYmUgcmVxdWVzdGVkJyk7XG4gIH1cbiAgY29uc3Qgb3B0c0ZuID0gdGhpc1tIVFRQX09QVElPTlNdO1xuICBsZXQgb3B0cyA9IG9wdGlvbnM7XG5cbiAgY29uc3Qgbm9uY2VLZXkgPSBgJHt1cmwub3JpZ2lufSR7dXJsLnBhdGhuYW1lfWA7XG4gIGlmIChEUG9QICYmICdkcG9wUHJvb2YnIGluIHRoaXMpIHtcbiAgICBvcHRzLmhlYWRlcnMgPSBvcHRzLmhlYWRlcnMgfHwge307XG4gICAgb3B0cy5oZWFkZXJzLkRQb1AgPSBhd2FpdCB0aGlzLmRwb3BQcm9vZihcbiAgICAgIHtcbiAgICAgICAgaHR1OiBgJHt1cmwub3JpZ2lufSR7dXJsLnBhdGhuYW1lfWAsXG4gICAgICAgIGh0bTogb3B0aW9ucy5tZXRob2QgfHwgJ0dFVCcsXG4gICAgICAgIG5vbmNlOiBub25jZXMuZ2V0KG5vbmNlS2V5KSxcbiAgICAgIH0sXG4gICAgICBEUG9QLFxuICAgICAgYWNjZXNzVG9rZW4sXG4gICAgKTtcbiAgfVxuXG4gIGxldCB1c2VyT3B0aW9ucztcbiAgaWYgKG9wdHNGbikge1xuICAgIHVzZXJPcHRpb25zID0gcGljayhcbiAgICAgIG9wdHNGbi5jYWxsKHRoaXMsIHVybCwgZGVmYXVsdHNEZWVwKHt9LCBvcHRzLCBERUZBVUxUX0hUVFBfT1BUSU9OUykpLFxuICAgICAgLi4uYWxsb3dlZCxcbiAgICApO1xuICB9XG4gIG9wdHMgPSBkZWZhdWx0c0RlZXAoe30sIHVzZXJPcHRpb25zLCBvcHRzLCBERUZBVUxUX0hUVFBfT1BUSU9OUyk7XG5cbiAgaWYgKG1UTFMgJiYgIW9wdHMucGZ4ICYmICEob3B0cy5rZXkgJiYgb3B0cy5jZXJ0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ211dHVhbC1UTFMgY2VydGlmaWNhdGUgYW5kIGtleSBub3Qgc2V0Jyk7XG4gIH1cblxuICBpZiAob3B0cy5zZWFyY2hQYXJhbXMpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvcHRzLnNlYXJjaFBhcmFtcykpIHtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKGtleSk7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBsZXQgcmVzcG9uc2VUeXBlO1xuICBsZXQgZm9ybTtcbiAgbGV0IGpzb247XG4gIGxldCBib2R5O1xuICAoeyBmb3JtLCByZXNwb25zZVR5cGUsIGpzb24sIGJvZHksIC4uLm9wdHMgfSA9IG9wdHMpO1xuXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdHMuaGVhZGVycyB8fCB7fSkpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVsZXRlIG9wdHMuaGVhZGVyc1trZXldO1xuICAgIH1cbiAgfVxuXG4gIGxldCByZXNwb25zZTtcbiAgY29uc3QgcmVxID0gKHVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyBodHRwcy5yZXF1ZXN0IDogaHR0cC5yZXF1ZXN0KSh1cmwuaHJlZiwgb3B0cyk7XG4gIHJldHVybiAoYXN5bmMgKCkgPT4ge1xuICAgIGlmIChqc29uKSB7XG4gICAgICBzZW5kKHJlcSwgSlNPTi5zdHJpbmdpZnkoanNvbiksICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgfSBlbHNlIGlmIChmb3JtKSB7XG4gICAgICBzZW5kKHJlcSwgcXVlcnlzdHJpbmcuc3RyaW5naWZ5KGZvcm0pLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyk7XG4gICAgfSBlbHNlIGlmIChib2R5KSB7XG4gICAgICBzZW5kKHJlcSwgYm9keSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbmQocmVxKTtcbiAgICB9XG5cbiAgICBbcmVzcG9uc2VdID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtvbmNlKHJlcSwgJ3Jlc3BvbnNlJyksIG9uY2UocmVxLCAndGltZW91dCcpXSk7XG5cbiAgICAvLyB0aW1lb3V0IHJlYWNoZWRcbiAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICByZXEuZGVzdHJveSgpO1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3IoYG91dGdvaW5nIHJlcXVlc3QgdGltZWQgb3V0IGFmdGVyICR7b3B0cy50aW1lb3V0fW1zYCk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFydHMgPSBbXTtcblxuICAgIGZvciBhd2FpdCAoY29uc3QgcGFydCBvZiByZXNwb25zZSkge1xuICAgICAgcGFydHMucHVzaChwYXJ0KTtcbiAgICB9XG5cbiAgICBpZiAocGFydHMubGVuZ3RoKSB7XG4gICAgICBzd2l0Y2ggKHJlc3BvbnNlVHlwZSkge1xuICAgICAgICBjYXNlICdqc29uJzoge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNwb25zZSwgJ2JvZHknLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgIGxldCB2YWx1ZSA9IEJ1ZmZlci5jb25jYXQocGFydHMpO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnIsICdyZXNwb25zZScsIHsgdmFsdWU6IHJlc3BvbnNlIH0pO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzcG9uc2UsICdib2R5JywgeyB2YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIGNhc2UgJ2J1ZmZlcic6IHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzcG9uc2UsICdib2R5Jywge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IEJ1ZmZlci5jb25jYXQocGFydHMpO1xuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzcG9uc2UsICdib2R5JywgeyB2YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW5zdXBwb3J0ZWQgcmVzcG9uc2VUeXBlIHJlcXVlc3Qgb3B0aW9uJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9KSgpXG4gICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGlmIChyZXNwb25zZSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVyciwgJ3Jlc3BvbnNlJywgeyB2YWx1ZTogcmVzcG9uc2UgfSk7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSlcbiAgICAuZmluYWxseSgoKSA9PiB7XG4gICAgICBjb25zdCBkcG9wTm9uY2UgPSByZXNwb25zZSAmJiByZXNwb25zZS5oZWFkZXJzWydkcG9wLW5vbmNlJ107XG4gICAgICBpZiAoZHBvcE5vbmNlICYmIE5RQ0hBUi50ZXN0KGRwb3BOb25jZSkpIHtcbiAgICAgICAgbm9uY2VzLnNldChub25jZUtleSwgZHBvcE5vbmNlKTtcbiAgICAgIH1cbiAgICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLnNldERlZmF1bHRzID0gc2V0RGVmYXVsdHMuYmluZCh1bmRlZmluZWQsIGFsbG93ZWQpO1xuIl0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJxdWVyeXN0cmluZyIsImh0dHAiLCJodHRwcyIsIm9uY2UiLCJVUkwiLCJMUlUiLCJwa2ciLCJSUEVycm9yIiwicGljayIsImRlZXAiLCJkZWZhdWx0c0RlZXAiLCJIVFRQX09QVElPTlMiLCJERUZBVUxUX0hUVFBfT1BUSU9OUyIsIk5RQ0hBUiIsImFsbG93ZWQiLCJzZXREZWZhdWx0cyIsInByb3BzIiwib3B0aW9ucyIsImxlbmd0aCIsImhlYWRlcnMiLCJuYW1lIiwidmVyc2lvbiIsImhvbWVwYWdlIiwidGltZW91dCIsInNlbmQiLCJyZXEiLCJib2R5IiwiY29udGVudFR5cGUiLCJyZW1vdmVIZWFkZXIiLCJzZXRIZWFkZXIiLCJCdWZmZXIiLCJieXRlTGVuZ3RoIiwid3JpdGUiLCJlbmQiLCJub25jZXMiLCJtYXgiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWVzdCIsImFjY2Vzc1Rva2VuIiwibVRMUyIsIkRQb1AiLCJ1cmwiLCJ0ZXN0IiwicHJvdG9jb2wiLCJlcnIiLCJUeXBlRXJyb3IiLCJvcHRzRm4iLCJvcHRzIiwibm9uY2VLZXkiLCJvcmlnaW4iLCJwYXRobmFtZSIsImRwb3BQcm9vZiIsImh0dSIsImh0bSIsIm1ldGhvZCIsIm5vbmNlIiwiZ2V0IiwidXNlck9wdGlvbnMiLCJjYWxsIiwicGZ4Iiwia2V5IiwiY2VydCIsInNlYXJjaFBhcmFtcyIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsImRlbGV0ZSIsInNldCIsInJlc3BvbnNlVHlwZSIsImZvcm0iLCJqc29uIiwidW5kZWZpbmVkIiwicmVzcG9uc2UiLCJocmVmIiwiSlNPTiIsInN0cmluZ2lmeSIsIlByb21pc2UiLCJyYWNlIiwiZGVzdHJveSIsInBhcnRzIiwicGFydCIsInB1c2giLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmNhdCIsInBhcnNlIiwiY29uZmlndXJhYmxlIiwiY2F0Y2giLCJmaW5hbGx5IiwiZHBvcE5vbmNlIiwiYmluZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/request.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/unix_timestamp.js":
/*!*******************************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/unix_timestamp.js ***!
  \*******************************************************************/
/***/ ((module) => {

eval("\nmodule.exports = ()=>Math.floor(Date.now() / 1000);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvdW5peF90aW1lc3RhbXAuanMiLCJtYXBwaW5ncyI6IjtBQUFBQSxPQUFPQyxPQUFPLEdBQUcsSUFBTUMsS0FBS0MsS0FBSyxDQUFDQyxLQUFLQyxHQUFHLEtBQUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lZHN1LWhvdXNlLXB1YmxpYy8uLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy91bml4X3RpbWVzdGFtcC5qcz9lYjQwIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gKCkgPT4gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIk1hdGgiLCJmbG9vciIsIkRhdGUiLCJub3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/unix_timestamp.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/weak_cache.js":
/*!***************************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/weak_cache.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\nmodule.exports.keystores = new WeakMap();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvd2Vha19jYWNoZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUFBLHdCQUF3QixHQUFHLElBQUlHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWRzdS1ob3VzZS1wdWJsaWMvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvd2Vha19jYWNoZS5qcz9hYjgxIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzLmtleXN0b3JlcyA9IG5ldyBXZWFrTWFwKCk7XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImtleXN0b3JlcyIsIldlYWtNYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/weak_cache.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/webfinger_normalize.js":
/*!************************************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/webfinger_normalize.js ***!
  \************************************************************************/
/***/ ((module) => {

eval("// Credit: https://github.com/rohe/pyoidc/blob/master/src/oic/utils/webfinger.py\n// -- Normalization --\n// A string of any other type is interpreted as a URI either the form of scheme\n// \"://\" authority path-abempty [ \"?\" query ] [ \"#\" fragment ] or authority\n// path-abempty [ \"?\" query ] [ \"#\" fragment ] per RFC 3986 [RFC3986] and is\n// normalized according to the following rules:\n//\n// If the user input Identifier does not have an RFC 3986 [RFC3986] scheme\n// portion, the string is interpreted as [userinfo \"@\"] host [\":\" port]\n// path-abempty [ \"?\" query ] [ \"#\" fragment ] per RFC 3986 [RFC3986].\n// If the userinfo component is present and all of the path component, query\n// component, and port component are empty, the acct scheme is assumed. In this\n// case, the normalized URI is formed by prefixing acct: to the string as the\n// scheme. Per the 'acct' URI Scheme [ID.ietfappsawgaccturi], if there is an\n// at-sign character ('@') in the userinfo component, it needs to be\n// percent-encoded as described in RFC 3986 [RFC3986].\n// For all other inputs without a scheme portion, the https scheme is assumed,\n// and the normalized URI is formed by prefixing https:// to the string as the\n// scheme.\n// If the resulting URI contains a fragment portion, it MUST be stripped off\n// together with the fragment delimiter character \"#\".\n// The WebFinger [ID.ietfappsawgwebfinger] Resource in this case is the\n// resulting URI, and the WebFinger Host is the authority component.\n//\n// Note: Since the definition of authority in RFC 3986 [RFC3986] is\n// [ userinfo \"@\" ] host [ \":\" port ], it is legal to have a user input\n// identifier like userinfo@host:port, e.g., alice@example.com:8080.\n\nconst PORT = /^\\d+$/;\nfunction hasScheme(input) {\n    if (input.includes(\"://\")) return true;\n    const authority = input.replace(/(\\/|\\?)/g, \"#\").split(\"#\")[0];\n    if (authority.includes(\":\")) {\n        const index = authority.indexOf(\":\");\n        const hostOrPort = authority.slice(index + 1);\n        if (!PORT.test(hostOrPort)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction acctSchemeAssumed(input) {\n    if (!input.includes(\"@\")) return false;\n    const parts = input.split(\"@\");\n    const host = parts[parts.length - 1];\n    return !(host.includes(\":\") || host.includes(\"/\") || host.includes(\"?\"));\n}\nfunction normalize(input) {\n    if (typeof input !== \"string\") {\n        throw new TypeError(\"input must be a string\");\n    }\n    let output;\n    if (hasScheme(input)) {\n        output = input;\n    } else if (acctSchemeAssumed(input)) {\n        output = `acct:${input}`;\n    } else {\n        output = `https://${input}`;\n    }\n    return output.split(\"#\")[0];\n}\nmodule.exports = normalize;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvd2ViZmluZ2VyX25vcm1hbGl6ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxnRkFBZ0Y7QUFFaEYsc0JBQXNCO0FBQ3RCLCtFQUErRTtBQUMvRSwyRUFBMkU7QUFDM0UsNEVBQTRFO0FBQzVFLCtDQUErQztBQUMvQyxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHVFQUF1RTtBQUN2RSxzRUFBc0U7QUFDdEUsNEVBQTRFO0FBQzVFLCtFQUErRTtBQUMvRSw2RUFBNkU7QUFDN0UsZ0ZBQWdGO0FBQ2hGLG9FQUFvRTtBQUNwRSxzREFBc0Q7QUFDdEQsOEVBQThFO0FBQzlFLDhFQUE4RTtBQUM5RSxVQUFVO0FBQ1YsNEVBQTRFO0FBQzVFLHNEQUFzRDtBQUN0RCwwRUFBMEU7QUFDMUUsb0VBQW9FO0FBQ3BFLEVBQUU7QUFDRixtRUFBbUU7QUFDbkUsdUVBQXVFO0FBQ3ZFLG9FQUFvRTs7QUFFcEUsTUFBTUEsT0FBTztBQUViLFNBQVNDLFVBQVVDLEtBQUs7SUFDdEIsSUFBSUEsTUFBTUMsUUFBUSxDQUFDLFFBQVEsT0FBTztJQUVsQyxNQUFNQyxZQUFZRixNQUFNRyxPQUFPLENBQUMsWUFBWSxLQUFLQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7SUFDOUQsSUFBSUYsVUFBVUQsUUFBUSxDQUFDLE1BQU07UUFDM0IsTUFBTUksUUFBUUgsVUFBVUksT0FBTyxDQUFDO1FBQ2hDLE1BQU1DLGFBQWFMLFVBQVVNLEtBQUssQ0FBQ0gsUUFBUTtRQUMzQyxJQUFJLENBQUNQLEtBQUtXLElBQUksQ0FBQ0YsYUFBYTtZQUMxQixPQUFPO1FBQ1Q7SUFDRjtJQUVBLE9BQU87QUFDVDtBQUVBLFNBQVNHLGtCQUFrQlYsS0FBSztJQUM5QixJQUFJLENBQUNBLE1BQU1DLFFBQVEsQ0FBQyxNQUFNLE9BQU87SUFDakMsTUFBTVUsUUFBUVgsTUFBTUksS0FBSyxDQUFDO0lBQzFCLE1BQU1RLE9BQU9ELEtBQUssQ0FBQ0EsTUFBTUUsTUFBTSxHQUFHLEVBQUU7SUFDcEMsT0FBTyxDQUFFRCxDQUFBQSxLQUFLWCxRQUFRLENBQUMsUUFBUVcsS0FBS1gsUUFBUSxDQUFDLFFBQVFXLEtBQUtYLFFBQVEsQ0FBQyxJQUFHO0FBQ3hFO0FBRUEsU0FBU2EsVUFBVWQsS0FBSztJQUN0QixJQUFJLE9BQU9BLFVBQVUsVUFBVTtRQUM3QixNQUFNLElBQUllLFVBQVU7SUFDdEI7SUFFQSxJQUFJQztJQUNKLElBQUlqQixVQUFVQyxRQUFRO1FBQ3BCZ0IsU0FBU2hCO0lBQ1gsT0FBTyxJQUFJVSxrQkFBa0JWLFFBQVE7UUFDbkNnQixTQUFTLENBQUMsS0FBSyxFQUFFaEIsTUFBTSxDQUFDO0lBQzFCLE9BQU87UUFDTGdCLFNBQVMsQ0FBQyxRQUFRLEVBQUVoQixNQUFNLENBQUM7SUFDN0I7SUFFQSxPQUFPZ0IsT0FBT1osS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQzdCO0FBRUFhLE9BQU9DLE9BQU8sR0FBR0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lZHN1LWhvdXNlLXB1YmxpYy8uLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaGVscGVycy93ZWJmaW5nZXJfbm9ybWFsaXplLmpzPzhiNTQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ3JlZGl0OiBodHRwczovL2dpdGh1Yi5jb20vcm9oZS9weW9pZGMvYmxvYi9tYXN0ZXIvc3JjL29pYy91dGlscy93ZWJmaW5nZXIucHlcblxuLy8gLS0gTm9ybWFsaXphdGlvbiAtLVxuLy8gQSBzdHJpbmcgb2YgYW55IG90aGVyIHR5cGUgaXMgaW50ZXJwcmV0ZWQgYXMgYSBVUkkgZWl0aGVyIHRoZSBmb3JtIG9mIHNjaGVtZVxuLy8gXCI6Ly9cIiBhdXRob3JpdHkgcGF0aC1hYmVtcHR5IFsgXCI/XCIgcXVlcnkgXSBbIFwiI1wiIGZyYWdtZW50IF0gb3IgYXV0aG9yaXR5XG4vLyBwYXRoLWFiZW1wdHkgWyBcIj9cIiBxdWVyeSBdIFsgXCIjXCIgZnJhZ21lbnQgXSBwZXIgUkZDIDM5ODYgW1JGQzM5ODZdIGFuZCBpc1xuLy8gbm9ybWFsaXplZCBhY2NvcmRpbmcgdG8gdGhlIGZvbGxvd2luZyBydWxlczpcbi8vXG4vLyBJZiB0aGUgdXNlciBpbnB1dCBJZGVudGlmaWVyIGRvZXMgbm90IGhhdmUgYW4gUkZDIDM5ODYgW1JGQzM5ODZdIHNjaGVtZVxuLy8gcG9ydGlvbiwgdGhlIHN0cmluZyBpcyBpbnRlcnByZXRlZCBhcyBbdXNlcmluZm8gXCJAXCJdIGhvc3QgW1wiOlwiIHBvcnRdXG4vLyBwYXRoLWFiZW1wdHkgWyBcIj9cIiBxdWVyeSBdIFsgXCIjXCIgZnJhZ21lbnQgXSBwZXIgUkZDIDM5ODYgW1JGQzM5ODZdLlxuLy8gSWYgdGhlIHVzZXJpbmZvIGNvbXBvbmVudCBpcyBwcmVzZW50IGFuZCBhbGwgb2YgdGhlIHBhdGggY29tcG9uZW50LCBxdWVyeVxuLy8gY29tcG9uZW50LCBhbmQgcG9ydCBjb21wb25lbnQgYXJlIGVtcHR5LCB0aGUgYWNjdCBzY2hlbWUgaXMgYXNzdW1lZC4gSW4gdGhpc1xuLy8gY2FzZSwgdGhlIG5vcm1hbGl6ZWQgVVJJIGlzIGZvcm1lZCBieSBwcmVmaXhpbmcgYWNjdDogdG8gdGhlIHN0cmluZyBhcyB0aGVcbi8vIHNjaGVtZS4gUGVyIHRoZSAnYWNjdCcgVVJJIFNjaGVtZSBbSeKAkUQuaWV0ZuKAkWFwcHNhd2figJFhY2N04oCRdXJpXSwgaWYgdGhlcmUgaXMgYW5cbi8vIGF0LXNpZ24gY2hhcmFjdGVyICgnQCcpIGluIHRoZSB1c2VyaW5mbyBjb21wb25lbnQsIGl0IG5lZWRzIHRvIGJlXG4vLyBwZXJjZW50LWVuY29kZWQgYXMgZGVzY3JpYmVkIGluIFJGQyAzOTg2IFtSRkMzOTg2XS5cbi8vIEZvciBhbGwgb3RoZXIgaW5wdXRzIHdpdGhvdXQgYSBzY2hlbWUgcG9ydGlvbiwgdGhlIGh0dHBzIHNjaGVtZSBpcyBhc3N1bWVkLFxuLy8gYW5kIHRoZSBub3JtYWxpemVkIFVSSSBpcyBmb3JtZWQgYnkgcHJlZml4aW5nIGh0dHBzOi8vIHRvIHRoZSBzdHJpbmcgYXMgdGhlXG4vLyBzY2hlbWUuXG4vLyBJZiB0aGUgcmVzdWx0aW5nIFVSSSBjb250YWlucyBhIGZyYWdtZW50IHBvcnRpb24sIGl0IE1VU1QgYmUgc3RyaXBwZWQgb2ZmXG4vLyB0b2dldGhlciB3aXRoIHRoZSBmcmFnbWVudCBkZWxpbWl0ZXIgY2hhcmFjdGVyIFwiI1wiLlxuLy8gVGhlIFdlYkZpbmdlciBbSeKAkUQuaWV0ZuKAkWFwcHNhd2figJF3ZWJmaW5nZXJdIFJlc291cmNlIGluIHRoaXMgY2FzZSBpcyB0aGVcbi8vIHJlc3VsdGluZyBVUkksIGFuZCB0aGUgV2ViRmluZ2VyIEhvc3QgaXMgdGhlIGF1dGhvcml0eSBjb21wb25lbnQuXG4vL1xuLy8gTm90ZTogU2luY2UgdGhlIGRlZmluaXRpb24gb2YgYXV0aG9yaXR5IGluIFJGQyAzOTg2IFtSRkMzOTg2XSBpc1xuLy8gWyB1c2VyaW5mbyBcIkBcIiBdIGhvc3QgWyBcIjpcIiBwb3J0IF0sIGl0IGlzIGxlZ2FsIHRvIGhhdmUgYSB1c2VyIGlucHV0XG4vLyBpZGVudGlmaWVyIGxpa2UgdXNlcmluZm9AaG9zdDpwb3J0LCBlLmcuLCBhbGljZUBleGFtcGxlLmNvbTo4MDgwLlxuXG5jb25zdCBQT1JUID0gL15cXGQrJC87XG5cbmZ1bmN0aW9uIGhhc1NjaGVtZShpbnB1dCkge1xuICBpZiAoaW5wdXQuaW5jbHVkZXMoJzovLycpKSByZXR1cm4gdHJ1ZTtcblxuICBjb25zdCBhdXRob3JpdHkgPSBpbnB1dC5yZXBsYWNlKC8oXFwvfFxcPykvZywgJyMnKS5zcGxpdCgnIycpWzBdO1xuICBpZiAoYXV0aG9yaXR5LmluY2x1ZGVzKCc6JykpIHtcbiAgICBjb25zdCBpbmRleCA9IGF1dGhvcml0eS5pbmRleE9mKCc6Jyk7XG4gICAgY29uc3QgaG9zdE9yUG9ydCA9IGF1dGhvcml0eS5zbGljZShpbmRleCArIDEpO1xuICAgIGlmICghUE9SVC50ZXN0KGhvc3RPclBvcnQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFjY3RTY2hlbWVBc3N1bWVkKGlucHV0KSB7XG4gIGlmICghaW5wdXQuaW5jbHVkZXMoJ0AnKSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBwYXJ0cyA9IGlucHV0LnNwbGl0KCdAJyk7XG4gIGNvbnN0IGhvc3QgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuICEoaG9zdC5pbmNsdWRlcygnOicpIHx8IGhvc3QuaW5jbHVkZXMoJy8nKSB8fCBob3N0LmluY2x1ZGVzKCc/JykpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemUoaW5wdXQpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnB1dCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICBsZXQgb3V0cHV0O1xuICBpZiAoaGFzU2NoZW1lKGlucHV0KSkge1xuICAgIG91dHB1dCA9IGlucHV0O1xuICB9IGVsc2UgaWYgKGFjY3RTY2hlbWVBc3N1bWVkKGlucHV0KSkge1xuICAgIG91dHB1dCA9IGBhY2N0OiR7aW5wdXR9YDtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBgaHR0cHM6Ly8ke2lucHV0fWA7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0LnNwbGl0KCcjJylbMF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbm9ybWFsaXplO1xuIl0sIm5hbWVzIjpbIlBPUlQiLCJoYXNTY2hlbWUiLCJpbnB1dCIsImluY2x1ZGVzIiwiYXV0aG9yaXR5IiwicmVwbGFjZSIsInNwbGl0IiwiaW5kZXgiLCJpbmRleE9mIiwiaG9zdE9yUG9ydCIsInNsaWNlIiwidGVzdCIsImFjY3RTY2hlbWVBc3N1bWVkIiwicGFydHMiLCJob3N0IiwibGVuZ3RoIiwibm9ybWFsaXplIiwiVHlwZUVycm9yIiwib3V0cHV0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/webfinger_normalize.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/helpers/www_authenticate_parser.js":
/*!****************************************************************************!*\
  !*** ../node_modules/openid-client/lib/helpers/www_authenticate_parser.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("\nconst REGEXP = /(\\w+)=(\"[^\"]*\")/g;\nmodule.exports = (wwwAuthenticate)=>{\n    const params = {};\n    try {\n        while(REGEXP.exec(wwwAuthenticate) !== null){\n            if (RegExp.$1 && RegExp.$2) {\n                params[RegExp.$1] = RegExp.$2.slice(1, -1);\n            }\n        }\n    } catch (err) {}\n    return params;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvd3d3X2F1dGhlbnRpY2F0ZV9wYXJzZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU1BLFNBQVM7QUFFZkMsT0FBT0MsT0FBTyxHQUFHLENBQUNDO0lBQ2hCLE1BQU1DLFNBQVMsQ0FBQztJQUNoQixJQUFJO1FBQ0YsTUFBT0osT0FBT0ssSUFBSSxDQUFDRixxQkFBcUIsS0FBTTtZQUM1QyxJQUFJRyxPQUFPQyxFQUFFLElBQUlELE9BQU9FLEVBQUUsRUFBRTtnQkFDMUJKLE1BQU0sQ0FBQ0UsT0FBT0MsRUFBRSxDQUFDLEdBQUdELE9BQU9FLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDLEdBQUcsQ0FBQztZQUMxQztRQUNGO0lBQ0YsRUFBRSxPQUFPQyxLQUFLLENBQUM7SUFFZixPQUFPTjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWRzdS1ob3VzZS1wdWJsaWMvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2hlbHBlcnMvd3d3X2F1dGhlbnRpY2F0ZV9wYXJzZXIuanM/Yzc5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBSRUdFWFAgPSAvKFxcdyspPShcIlteXCJdKlwiKS9nO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICh3d3dBdXRoZW50aWNhdGUpID0+IHtcbiAgY29uc3QgcGFyYW1zID0ge307XG4gIHRyeSB7XG4gICAgd2hpbGUgKFJFR0VYUC5leGVjKHd3d0F1dGhlbnRpY2F0ZSkgIT09IG51bGwpIHtcbiAgICAgIGlmIChSZWdFeHAuJDEgJiYgUmVnRXhwLiQyKSB7XG4gICAgICAgIHBhcmFtc1tSZWdFeHAuJDFdID0gUmVnRXhwLiQyLnNsaWNlKDEsIC0xKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge31cblxuICByZXR1cm4gcGFyYW1zO1xufTtcbiJdLCJuYW1lcyI6WyJSRUdFWFAiLCJtb2R1bGUiLCJleHBvcnRzIiwid3d3QXV0aGVudGljYXRlIiwicGFyYW1zIiwiZXhlYyIsIlJlZ0V4cCIsIiQxIiwiJDIiLCJzbGljZSIsImVyciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/helpers/www_authenticate_parser.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/index.js":
/*!**************************************************!*\
  !*** ../node_modules/openid-client/lib/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Issuer = __webpack_require__(/*! ./issuer */ \"(rsc)/../node_modules/openid-client/lib/issuer.js\");\nconst { OPError, RPError } = __webpack_require__(/*! ./errors */ \"(rsc)/../node_modules/openid-client/lib/errors.js\");\nconst Strategy = __webpack_require__(/*! ./passport_strategy */ \"(rsc)/../node_modules/openid-client/lib/passport_strategy.js\");\nconst TokenSet = __webpack_require__(/*! ./token_set */ \"(rsc)/../node_modules/openid-client/lib/token_set.js\");\nconst { CLOCK_TOLERANCE, HTTP_OPTIONS } = __webpack_require__(/*! ./helpers/consts */ \"(rsc)/../node_modules/openid-client/lib/helpers/consts.js\");\nconst generators = __webpack_require__(/*! ./helpers/generators */ \"(rsc)/../node_modules/openid-client/lib/helpers/generators.js\");\nconst { setDefaults } = __webpack_require__(/*! ./helpers/request */ \"(rsc)/../node_modules/openid-client/lib/helpers/request.js\");\nmodule.exports = {\n    Issuer,\n    Strategy,\n    TokenSet,\n    errors: {\n        OPError,\n        RPError\n    },\n    custom: {\n        setHttpOptionsDefaults: setDefaults,\n        http_options: HTTP_OPTIONS,\n        clock_tolerance: CLOCK_TOLERANCE\n    },\n    generators\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUN2QixNQUFNLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFLEdBQUdGLG1CQUFPQSxDQUFDO0FBQ3JDLE1BQU1HLFdBQVdILG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU1JLFdBQVdKLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU0sRUFBRUssZUFBZSxFQUFFQyxZQUFZLEVBQUUsR0FBR04sbUJBQU9BLENBQUM7QUFDbEQsTUFBTU8sYUFBYVAsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFUSxXQUFXLEVBQUUsR0FBR1IsbUJBQU9BLENBQUM7QUFFaENTLE9BQU9DLE9BQU8sR0FBRztJQUNmWDtJQUNBSTtJQUNBQztJQUNBTyxRQUFRO1FBQ05WO1FBQ0FDO0lBQ0Y7SUFDQVUsUUFBUTtRQUNOQyx3QkFBd0JMO1FBQ3hCTSxjQUFjUjtRQUNkUyxpQkFBaUJWO0lBQ25CO0lBQ0FFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lZHN1LWhvdXNlLXB1YmxpYy8uLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvaW5kZXguanM/OWQyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBJc3N1ZXIgPSByZXF1aXJlKCcuL2lzc3VlcicpO1xuY29uc3QgeyBPUEVycm9yLCBSUEVycm9yIH0gPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgU3RyYXRlZ3kgPSByZXF1aXJlKCcuL3Bhc3Nwb3J0X3N0cmF0ZWd5Jyk7XG5jb25zdCBUb2tlblNldCA9IHJlcXVpcmUoJy4vdG9rZW5fc2V0Jyk7XG5jb25zdCB7IENMT0NLX1RPTEVSQU5DRSwgSFRUUF9PUFRJT05TIH0gPSByZXF1aXJlKCcuL2hlbHBlcnMvY29uc3RzJyk7XG5jb25zdCBnZW5lcmF0b3JzID0gcmVxdWlyZSgnLi9oZWxwZXJzL2dlbmVyYXRvcnMnKTtcbmNvbnN0IHsgc2V0RGVmYXVsdHMgfSA9IHJlcXVpcmUoJy4vaGVscGVycy9yZXF1ZXN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBJc3N1ZXIsXG4gIFN0cmF0ZWd5LFxuICBUb2tlblNldCxcbiAgZXJyb3JzOiB7XG4gICAgT1BFcnJvcixcbiAgICBSUEVycm9yLFxuICB9LFxuICBjdXN0b206IHtcbiAgICBzZXRIdHRwT3B0aW9uc0RlZmF1bHRzOiBzZXREZWZhdWx0cyxcbiAgICBodHRwX29wdGlvbnM6IEhUVFBfT1BUSU9OUyxcbiAgICBjbG9ja190b2xlcmFuY2U6IENMT0NLX1RPTEVSQU5DRSxcbiAgfSxcbiAgZ2VuZXJhdG9ycyxcbn07XG4iXSwibmFtZXMiOlsiSXNzdWVyIiwicmVxdWlyZSIsIk9QRXJyb3IiLCJSUEVycm9yIiwiU3RyYXRlZ3kiLCJUb2tlblNldCIsIkNMT0NLX1RPTEVSQU5DRSIsIkhUVFBfT1BUSU9OUyIsImdlbmVyYXRvcnMiLCJzZXREZWZhdWx0cyIsIm1vZHVsZSIsImV4cG9ydHMiLCJlcnJvcnMiLCJjdXN0b20iLCJzZXRIdHRwT3B0aW9uc0RlZmF1bHRzIiwiaHR0cF9vcHRpb25zIiwiY2xvY2tfdG9sZXJhbmNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/index.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/issuer.js":
/*!***************************************************!*\
  !*** ../node_modules/openid-client/lib/issuer.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { inspect } = __webpack_require__(/*! util */ \"util\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst { RPError } = __webpack_require__(/*! ./errors */ \"(rsc)/../node_modules/openid-client/lib/errors.js\");\nconst getClient = __webpack_require__(/*! ./client */ \"(rsc)/../node_modules/openid-client/lib/client.js\");\nconst registry = __webpack_require__(/*! ./issuer_registry */ \"(rsc)/../node_modules/openid-client/lib/issuer_registry.js\");\nconst processResponse = __webpack_require__(/*! ./helpers/process_response */ \"(rsc)/../node_modules/openid-client/lib/helpers/process_response.js\");\nconst webfingerNormalize = __webpack_require__(/*! ./helpers/webfinger_normalize */ \"(rsc)/../node_modules/openid-client/lib/helpers/webfinger_normalize.js\");\nconst request = __webpack_require__(/*! ./helpers/request */ \"(rsc)/../node_modules/openid-client/lib/helpers/request.js\");\nconst clone = __webpack_require__(/*! ./helpers/deep_clone */ \"(rsc)/../node_modules/openid-client/lib/helpers/deep_clone.js\");\nconst { keystore } = __webpack_require__(/*! ./helpers/issuer */ \"(rsc)/../node_modules/openid-client/lib/helpers/issuer.js\");\nconst AAD_MULTITENANT_DISCOVERY = [\n    \"https://login.microsoftonline.com/common/.well-known/openid-configuration\",\n    \"https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration\",\n    \"https://login.microsoftonline.com/organizations/v2.0/.well-known/openid-configuration\",\n    \"https://login.microsoftonline.com/consumers/v2.0/.well-known/openid-configuration\"\n];\nconst AAD_MULTITENANT = Symbol();\nconst ISSUER_DEFAULTS = {\n    claim_types_supported: [\n        \"normal\"\n    ],\n    claims_parameter_supported: false,\n    grant_types_supported: [\n        \"authorization_code\",\n        \"implicit\"\n    ],\n    request_parameter_supported: false,\n    request_uri_parameter_supported: true,\n    require_request_uri_registration: false,\n    response_modes_supported: [\n        \"query\",\n        \"fragment\"\n    ],\n    token_endpoint_auth_methods_supported: [\n        \"client_secret_basic\"\n    ]\n};\nclass Issuer {\n    #metadata;\n    constructor(meta = {}){\n        const aadIssValidation = meta[AAD_MULTITENANT];\n        delete meta[AAD_MULTITENANT];\n        [\n            \"introspection\",\n            \"revocation\"\n        ].forEach((endpoint)=>{\n            // if intro/revocation endpoint auth specific meta is missing use the token ones if they\n            // are defined\n            if (meta[`${endpoint}_endpoint`] && meta[`${endpoint}_endpoint_auth_methods_supported`] === undefined && meta[`${endpoint}_endpoint_auth_signing_alg_values_supported`] === undefined) {\n                if (meta.token_endpoint_auth_methods_supported) {\n                    meta[`${endpoint}_endpoint_auth_methods_supported`] = meta.token_endpoint_auth_methods_supported;\n                }\n                if (meta.token_endpoint_auth_signing_alg_values_supported) {\n                    meta[`${endpoint}_endpoint_auth_signing_alg_values_supported`] = meta.token_endpoint_auth_signing_alg_values_supported;\n                }\n            }\n        });\n        this.#metadata = new Map();\n        Object.entries(meta).forEach(([key, value])=>{\n            this.#metadata.set(key, value);\n            if (!this[key]) {\n                Object.defineProperty(this, key, {\n                    get () {\n                        return this.#metadata.get(key);\n                    },\n                    enumerable: true\n                });\n            }\n        });\n        registry.set(this.issuer, this);\n        const Client = getClient(this, aadIssValidation);\n        Object.defineProperties(this, {\n            Client: {\n                value: Client,\n                enumerable: true\n            },\n            FAPI1Client: {\n                value: class FAPI1Client extends Client {\n                },\n                enumerable: true\n            },\n            FAPI2Client: {\n                value: class FAPI2Client extends Client {\n                },\n                enumerable: true\n            }\n        });\n    }\n    get metadata() {\n        return clone(Object.fromEntries(this.#metadata.entries()));\n    }\n    static async webfinger(input) {\n        const resource = webfingerNormalize(input);\n        const { host } = url.parse(resource);\n        const webfingerUrl = `https://${host}/.well-known/webfinger`;\n        const response = await request.call(this, {\n            method: \"GET\",\n            url: webfingerUrl,\n            responseType: \"json\",\n            searchParams: {\n                resource,\n                rel: \"http://openid.net/specs/connect/1.0/issuer\"\n            },\n            headers: {\n                Accept: \"application/json\"\n            }\n        });\n        const body = processResponse(response);\n        const location = Array.isArray(body.links) && body.links.find((link)=>typeof link === \"object\" && link.rel === \"http://openid.net/specs/connect/1.0/issuer\" && link.href);\n        if (!location) {\n            throw new RPError({\n                message: \"no issuer found in webfinger response\",\n                body\n            });\n        }\n        if (typeof location.href !== \"string\" || !location.href.startsWith(\"https://\")) {\n            throw new RPError({\n                printf: [\n                    \"invalid issuer location %s\",\n                    location.href\n                ],\n                body\n            });\n        }\n        const expectedIssuer = location.href;\n        if (registry.has(expectedIssuer)) {\n            return registry.get(expectedIssuer);\n        }\n        const issuer = await this.discover(expectedIssuer);\n        if (issuer.issuer !== expectedIssuer) {\n            registry.del(issuer.issuer);\n            throw new RPError(\"discovered issuer mismatch, expected %s, got: %s\", expectedIssuer, issuer.issuer);\n        }\n        return issuer;\n    }\n    static async discover(uri) {\n        const wellKnownUri = resolveWellKnownUri(uri);\n        const response = await request.call(this, {\n            method: \"GET\",\n            responseType: \"json\",\n            url: wellKnownUri,\n            headers: {\n                Accept: \"application/json\"\n            }\n        });\n        const body = processResponse(response);\n        return new Issuer({\n            ...ISSUER_DEFAULTS,\n            ...body,\n            [AAD_MULTITENANT]: !!AAD_MULTITENANT_DISCOVERY.find((discoveryURL)=>wellKnownUri.startsWith(discoveryURL))\n        });\n    }\n    async reloadJwksUri() {\n        await keystore.call(this, true);\n    }\n    /* istanbul ignore next */ [inspect.custom]() {\n        return `${this.constructor.name} ${inspect(this.metadata, {\n            depth: Infinity,\n            colors: process.stdout.isTTY,\n            compact: false,\n            sorted: true\n        })}`;\n    }\n}\nfunction resolveWellKnownUri(uri) {\n    const parsed = url.parse(uri);\n    if (parsed.pathname.includes(\"/.well-known/\")) {\n        return uri;\n    } else {\n        let pathname;\n        if (parsed.pathname.endsWith(\"/\")) {\n            pathname = `${parsed.pathname}.well-known/openid-configuration`;\n        } else {\n            pathname = `${parsed.pathname}/.well-known/openid-configuration`;\n        }\n        return url.format({\n            ...parsed,\n            pathname\n        });\n    }\n}\nmodule.exports = Issuer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2lzc3Vlci5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxFQUFFQSxPQUFPLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDNUIsTUFBTUMsTUFBTUQsbUJBQU9BLENBQUM7QUFFcEIsTUFBTSxFQUFFRSxPQUFPLEVBQUUsR0FBR0YsbUJBQU9BLENBQUM7QUFDNUIsTUFBTUcsWUFBWUgsbUJBQU9BLENBQUM7QUFDMUIsTUFBTUksV0FBV0osbUJBQU9BLENBQUM7QUFDekIsTUFBTUssa0JBQWtCTCxtQkFBT0EsQ0FBQztBQUNoQyxNQUFNTSxxQkFBcUJOLG1CQUFPQSxDQUFDO0FBQ25DLE1BQU1PLFVBQVVQLG1CQUFPQSxDQUFDO0FBQ3hCLE1BQU1RLFFBQVFSLG1CQUFPQSxDQUFDO0FBQ3RCLE1BQU0sRUFBRVMsUUFBUSxFQUFFLEdBQUdULG1CQUFPQSxDQUFDO0FBRTdCLE1BQU1VLDRCQUE0QjtJQUNoQztJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBQ0QsTUFBTUMsa0JBQWtCQztBQUN4QixNQUFNQyxrQkFBa0I7SUFDdEJDLHVCQUF1QjtRQUFDO0tBQVM7SUFDakNDLDRCQUE0QjtJQUM1QkMsdUJBQXVCO1FBQUM7UUFBc0I7S0FBVztJQUN6REMsNkJBQTZCO0lBQzdCQyxpQ0FBaUM7SUFDakNDLGtDQUFrQztJQUNsQ0MsMEJBQTBCO1FBQUM7UUFBUztLQUFXO0lBQy9DQyx1Q0FBdUM7UUFBQztLQUFzQjtBQUNoRTtBQUVBLE1BQU1DO0lBQ0osQ0FBQ0MsUUFBUSxDQUFDO0lBQ1ZDLFlBQVlDLE9BQU8sQ0FBQyxDQUFDLENBQUU7UUFDckIsTUFBTUMsbUJBQW1CRCxJQUFJLENBQUNkLGdCQUFnQjtRQUM5QyxPQUFPYyxJQUFJLENBQUNkLGdCQUFnQjtRQUM1QjtZQUFDO1lBQWlCO1NBQWEsQ0FBQ2dCLE9BQU8sQ0FBQyxDQUFDQztZQUN2Qyx3RkFBd0Y7WUFDeEYsY0FBYztZQUNkLElBQ0VILElB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QUFNLENBQUNDLEtBQUs7WUFDNUJDLFNBQVM7WUFDVEMsUUFBUTtRQUNWLEdBQUcsQ0FBQztJQUNOO0FBQ0Y7QUFFQSxTQUFTWixvQkFBb0JGLEdBQUc7SUFDOUIsTUFBTWUsU0FBU3pGLElBQUlpRCxLQUFLLENBQUN5QjtJQUN6QixJQUFJZSxPQUFPQyxRQUFRLENBQUNDLFFBQVEsQ0FBQyxrQkFBa0I7UUFDN0MsT0FBT2pCO0lBQ1QsT0FBTztRQUNMLElBQUlnQjtRQUNKLElBQUlELE9BQU9DLFFBQVEsQ0FBQ0UsUUFBUSxDQUFDLE1BQU07WUFDakNGLFdBQVcsQ0FBQyxFQUFFRCxPQUFPQyxRQUFRLENBQUMsZ0NBQWdDLENBQUM7UUFDakUsT0FBTztZQUNMQSxXQUFXLENBQUMsRUFBRUQsT0FBT0MsUUFBUSxDQUFDLGlDQUFpQyxDQUFDO1FBQ2xFO1FBQ0EsT0FBTzFGLElBQUk2RixNQUFNLENBQUM7WUFBRSxHQUFHSixNQUFNO1lBQUVDO1FBQVM7SUFDMUM7QUFDRjtBQUVBSSxPQUFPQyxPQUFPLEdBQUcxRSIsInNvdXJjZXMiOlsid2VicGFjazovL2Vkc3UtaG91c2UtcHVibGljLy4uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9pc3N1ZXIuanM/YzkyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IGluc3BlY3QgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuXG5jb25zdCB7IFJQRXJyb3IgfSA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBnZXRDbGllbnQgPSByZXF1aXJlKCcuL2NsaWVudCcpO1xuY29uc3QgcmVnaXN0cnkgPSByZXF1aXJlKCcuL2lzc3Vlcl9yZWdpc3RyeScpO1xuY29uc3QgcHJvY2Vzc1Jlc3BvbnNlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3Byb2Nlc3NfcmVzcG9uc2UnKTtcbmNvbnN0IHdlYmZpbmdlck5vcm1hbGl6ZSA9IHJlcXVpcmUoJy4vaGVscGVycy93ZWJmaW5nZXJfbm9ybWFsaXplJyk7XG5jb25zdCByZXF1ZXN0ID0gcmVxdWlyZSgnLi9oZWxwZXJzL3JlcXVlc3QnKTtcbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi9oZWxwZXJzL2RlZXBfY2xvbmUnKTtcbmNvbnN0IHsga2V5c3RvcmUgfSA9IHJlcXVpcmUoJy4vaGVscGVycy9pc3N1ZXInKTtcblxuY29uc3QgQUFEX01VTFRJVEVOQU5UX0RJU0NPVkVSWSA9IFtcbiAgJ2h0dHBzOi8vbG9naW4ubWljcm9zb2Z0b25saW5lLmNvbS9jb21tb24vLndlbGwta25vd24vb3BlbmlkLWNvbmZpZ3VyYXRpb24nLFxuICAnaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tL2NvbW1vbi92Mi4wLy53ZWxsLWtub3duL29wZW5pZC1jb25maWd1cmF0aW9uJyxcbiAgJ2h0dHBzOi8vbG9naW4ubWljcm9zb2Z0b25saW5lLmNvbS9vcmdhbml6YXRpb25zL3YyLjAvLndlbGwta25vd24vb3BlbmlkLWNvbmZpZ3VyYXRpb24nLFxuICAnaHR0cHM6Ly9sb2dpbi5taWNyb3NvZnRvbmxpbmUuY29tL2NvbnN1bWVycy92Mi4wLy53ZWxsLWtub3duL29wZW5pZC1jb25maWd1cmF0aW9uJyxcbl07XG5jb25zdCBBQURfTVVMVElURU5BTlQgPSBTeW1ib2woKTtcbmNvbnN0IElTU1VFUl9ERUZBVUxUUyA9IHtcbiAgY2xhaW1fdHlwZXNfc3VwcG9ydGVkOiBbJ25vcm1hbCddLFxuICBjbGFpbXNfcGFyYW1ldGVyX3N1cHBvcnRlZDogZmFsc2UsXG4gIGdyYW50X3R5cGVzX3N1cHBvcnRlZDogWydhdXRob3JpemF0aW9uX2NvZGUnLCAnaW1wbGljaXQnXSxcbiAgcmVxdWVzdF9wYXJhbWV0ZXJfc3VwcG9ydGVkOiBmYWxzZSxcbiAgcmVxdWVzdF91cmlfcGFyYW1ldGVyX3N1cHBvcnRlZDogdHJ1ZSxcbiAgcmVxdWlyZV9yZXF1ZXN0X3VyaV9yZWdpc3RyYXRpb246IGZhbHNlLFxuICByZXNwb25zZV9tb2Rlc19zdXBwb3J0ZWQ6IFsncXVlcnknLCAnZnJhZ21lbnQnXSxcbiAgdG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2RzX3N1cHBvcnRlZDogWydjbGllbnRfc2VjcmV0X2Jhc2ljJ10sXG59O1xuXG5jbGFzcyBJc3N1ZXIge1xuICAjbWV0YWRhdGE7XG4gIGNvbnN0cnVjdG9yKG1ldGEgPSB7fSkge1xuICAgIGNvbnN0IGFhZElzc1ZhbGlkYXRpb24gPSBtZXRhW0FBRF9NVUxUSVRFTkFOVF07XG4gICAgZGVsZXRlIG1ldGFbQUFEX01VTFRJVEVOQU5UXTtcbiAgICBbJ2ludHJvc3BlY3Rpb24nLCAncmV2b2NhdGlvbiddLmZvckVhY2goKGVuZHBvaW50KSA9PiB7XG4gICAgICAvLyBpZiBpbnRyby9yZXZvY2F0aW9uIGVuZHBvaW50IGF1dGggc3BlY2lmaWMgbWV0YSBpcyBtaXNzaW5nIHVzZSB0aGUgdG9rZW4gb25lcyBpZiB0aGV5XG4gICAgICAvLyBhcmUgZGVmaW5lZFxuICAgICAgaWYgKFxuICAgICAgICBtZXRhW2Ake2VuZHBvaW50fV9lbmRwb2ludGBdICYmXG4gICAgICAgIG1ldGFbYCR7ZW5kcG9pbnR9X2VuZHBvaW50X2F1dGhfbWV0aG9kc19zdXBwb3J0ZWRgXSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgIG1ldGFbYCR7ZW5kcG9pbnR9X2VuZHBvaW50X2F1dGhfc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZGBdID09PSB1bmRlZmluZWRcbiAgICAgICkge1xuICAgICAgICBpZiAobWV0YS50b2tlbl9lbmRwb2ludF9hdXRoX21ldGhvZHNfc3VwcG9ydGVkKSB7XG4gICAgICAgICAgbWV0YVtgJHtlbmRwb2ludH1fZW5kcG9pbnRfYXV0aF9tZXRob2RzX3N1cHBvcnRlZGBdID1cbiAgICAgICAgICAgIG1ldGEudG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2RzX3N1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YS50b2tlbl9lbmRwb2ludF9hdXRoX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWQpIHtcbiAgICAgICAgICBtZXRhW2Ake2VuZHBvaW50fV9lbmRwb2ludF9hdXRoX3NpZ25pbmdfYWxnX3ZhbHVlc19zdXBwb3J0ZWRgXSA9XG4gICAgICAgICAgICBtZXRhLnRva2VuX2VuZHBvaW50X2F1dGhfc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy4jbWV0YWRhdGEgPSBuZXcgTWFwKCk7XG5cbiAgICBPYmplY3QuZW50cmllcyhtZXRhKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIHRoaXMuI21ldGFkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgIGlmICghdGhpc1trZXldKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jbWV0YWRhdGEuZ2V0KGtleSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlZ2lzdHJ5LnNldCh0aGlzLmlzc3VlciwgdGhpcyk7XG5cbiAgICBjb25zdCBDbGllbnQgPSBnZXRDbGllbnQodGhpcywgYWFkSXNzVmFsaWRhdGlvbik7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICBDbGllbnQ6IHsgdmFsdWU6IENsaWVudCwgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgRkFQSTFDbGllbnQ6IHsgdmFsdWU6IGNsYXNzIEZBUEkxQ2xpZW50IGV4dGVuZHMgQ2xpZW50IHt9LCBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICBGQVBJMkNsaWVudDogeyB2YWx1ZTogY2xhc3MgRkFQSTJDbGllbnQgZXh0ZW5kcyBDbGllbnQge30sIGVudW1lcmFibGU6IHRydWUgfSxcbiAgICB9KTtcbiAgfVxuXG4gIGdldCBtZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gY2xvbmUoT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuI21ldGFkYXRhLmVudHJpZXMoKSkpO1xuICB9XG5cbiAgc3RhdGljIGFzeW5jIHdlYmZpbmdlcihpbnB1dCkge1xuICAgIGNvbnN0IHJlc291cmNlID0gd2ViZmluZ2VyTm9ybWFsaXplKGlucHV0KTtcbiAgICBjb25zdCB7IGhvc3QgfSA9IHVybC5wYXJzZShyZXNvdXJjZSk7XG4gICAgY29uc3Qgd2ViZmluZ2VyVXJsID0gYGh0dHBzOi8vJHtob3N0fS8ud2VsbC1rbm93bi93ZWJmaW5nZXJgO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0LmNhbGwodGhpcywge1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHVybDogd2ViZmluZ2VyVXJsLFxuICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICBzZWFyY2hQYXJhbXM6IHsgcmVzb3VyY2UsIHJlbDogJ2h0dHA6Ly9vcGVuaWQubmV0L3NwZWNzL2Nvbm5lY3QvMS4wL2lzc3VlcicgfSxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IGJvZHkgPSBwcm9jZXNzUmVzcG9uc2UocmVzcG9uc2UpO1xuXG4gICAgY29uc3QgbG9jYXRpb24gPVxuICAgICAgQXJyYXkuaXNBcnJheShib2R5LmxpbmtzKSAmJlxuICAgICAgYm9keS5saW5rcy5maW5kKFxuICAgICAgICAobGluaykgPT5cbiAgICAgICAgICB0eXBlb2YgbGluayA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICBsaW5rLnJlbCA9PT0gJ2h0dHA6Ly9vcGVuaWQubmV0L3NwZWNzL2Nvbm5lY3QvMS4wL2lzc3VlcicgJiZcbiAgICAgICAgICBsaW5rLmhyZWYsXG4gICAgICApO1xuXG4gICAgaWYgKCFsb2NhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IFJQRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiAnbm8gaXNzdWVyIGZvdW5kIGluIHdlYmZpbmdlciByZXNwb25zZScsXG4gICAgICAgIGJvZHksXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGxvY2F0aW9uLmhyZWYgIT09ICdzdHJpbmcnIHx8ICFsb2NhdGlvbi5ocmVmLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykpIHtcbiAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgcHJpbnRmOiBbJ2ludmFsaWQgaXNzdWVyIGxvY2F0aW9uICVzJywgbG9jYXRpb24uaHJlZl0sXG4gICAgICAgIGJvZHksXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBleHBlY3RlZElzc3VlciA9IGxvY2F0aW9uLmhyZWY7XG4gICAgaWYgKHJlZ2lzdHJ5LmhhcyhleHBlY3RlZElzc3VlcikpIHtcbiAgICAgIHJldHVybiByZWdpc3RyeS5nZXQoZXhwZWN0ZWRJc3N1ZXIpO1xuICAgIH1cblxuICAgIGNvbnN0IGlzc3VlciA9IGF3YWl0IHRoaXMuZGlzY292ZXIoZXhwZWN0ZWRJc3N1ZXIpO1xuXG4gICAgaWYgKGlzc3Vlci5pc3N1ZXIgIT09IGV4cGVjdGVkSXNzdWVyKSB7XG4gICAgICByZWdpc3RyeS5kZWwoaXNzdWVyLmlzc3Vlcik7XG4gICAgICB0aHJvdyBuZXcgUlBFcnJvcihcbiAgICAgICAgJ2Rpc2NvdmVyZWQgaXNzdWVyIG1pc21hdGNoLCBleHBlY3RlZCAlcywgZ290OiAlcycsXG4gICAgICAgIGV4cGVjdGVkSXNzdWVyLFxuICAgICAgICBpc3N1ZXIuaXNzdWVyLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzc3VlcjtcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBkaXNjb3Zlcih1cmkpIHtcbiAgICBjb25zdCB3ZWxsS25vd25VcmkgPSByZXNvbHZlV2VsbEtub3duVXJpKHVyaSk7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QuY2FsbCh0aGlzLCB7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICB1cmw6IHdlbGxLbm93blVyaSxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IGJvZHkgPSBwcm9jZXNzUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIHJldHVybiBuZXcgSXNzdWVyKHtcbiAgICAgIC4uLklTU1VFUl9ERUZBVUxUUyxcbiAgICAgIC4uLmJvZHksXG4gICAgICBbQUFEX01VTFRJVEVOQU5UXTogISFBQURfTVVMVElURU5BTlRfRElTQ09WRVJZLmZpbmQoKGRpc2NvdmVyeVVSTCkgPT5cbiAgICAgICAgd2VsbEtub3duVXJpLnN0YXJ0c1dpdGgoZGlzY292ZXJ5VVJMKSxcbiAgICAgICksXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyByZWxvYWRKd2tzVXJpKCkge1xuICAgIGF3YWl0IGtleXN0b3JlLmNhbGwodGhpcywgdHJ1ZSk7XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBbaW5zcGVjdC5jdXN0b21dKCkge1xuICAgIHJldHVybiBgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9ICR7aW5zcGVjdCh0aGlzLm1ldGFkYXRhLCB7XG4gICAgICBkZXB0aDogSW5maW5pdHksXG4gICAgICBjb2xvcnM6IHByb2Nlc3Muc3Rkb3V0LmlzVFRZLFxuICAgICAgY29tcGFjdDogZmFsc2UsXG4gICAgICBzb3J0ZWQ6IHRydWUsXG4gICAgfSl9YDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlV2VsbEtub3duVXJpKHVyaSkge1xuICBjb25zdCBwYXJzZWQgPSB1cmwucGFyc2UodXJpKTtcbiAgaWYgKHBhcnNlZC5wYXRobmFtZS5pbmNsdWRlcygnLy53ZWxsLWtub3duLycpKSB7XG4gICAgcmV0dXJuIHVyaTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcGF0aG5hbWU7XG4gICAgaWYgKHBhcnNlZC5wYXRobmFtZS5lbmRzV2l0aCgnLycpKSB7XG4gICAgICBwYXRobmFtZSA9IGAke3BhcnNlZC5wYXRobmFtZX0ud2VsbC1rbm93bi9vcGVuaWQtY29uZmlndXJhdGlvbmA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGhuYW1lID0gYCR7cGFyc2VkLnBhdGhuYW1lfS8ud2VsbC1rbm93bi9vcGVuaWQtY29uZmlndXJhdGlvbmA7XG4gICAgfVxuICAgIHJldHVybiB1cmwuZm9ybWF0KHsgLi4ucGFyc2VkLCBwYXRobmFtZSB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IElzc3VlcjtcbiJdLCJuYW1lcyI6WyJpbnNwZWN0IiwicmVxdWlyZSIsInVybCIsIlJQRXJyb3IiLCJnZXRDbGllbnQiLCJyZWdpc3RyeSIsInByb2Nlc3NSZXNwb25zZSIsIndlYmZpbmdlck5vcm1hbGl6ZSIsInJlcXVlc3QiLCJjbG9uZSIsImtleXN0b3JlIiwiQUFEX01VTFRJVEVOQU5UX0RJU0NPVkVSWSIsIkFBRF9NVUxUSVRFTkFOVCIsIlN5bWJvbCIsIklTU1VFUl9ERUZBVUxUUyIsImNsYWltX3R5cGVzX3N1cHBvcnRlZCIsImNsYWltc19wYXJhbWV0ZXJfc3VwcG9ydGVkIiwiZ3JhbnRfdHlwZXNfc3VwcG9ydGVkIiwicmVxdWVzdF9wYXJhbWV0ZXJfc3VwcG9ydGVkIiwicmVxdWVzdF91cmlfcGFyYW1ldGVyX3N1cHBvcnRlZCIsInJlcXVpcmVfcmVxdWVzdF91cmlfcmVnaXN0cmF0aW9uIiwicmVzcG9uc2VfbW9kZXNfc3VwcG9ydGVkIiwidG9rZW5fZW5kcG9pbnRfYXV0aF9tZXRob2RzX3N1cHBvcnRlZCIsIklzc3VlciIsIm1ldGFkYXRhIiwiY29uc3RydWN0b3IiLCJtZXRhIiwiYWFkSXNzVmFsaWRhdGlvbiIsImZvckVhY2giLCJlbmRwb2ludCIsInVuZGVmaW5lZCIsInRva2VuX2VuZHBvaW50X2F1dGhfc2lnbmluZ19hbGdfdmFsdWVzX3N1cHBvcnRlZCIsIk1hcCIsIk9iamVjdCIsImVudHJpZXMiLCJrZXkiLCJ2YWx1ZSIsInNldCIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiZW51bWVyYWJsZSIsImlzc3VlciIsIkNsaWVudCIsImRlZmluZVByb3BlcnRpZXMiLCJGQVBJMUNsaWVudCIsIkZBUEkyQ2xpZW50IiwiZnJvbUVudHJpZXMiLCJ3ZWJmaW5nZXIiLCJpbnB1dCIsInJlc291cmNlIiwiaG9zdCIsInBhcnNlIiwid2ViZmluZ2VyVXJsIiwicmVzcG9uc2UiLCJjYWxsIiwibWV0aG9kIiwicmVzcG9uc2VUeXBlIiwic2VhcmNoUGFyYW1zIiwicmVsIiwiaGVhZGVycyIsIkFjY2VwdCIsImJvZHkiLCJsb2NhdGlvbiIsIkFycmF5IiwiaXNBcnJheSIsImxpbmtzIiwiZmluZCIsImxpbmsiLCJocmVmIiwibWVzc2FnZSIsInN0YXJ0c1dpdGgiLCJwcmludGYiLCJleHBlY3RlZElzc3VlciIsImhhcyIsImRpc2NvdmVyIiwiZGVsIiwidXJpIiwid2VsbEtub3duVXJpIiwicmVzb2x2ZVdlbGxLbm93blVyaSIsImRpc2NvdmVyeVVSTCIsInJlbG9hZEp3a3NVcmkiLCJjdXN0b20iLCJuYW1lIiwiZGVwdGgiLCJJbmZpbml0eSIsImNvbG9ycyIsInByb2Nlc3MiLCJzdGRvdXQiLCJpc1RUWSIsImNvbXBhY3QiLCJzb3J0ZWQiLCJwYXJzZWQiLCJwYXRobmFtZSIsImluY2x1ZGVzIiwiZW5kc1dpdGgiLCJmb3JtYXQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/issuer.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/issuer_registry.js":
/*!************************************************************!*\
  !*** ../node_modules/openid-client/lib/issuer_registry.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst LRU = __webpack_require__(/*! lru-cache */ \"(rsc)/../node_modules/lru-cache/index.js\");\nmodule.exports = new LRU({\n    max: 100\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL2lzc3Vlcl9yZWdpc3RyeS5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTUEsTUFBTUMsbUJBQU9BLENBQUM7QUFFcEJDLE9BQU9DLE9BQU8sR0FBRyxJQUFJSCxJQUFJO0lBQUVJLEtBQUs7QUFBSSIsInNvdXJjZXMiOlsid2VicGFjazovL2Vkc3UtaG91c2UtcHVibGljLy4uL25vZGVfbW9kdWxlcy9vcGVuaWQtY2xpZW50L2xpYi9pc3N1ZXJfcmVnaXN0cnkuanM/ZmVhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBMUlUgPSByZXF1aXJlKCdscnUtY2FjaGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgTFJVKHsgbWF4OiAxMDAgfSk7XG4iXSwibmFtZXMiOlsiTFJVIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJtYXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/issuer_registry.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/passport_strategy.js":
/*!**************************************************************!*\
  !*** ../node_modules/openid-client/lib/passport_strategy.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst url = __webpack_require__(/*! url */ \"url\");\nconst { format } = __webpack_require__(/*! util */ \"util\");\nconst cloneDeep = __webpack_require__(/*! ./helpers/deep_clone */ \"(rsc)/../node_modules/openid-client/lib/helpers/deep_clone.js\");\nconst { RPError, OPError } = __webpack_require__(/*! ./errors */ \"(rsc)/../node_modules/openid-client/lib/errors.js\");\nconst { BaseClient } = __webpack_require__(/*! ./client */ \"(rsc)/../node_modules/openid-client/lib/client.js\");\nconst { random, codeChallenge } = __webpack_require__(/*! ./helpers/generators */ \"(rsc)/../node_modules/openid-client/lib/helpers/generators.js\");\nconst pick = __webpack_require__(/*! ./helpers/pick */ \"(rsc)/../node_modules/openid-client/lib/helpers/pick.js\");\nconst { resolveResponseType, resolveRedirectUri } = __webpack_require__(/*! ./helpers/client */ \"(rsc)/../node_modules/openid-client/lib/helpers/client.js\");\nfunction verified(err, user, info = {}) {\n    if (err) {\n        this.error(err);\n    } else if (!user) {\n        this.fail(info);\n    } else {\n        this.success(user, info);\n    }\n}\nfunction OpenIDConnectStrategy({ client, params = {}, passReqToCallback = false, sessionKey, usePKCE = true, extras = {} } = {}, verify) {\n    if (!(client instanceof BaseClient)) {\n        throw new TypeError(\"client must be an instance of openid-client Client\");\n    }\n    if (typeof verify !== \"function\") {\n        throw new TypeError(\"verify callback must be a function\");\n    }\n    if (!client.issuer || !client.issuer.issuer) {\n        throw new TypeError(\"client must have an issuer with an identifier\");\n    }\n    this._client = client;\n    this._issuer = client.issuer;\n    this._verify = verify;\n    this._passReqToCallback = passReqToCallback;\n    this._usePKCE = usePKCE;\n    this._key = sessionKey || `oidc:${url.parse(this._issuer.issuer).hostname}`;\n    this._params = cloneDeep(params);\n    // state and nonce are handled in authenticate()\n    delete this._params.state;\n    delete this._params.nonce;\n    this._extras = cloneDeep(extras);\n    if (!this._params.response_type) this._params.response_type = resolveResponseType.call(client);\n    if (!this._params.redirect_uri) this._params.redirect_uri = resolveRedirectUri.call(client);\n    if (!this._params.scope) this._params.scope = \"openid\";\n    if (this._usePKCE === true) {\n        const supportedMethods = Array.isArray(this._issuer.code_challenge_methods_supported) ? this._issuer.code_challenge_methods_supported : false;\n        if (supportedMethods && supportedMethods.includes(\"S256\")) {\n            this._usePKCE = \"S256\";\n        } else if (supportedMethods && supportedMethods.includes(\"plain\")) {\n            this._usePKCE = \"plain\";\n        } else if (supportedMethods) {\n            throw new TypeError(\"neither code_challenge_method supported by the client is supported by the issuer\");\n        } else {\n            this._usePKCE = \"S256\";\n        }\n    } else if (typeof this._usePKCE === \"string\" && ![\n        \"plain\",\n        \"S256\"\n    ].includes(this._usePKCE)) {\n        throw new TypeError(`${this._usePKCE} is not valid/implemented PKCE code_challenge_method`);\n    }\n    this.name = url.parse(client.issuer.issuer).hostname;\n}\nOpenIDConnectStrategy.prototype.authenticate = function authenticate(req, options) {\n    (async ()=>{\n        const client = this._client;\n        if (!req.session) {\n            throw new TypeError(\"authentication requires session support\");\n        }\n        const reqParams = client.callbackParams(req);\n        const sessionKey = this._key;\n        const { 0: parameter, length } = Object.keys(reqParams);\n        /**\n     * Start authentication request if this has no authorization response parameters or\n     * this might a login initiated from a third party as per\n     * https://openid.net/specs/openid-connect-core-1_0.html#ThirdPartyInitiatedLogin.\n     */ if (length === 0 || length === 1 && parameter === \"iss\") {\n            // provide options object with extra authentication parameters\n            const params = {\n                state: random(),\n                ...this._params,\n                ...options\n            };\n            if (!params.nonce && params.response_type.includes(\"id_token\")) {\n                params.nonce = random();\n            }\n            req.session[sessionKey] = pick(params, \"nonce\", \"state\", \"max_age\", \"response_type\");\n            if (this._usePKCE && params.response_type.includes(\"code\")) {\n                const verifier = random();\n                req.session[sessionKey].code_verifier = verifier;\n                switch(this._usePKCE){\n                    case \"S256\":\n                        params.code_challenge = codeChallenge(verifier);\n                        params.code_challenge_method = \"S256\";\n                        break;\n                    case \"plain\":\n                        params.code_challenge = verifier;\n                        break;\n                }\n            }\n            this.redirect(client.authorizationUrl(params));\n            return;\n        }\n        /* end authentication request */ /* start authentication response */ const session = req.session[sessionKey];\n        if (Object.keys(session || {}).length === 0) {\n            throw new Error(format('did not find expected authorization request details in session, req.session[\"%s\"] is %j', sessionKey, session));\n        }\n        const { state, nonce, max_age: maxAge, code_verifier: codeVerifier, response_type: responseType } = session;\n        try {\n            delete req.session[sessionKey];\n        } catch (err) {}\n        const opts = {\n            redirect_uri: this._params.redirect_uri,\n            ...options\n        };\n        const checks = {\n            state,\n            nonce,\n            max_age: maxAge,\n            code_verifier: codeVerifier,\n            response_type: responseType\n        };\n        const tokenset = await client.callback(opts.redirect_uri, reqParams, checks, this._extras);\n        const passReq = this._passReqToCallback;\n        const loadUserinfo = this._verify.length > (passReq ? 3 : 2) && client.issuer.userinfo_endpoint;\n        const args = [\n            tokenset,\n            verified.bind(this)\n        ];\n        if (loadUserinfo) {\n            if (!tokenset.access_token) {\n                throw new RPError({\n                    message: \"expected access_token to be returned when asking for userinfo in verify callback\",\n                    tokenset\n                });\n            }\n            const userinfo = await client.userinfo(tokenset);\n            args.splice(1, 0, userinfo);\n        }\n        if (passReq) {\n            args.unshift(req);\n        }\n        this._verify(...args);\n    /* end authentication response */ })().catch((error)=>{\n        if (error instanceof OPError && error.error !== \"server_error\" && !error.error.startsWith(\"invalid\") || error instanceof RPError) {\n            this.fail(error);\n        } else {\n            this.error(error);\n        }\n    });\n};\nmodule.exports = OpenIDConnectStrategy;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL3Bhc3Nwb3J0X3N0cmF0ZWd5LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNQSxNQUFNQyxtQkFBT0EsQ0FBQztBQUNwQixNQUFNLEVBQUVDLE1BQU0sRUFBRSxHQUFHRCxtQkFBT0EsQ0FBQztBQUUzQixNQUFNRSxZQUFZRixtQkFBT0EsQ0FBQztBQUMxQixNQUFNLEVBQUVHLE9BQU8sRUFBRUMsT0FBTyxFQUFFLEdBQUdKLG1CQUFPQSxDQUFDO0FBQ3JDLE1BQU0sRUFBRUssVUFBVSxFQUFFLEdBQUdMLG1CQUFPQSxDQUFDO0FBQy9CLE1BQU0sRUFBRU0sTUFBTSxFQUFFQyxhQUFhLEVBQUUsR0FBR1AsbUJBQU9BLENBQUM7QUFDMUMsTUFBTVEsT0FBT1IsbUJBQU9BLENBQUM7QUFDckIsTUFBTSxFQUFFUyxtQkFBbUIsRUFBRUMsa0JBQWtCLEVBQUUsR0FBR1YsbUJBQU9BLENBQUM7QUFFNUQsU0FBU1csU0FBU0MsR0FBRyxFQUFFQyxJQUFJLEVBQUVDLE9BQU8sQ0FBQyxDQUFDO0lBQ3BDLElBQUlGLEtBQUs7UUFDUCxJQUFJLENBQUNHLEtBQUssQ0FBQ0g7SUFDYixPQUFPLElBQUksQ0FBQ0MsTUFBTTtRQUNoQixJQUFJLENBQUNHLElBQUksQ0FBQ0Y7SUFDWixPQUFPO1FBQ0wsSUFBSSxDQUFDRyxPQUFPLENBQUNKLE1BQU1DO0lBQ3JCO0FBQ0Y7QUFFQSxTQUFTSSxzQkFDUCxFQUFFQyxNQUFNLEVBQUVDLFNBQVMsQ0FBQyxDQUFDLEVBQUVDLG9CQUFvQixLQUFLLEVBQUVDLFVBQVUsRUFBRUMsVUFBVSxJQUFJLEVBQUVDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFDaEdDLE1BQU07SUFFTixJQUFJLENBQUVOLENBQUFBLGtCQUFrQmQsVUFBUyxHQUFJO1FBQ25DLE1BQU0sSUFBSXFCLFVBQVU7SUFDdEI7SUFFQSxJQUFJLE9BQU9ELFdBQVcsWUFBWTtRQUNoQyxNQUFNLElBQUlDLFVBQVU7SUFDdEI7SUFFQSxJQUFJLENBQUNQLE9BQU9RLE1BQU0sSUFBSSxDQUFDUixPQUFPUSxNQUFNLENBQUNBLE1BQU0sRUFBRTtRQUMzQyxNQUFNLElBQUlELFVBQVU7SUFDdEI7SUFFQSxJQUFJLENBQUNFLE9BQU8sR0FBR1Q7SUFDZixJQUFJLENBQUNVLE9BQU8sR0FBR1YsT0FBT1EsTUFBTTtJQUM1QixJQUFJLENBQUNHLE9BQU8sR0FBR0w7SUFDZixJQUFJLENBQUNNLGtCQUFrQixHQUFHVjtJQUMxQixJQUFJLENBQUNXLFFBQVEsR0FBR1Q7SUFDaEIsSUFBSSxDQUFDVSxJQUFJLEdBQUdYLGNBQWMsQ0FBQyxLQUFLLEVBQUV2QixJQUFJbUMsS0FBSyxDQUFDLElBQUksQ0FBQ0wsT0FBTyxDQUFDRixNQUFNLEVBQUVRLFFBQVEsQ0FBQyxDQUFDO0lBQzNFLElBQUksQ0FBQ0MsT0FBTyxHQUFHbEMsVUFBVWtCO0lBRXpCLGdEQUFnRDtJQUNoRCxPQUFPLElBQUksQ0FBQ2dCLE9BQU8sQ0FBQ0MsS0FBSztJQUN6QixPQUFPLElBQUksQ0FBQ0QsT0FBTyxDQUFDRSxLQUFLO0lBRXpCLElBQUksQ0FBQ0MsT0FBTyxHQUFHckMsVUFBVXNCO0lBRXpCLElBQUksQ0FBQyxJQUFJLENBQUNZLE9BQU8sQ0FBQ0ksYUFBYSxFQUFFLElBQUksQ0FBQ0osT0FBTyxDQUFDSSxhQUFhLEdBQUcvQixvQkFBb0JnQyxJQUFJLENBQUN0QjtJQUN2RixJQUFJLENBQUMsSUFBSSxDQUFDaUIsT0FBTyxDQUFDTSxZQUFZLEVBQUUsSUFBSSxDQUFDTixPQUFPLENBQUNNLFlBQVksR0FBR2hDLG1CQUFtQitCLElBQUksQ0FBQ3RCO0lBQ3BGLElBQUksQ0FBQyxJQUFJLENBQUNpQixPQUFPLENBQUNPLEtBQUssRUFBRSxJQUFJLENBQUNQLE9BQU8sQ0FBQ08sS0FBSyxHQUFHO0lBRTlDLElBQUksSUFBSSxDQUFDWCxRQUFRLEtBQUssTUFBTTtRQUMxQixNQUFNWSxtQkFBbUJDLE1BQU1DLE9BQU8sQ0FBQyxJQUFJLENBQUNqQixPQUFPLENBQUNrQixnQ0FBZ0MsSUFDaEYsSUFBSSxDQUFDbEIsT0FBTyxDQUFDa0IsZ0NBQWdDLEdBQzdDO1FBRUosSUFBSUgsb0JBQW9CQSxpQkFBaUJJLFFBQVEsQ0FBQyxTQUFTO1lBQ3pELElBQUksQ0FBQ2hCLFFBQVEsR0FBRztRQUNsQixPQUFPLElBQUlZLG9CQUFvQkEsaUJBQWlCSSxRQUFRLENBQUMsVUFBVTtZQUNqRSxJQUFJLENBQUNoQixRQUFRLEdBQUc7UUFDbEIsT0FBTyxJQUFJWSxrQkFBa0I7WUFDM0IsTUFBTSxJQUFJbEIsVUFDUjtRQUVKLE9BQU87WUFDTCxJQUFJLENBQUNNLFFBQVEsR0FBRztRQUNsQjtJQUNGLE9BQU8sSUFBSSxPQUFPLElBQUksQ0FBQ0EsUUFBUSxLQUFLLFlBQVksQ0FBQztRQUFDO1FBQVM7S0FBTyxDQUFDZ0IsUUFBUSxDQUFDLElBQUksQ0FBQ2hCLFFBQVEsR0FBRztRQUMxRixNQUFNLElBQUlOLFVBQVUsQ0FBQyxFQUFFLElBQUksQ0FBQ00sUUFBUSxDQUFDLG9EQUFvRCxDQUFDO0lBQzVGO0lBRUEsSUFBSSxDQUFDaUIsSUFBSSxHQUFHbEQsSUFBSW1DLEtBQUssQ0FBQ2YsT0FBT1EsTUFBTSxDQUFDQSxNQUFNLEVBQUVRLFFBQVE7QUFDdEQ7QUFFQWpCLHNCQUFzQmdDLFNBQVMsQ0FBQ0MsWUFBWSxHQUFHLFNBQVNBLGFBQWFDLEdBQUcsRUFBRUMsT0FBTztJQUM5RTtRQUNDLE1BQU1sQyxTQUFTLElBQUksQ0FBQ1MsT0FBTztRQUMzQixJQUFJLENBQUN3QixJQUFJRSxPQUFPLEVBQUU7WUFDaEIsTUFBTSxJQUFJNUIsVUFBVTtRQUN0QjtRQUNBLE1BQU02QixZQUFZcEMsT0FBT3FDLGNBQWMsQ0FBQ0o7UUFDeEMsTUFBTTlCLGFBQWEsSUFBSSxDQUFDVyxJQUFJO1FBRTVCLE1BQU0sRUFBRSxHQUFHd0IsU0FBUyxFQUFFQyxNQUFNLEVBQUUsR0FBR0MsT0FBT0MsSUFBSSxDQUFDTDtRQUU3Qzs7OztLQUlDLEdBQ0QsSUFBSUcsV0FBVyxLQUFNQSxXQUFXLEtBQUtELGNBQWMsT0FBUTtZQUN6RCw4REFBOEQ7WUFDOUQsTUFBTXJDLFNBQVM7Z0JBQ2JpQixPQUFPL0I7Z0JBQ1AsR0FBRyxJQUFJLENBQUM4QixPQUFPO2dCQUNmLEdBQUdpQixPQUFPO1lBQ1o7WUFFQSxJQUFJLENBQUNqQyxPQUFPa0IsS0FBSyxJQUFJbEIsT0FBT29CLGFBQWEsQ0FBQ1EsUUFBUSxDQUFDLGFBQWE7Z0JBQzlENUIsT0FBT2tCLEtBQUssR0FBR2hDO1lBQ2pCO1lBRUE4QyxJQUFJRSxPQUFPLENBQUNoQyxXQUFXLEdBQUdkLEtBQUtZLFFBQVEsU0FBUyxTQUFTLFdBQVc7WUFFcEUsSUFBSSxJQUFJLENBQUNZLFFBQVEsSUFBSVosT0FBT29CLGFBQWEsQ0FBQ1EsUUFBUSxDQUFDLFNBQVM7Z0JBQzFELE1BQU1hLFdBQVd2RDtnQkFDakI4QyxJQUFJRSxPQUFPLENBQUNoQyxXQUFXLENBQUN3QyxhQUFhLEdBQUdEO2dCQUV4QyxPQUFRLElBQUksQ0FBQzdCLFFBQVE7b0JBQ25CLEtBQUs7d0JBQ0haLE9BQU8yQyxjQUFjLEdBQUd4RCxjQUFjc0Q7d0JBQ3RDekMsT0FBTzRDLHFCQUFxQixHQUFHO3dCQUMvQjtvQkFDRixLQUFLO3dCQUNINUMsT0FBTzJDLGNBQWMsR0FBR0Y7d0JBQ3hCO2dCQUNKO1lBQ0Y7WUFFQSxJQUFJLENBQUNJLFFBQVEsQ0FBQzlDLE9BQU8rQyxnQkFBZ0IsQ0FBQzlDO1lBQ3RDO1FBQ0Y7UUFDQSw4QkFBOEIsR0FFOUIsaUNBQWlDLEdBRWpDLE1BQU1rQyxVQUFVRixJQUFJRSxPQUFPLENBQUNoQyxXQUFXO1FBQ3ZDLElBQUlxQyxPQUFPQyxJQUFJLENBQUNOLFdBQVcsQ0FBQyxHQUFHSSxNQUFNLEtBQUssR0FBRztZQUMzQyxNQUFNLElBQUlTLE1BQ1JsRSxPQUNFLDJGQUNBcUIsWUFDQWdDO1FBR047UUFFQSxNQUFNLEVBQ0pqQixLQUFLLEVBQ0xDLEtBQUssRUFDTDhCLFNBQVNDLE1BQU0sRUFDZlAsZUFBZVEsWUFBWSxFQUMzQjlCLGVBQWUrQixZQUFZLEVBQzVCLEdBQUdqQjtRQUVKLElBQUk7WUFDRixPQUFPRixJQUFJRSxPQUFPLENBQUNoQyxXQUFXO1FBQ2hDLEVBQUUsT0FBT1YsS0FBSyxDQUFDO1FBRWYsTUFBTTRELE9BQU87WUFDWDlCLGNBQWMsSUFBSSxDQUFDTixPQUFPLENBQUNNLFlBQVk7WUFDdkMsR0FBR1csT0FBTztRQUNaO1FBRUEsTUFBTW9CLFNBQVM7WUFDYnBDO1lBQ0FDO1lBQ0E4QixTQUFTQztZQUNUUCxlQUFlUTtZQUNmOUIsZUFBZStCO1FBQ2pCO1FBRUEsTUFBTUcsV0FBVyxNQUFNdkQsT0FBT3dELFFBQVEsQ0FBQ0gsS0FBSzlCLFlBQVksRUFBRWEsV0FBV2tCLFFBQVEsSUFBSSxDQUFDbEMsT0FBTztRQUV6RixNQUFNcUMsVUFBVSxJQUFJLENBQUM3QyxrQkFBa0I7UUFDdkMsTUFBTThDLGVBQWUsSUFBSSxDQUFDL0MsT0FBTyxDQUFDNEIsTUFBTSxHQUFJa0IsQ0FBQUEsVUFBVSxJQUFJLE1BQU16RCxPQUFPUSxNQUFNLENBQUNtRCxpQkFBaUI7UUFFL0YsTUFBTUMsT0FBTztZQUFDTDtZQUFVL0QsU0FBU3FFLElBQUksQ0FBQyxJQUFJO1NBQUU7UUFFNUMsSUFBSUgsY0FBYztZQUNoQixJQUFJLENBQUNILFNBQVNPLFlBQVksRUFBRTtnQkFDMUIsTUFBTSxJQUFJOUUsUUFBUTtvQkFDaEIrRSxTQUNFO29CQUNGUjtnQkFDRjtZQUNGO1lBQ0EsTUFBTVMsV0FBVyxNQUFNaEUsT0FBT2dFLFFBQVEsQ0FBQ1Q7WUFDdkNLLEtBQUtLLE1BQU0sQ0FBQyxHQUFHLEdBQUdEO1FBQ3BCO1FBRUEsSUFBSVAsU0FBUztZQUNYRyxLQUFLTSxPQUFPLENBQUNqQztRQUNmO1FBRUEsSUFBSSxDQUFDdEIsT0FBTyxJQUFJaUQ7SUFDaEIsK0JBQStCLEdBQ2pDLEtBQUtPLEtBQUssQ0FBQyxDQUFDdkU7UUFDVixJQUNFLGlCQUFrQlgsV0FDaEJXLE1BQU1BLEtBQUssS0FBSyxrQkFDaEIsQ0FBQ0EsTUFBTUEsS0FBSyxDQUFDd0UsVUFBVSxDQUFDLGNBQzFCeEUsaUJBQWlCWixTQUNqQjtZQUNBLElBQUksQ0FBQ2EsSUFBSSxDQUFDRDtRQUNaLE9BQU87WUFDTCxJQUFJLENBQUNBLEtBQUssQ0FBQ0E7UUFDYjtJQUNGO0FBQ0Y7QUFFQXlFLE9BQU9DLE9BQU8sR0FBR3ZFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWRzdS1ob3VzZS1wdWJsaWMvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL3Bhc3Nwb3J0X3N0cmF0ZWd5LmpzPzg4NmEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgdXJsID0gcmVxdWlyZSgndXJsJyk7XG5jb25zdCB7IGZvcm1hdCB9ID0gcmVxdWlyZSgndXRpbCcpO1xuXG5jb25zdCBjbG9uZURlZXAgPSByZXF1aXJlKCcuL2hlbHBlcnMvZGVlcF9jbG9uZScpO1xuY29uc3QgeyBSUEVycm9yLCBPUEVycm9yIH0gPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgeyBCYXNlQ2xpZW50IH0gPSByZXF1aXJlKCcuL2NsaWVudCcpO1xuY29uc3QgeyByYW5kb20sIGNvZGVDaGFsbGVuZ2UgfSA9IHJlcXVpcmUoJy4vaGVscGVycy9nZW5lcmF0b3JzJyk7XG5jb25zdCBwaWNrID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BpY2snKTtcbmNvbnN0IHsgcmVzb2x2ZVJlc3BvbnNlVHlwZSwgcmVzb2x2ZVJlZGlyZWN0VXJpIH0gPSByZXF1aXJlKCcuL2hlbHBlcnMvY2xpZW50Jyk7XG5cbmZ1bmN0aW9uIHZlcmlmaWVkKGVyciwgdXNlciwgaW5mbyA9IHt9KSB7XG4gIGlmIChlcnIpIHtcbiAgICB0aGlzLmVycm9yKGVycik7XG4gIH0gZWxzZSBpZiAoIXVzZXIpIHtcbiAgICB0aGlzLmZhaWwoaW5mbyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zdWNjZXNzKHVzZXIsIGluZm8pO1xuICB9XG59XG5cbmZ1bmN0aW9uIE9wZW5JRENvbm5lY3RTdHJhdGVneShcbiAgeyBjbGllbnQsIHBhcmFtcyA9IHt9LCBwYXNzUmVxVG9DYWxsYmFjayA9IGZhbHNlLCBzZXNzaW9uS2V5LCB1c2VQS0NFID0gdHJ1ZSwgZXh0cmFzID0ge30gfSA9IHt9LFxuICB2ZXJpZnksXG4pIHtcbiAgaWYgKCEoY2xpZW50IGluc3RhbmNlb2YgQmFzZUNsaWVudCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjbGllbnQgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBvcGVuaWQtY2xpZW50IENsaWVudCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2ZXJpZnkgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2ZXJpZnkgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBpZiAoIWNsaWVudC5pc3N1ZXIgfHwgIWNsaWVudC5pc3N1ZXIuaXNzdWVyKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2xpZW50IG11c3QgaGF2ZSBhbiBpc3N1ZXIgd2l0aCBhbiBpZGVudGlmaWVyJyk7XG4gIH1cblxuICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gIHRoaXMuX2lzc3VlciA9IGNsaWVudC5pc3N1ZXI7XG4gIHRoaXMuX3ZlcmlmeSA9IHZlcmlmeTtcbiAgdGhpcy5fcGFzc1JlcVRvQ2FsbGJhY2sgPSBwYXNzUmVxVG9DYWxsYmFjaztcbiAgdGhpcy5fdXNlUEtDRSA9IHVzZVBLQ0U7XG4gIHRoaXMuX2tleSA9IHNlc3Npb25LZXkgfHwgYG9pZGM6JHt1cmwucGFyc2UodGhpcy5faXNzdWVyLmlzc3VlcikuaG9zdG5hbWV9YDtcbiAgdGhpcy5fcGFyYW1zID0gY2xvbmVEZWVwKHBhcmFtcyk7XG5cbiAgLy8gc3RhdGUgYW5kIG5vbmNlIGFyZSBoYW5kbGVkIGluIGF1dGhlbnRpY2F0ZSgpXG4gIGRlbGV0ZSB0aGlzLl9wYXJhbXMuc3RhdGU7XG4gIGRlbGV0ZSB0aGlzLl9wYXJhbXMubm9uY2U7XG5cbiAgdGhpcy5fZXh0cmFzID0gY2xvbmVEZWVwKGV4dHJhcyk7XG5cbiAgaWYgKCF0aGlzLl9wYXJhbXMucmVzcG9uc2VfdHlwZSkgdGhpcy5fcGFyYW1zLnJlc3BvbnNlX3R5cGUgPSByZXNvbHZlUmVzcG9uc2VUeXBlLmNhbGwoY2xpZW50KTtcbiAgaWYgKCF0aGlzLl9wYXJhbXMucmVkaXJlY3RfdXJpKSB0aGlzLl9wYXJhbXMucmVkaXJlY3RfdXJpID0gcmVzb2x2ZVJlZGlyZWN0VXJpLmNhbGwoY2xpZW50KTtcbiAgaWYgKCF0aGlzLl9wYXJhbXMuc2NvcGUpIHRoaXMuX3BhcmFtcy5zY29wZSA9ICdvcGVuaWQnO1xuXG4gIGlmICh0aGlzLl91c2VQS0NFID09PSB0cnVlKSB7XG4gICAgY29uc3Qgc3VwcG9ydGVkTWV0aG9kcyA9IEFycmF5LmlzQXJyYXkodGhpcy5faXNzdWVyLmNvZGVfY2hhbGxlbmdlX21ldGhvZHNfc3VwcG9ydGVkKVxuICAgICAgPyB0aGlzLl9pc3N1ZXIuY29kZV9jaGFsbGVuZ2VfbWV0aG9kc19zdXBwb3J0ZWRcbiAgICAgIDogZmFsc2U7XG5cbiAgICBpZiAoc3VwcG9ydGVkTWV0aG9kcyAmJiBzdXBwb3J0ZWRNZXRob2RzLmluY2x1ZGVzKCdTMjU2JykpIHtcbiAgICAgIHRoaXMuX3VzZVBLQ0UgPSAnUzI1Nic7XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0ZWRNZXRob2RzICYmIHN1cHBvcnRlZE1ldGhvZHMuaW5jbHVkZXMoJ3BsYWluJykpIHtcbiAgICAgIHRoaXMuX3VzZVBLQ0UgPSAncGxhaW4nO1xuICAgIH0gZWxzZSBpZiAoc3VwcG9ydGVkTWV0aG9kcykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ25laXRoZXIgY29kZV9jaGFsbGVuZ2VfbWV0aG9kIHN1cHBvcnRlZCBieSB0aGUgY2xpZW50IGlzIHN1cHBvcnRlZCBieSB0aGUgaXNzdWVyJyxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VzZVBLQ0UgPSAnUzI1Nic7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl91c2VQS0NFID09PSAnc3RyaW5nJyAmJiAhWydwbGFpbicsICdTMjU2J10uaW5jbHVkZXModGhpcy5fdXNlUEtDRSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3RoaXMuX3VzZVBLQ0V9IGlzIG5vdCB2YWxpZC9pbXBsZW1lbnRlZCBQS0NFIGNvZGVfY2hhbGxlbmdlX21ldGhvZGApO1xuICB9XG5cbiAgdGhpcy5uYW1lID0gdXJsLnBhcnNlKGNsaWVudC5pc3N1ZXIuaXNzdWVyKS5ob3N0bmFtZTtcbn1cblxuT3BlbklEQ29ubmVjdFN0cmF0ZWd5LnByb3RvdHlwZS5hdXRoZW50aWNhdGUgPSBmdW5jdGlvbiBhdXRoZW50aWNhdGUocmVxLCBvcHRpb25zKSB7XG4gIChhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5fY2xpZW50O1xuICAgIGlmICghcmVxLnNlc3Npb24pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F1dGhlbnRpY2F0aW9uIHJlcXVpcmVzIHNlc3Npb24gc3VwcG9ydCcpO1xuICAgIH1cbiAgICBjb25zdCByZXFQYXJhbXMgPSBjbGllbnQuY2FsbGJhY2tQYXJhbXMocmVxKTtcbiAgICBjb25zdCBzZXNzaW9uS2V5ID0gdGhpcy5fa2V5O1xuXG4gICAgY29uc3QgeyAwOiBwYXJhbWV0ZXIsIGxlbmd0aCB9ID0gT2JqZWN0LmtleXMocmVxUGFyYW1zKTtcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGF1dGhlbnRpY2F0aW9uIHJlcXVlc3QgaWYgdGhpcyBoYXMgbm8gYXV0aG9yaXphdGlvbiByZXNwb25zZSBwYXJhbWV0ZXJzIG9yXG4gICAgICogdGhpcyBtaWdodCBhIGxvZ2luIGluaXRpYXRlZCBmcm9tIGEgdGhpcmQgcGFydHkgYXMgcGVyXG4gICAgICogaHR0cHM6Ly9vcGVuaWQubmV0L3NwZWNzL29wZW5pZC1jb25uZWN0LWNvcmUtMV8wLmh0bWwjVGhpcmRQYXJ0eUluaXRpYXRlZExvZ2luLlxuICAgICAqL1xuICAgIGlmIChsZW5ndGggPT09IDAgfHwgKGxlbmd0aCA9PT0gMSAmJiBwYXJhbWV0ZXIgPT09ICdpc3MnKSkge1xuICAgICAgLy8gcHJvdmlkZSBvcHRpb25zIG9iamVjdCB3aXRoIGV4dHJhIGF1dGhlbnRpY2F0aW9uIHBhcmFtZXRlcnNcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgc3RhdGU6IHJhbmRvbSgpLFxuICAgICAgICAuLi50aGlzLl9wYXJhbXMsXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB9O1xuXG4gICAgICBpZiAoIXBhcmFtcy5ub25jZSAmJiBwYXJhbXMucmVzcG9uc2VfdHlwZS5pbmNsdWRlcygnaWRfdG9rZW4nKSkge1xuICAgICAgICBwYXJhbXMubm9uY2UgPSByYW5kb20oKTtcbiAgICAgIH1cblxuICAgICAgcmVxLnNlc3Npb25bc2Vzc2lvbktleV0gPSBwaWNrKHBhcmFtcywgJ25vbmNlJywgJ3N0YXRlJywgJ21heF9hZ2UnLCAncmVzcG9uc2VfdHlwZScpO1xuXG4gICAgICBpZiAodGhpcy5fdXNlUEtDRSAmJiBwYXJhbXMucmVzcG9uc2VfdHlwZS5pbmNsdWRlcygnY29kZScpKSB7XG4gICAgICAgIGNvbnN0IHZlcmlmaWVyID0gcmFuZG9tKCk7XG4gICAgICAgIHJlcS5zZXNzaW9uW3Nlc3Npb25LZXldLmNvZGVfdmVyaWZpZXIgPSB2ZXJpZmllcjtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMuX3VzZVBLQ0UpIHtcbiAgICAgICAgICBjYXNlICdTMjU2JzpcbiAgICAgICAgICAgIHBhcmFtcy5jb2RlX2NoYWxsZW5nZSA9IGNvZGVDaGFsbGVuZ2UodmVyaWZpZXIpO1xuICAgICAgICAgICAgcGFyYW1zLmNvZGVfY2hhbGxlbmdlX21ldGhvZCA9ICdTMjU2JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3BsYWluJzpcbiAgICAgICAgICAgIHBhcmFtcy5jb2RlX2NoYWxsZW5nZSA9IHZlcmlmaWVyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5yZWRpcmVjdChjbGllbnQuYXV0aG9yaXphdGlvblVybChwYXJhbXMpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyogZW5kIGF1dGhlbnRpY2F0aW9uIHJlcXVlc3QgKi9cblxuICAgIC8qIHN0YXJ0IGF1dGhlbnRpY2F0aW9uIHJlc3BvbnNlICovXG5cbiAgICBjb25zdCBzZXNzaW9uID0gcmVxLnNlc3Npb25bc2Vzc2lvbktleV07XG4gICAgaWYgKE9iamVjdC5rZXlzKHNlc3Npb24gfHwge30pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBmb3JtYXQoXG4gICAgICAgICAgJ2RpZCBub3QgZmluZCBleHBlY3RlZCBhdXRob3JpemF0aW9uIHJlcXVlc3QgZGV0YWlscyBpbiBzZXNzaW9uLCByZXEuc2Vzc2lvbltcIiVzXCJdIGlzICVqJyxcbiAgICAgICAgICBzZXNzaW9uS2V5LFxuICAgICAgICAgIHNlc3Npb24sXG4gICAgICAgICksXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIHN0YXRlLFxuICAgICAgbm9uY2UsXG4gICAgICBtYXhfYWdlOiBtYXhBZ2UsXG4gICAgICBjb2RlX3ZlcmlmaWVyOiBjb2RlVmVyaWZpZXIsXG4gICAgICByZXNwb25zZV90eXBlOiByZXNwb25zZVR5cGUsXG4gICAgfSA9IHNlc3Npb247XG5cbiAgICB0cnkge1xuICAgICAgZGVsZXRlIHJlcS5zZXNzaW9uW3Nlc3Npb25LZXldO1xuICAgIH0gY2F0Y2ggKGVycikge31cblxuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICByZWRpcmVjdF91cmk6IHRoaXMuX3BhcmFtcy5yZWRpcmVjdF91cmksXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH07XG5cbiAgICBjb25zdCBjaGVja3MgPSB7XG4gICAgICBzdGF0ZSxcbiAgICAgIG5vbmNlLFxuICAgICAgbWF4X2FnZTogbWF4QWdlLFxuICAgICAgY29kZV92ZXJpZmllcjogY29kZVZlcmlmaWVyLFxuICAgICAgcmVzcG9uc2VfdHlwZTogcmVzcG9uc2VUeXBlLFxuICAgIH07XG5cbiAgICBjb25zdCB0b2tlbnNldCA9IGF3YWl0IGNsaWVudC5jYWxsYmFjayhvcHRzLnJlZGlyZWN0X3VyaSwgcmVxUGFyYW1zLCBjaGVja3MsIHRoaXMuX2V4dHJhcyk7XG5cbiAgICBjb25zdCBwYXNzUmVxID0gdGhpcy5fcGFzc1JlcVRvQ2FsbGJhY2s7XG4gICAgY29uc3QgbG9hZFVzZXJpbmZvID0gdGhpcy5fdmVyaWZ5Lmxlbmd0aCA+IChwYXNzUmVxID8gMyA6IDIpICYmIGNsaWVudC5pc3N1ZXIudXNlcmluZm9fZW5kcG9pbnQ7XG5cbiAgICBjb25zdCBhcmdzID0gW3Rva2Vuc2V0LCB2ZXJpZmllZC5iaW5kKHRoaXMpXTtcblxuICAgIGlmIChsb2FkVXNlcmluZm8pIHtcbiAgICAgIGlmICghdG9rZW5zZXQuYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgIHRocm93IG5ldyBSUEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgJ2V4cGVjdGVkIGFjY2Vzc190b2tlbiB0byBiZSByZXR1cm5lZCB3aGVuIGFza2luZyBmb3IgdXNlcmluZm8gaW4gdmVyaWZ5IGNhbGxiYWNrJyxcbiAgICAgICAgICB0b2tlbnNldCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCB1c2VyaW5mbyA9IGF3YWl0IGNsaWVudC51c2VyaW5mbyh0b2tlbnNldCk7XG4gICAgICBhcmdzLnNwbGljZSgxLCAwLCB1c2VyaW5mbyk7XG4gICAgfVxuXG4gICAgaWYgKHBhc3NSZXEpIHtcbiAgICAgIGFyZ3MudW5zaGlmdChyZXEpO1xuICAgIH1cblxuICAgIHRoaXMuX3ZlcmlmeSguLi5hcmdzKTtcbiAgICAvKiBlbmQgYXV0aGVudGljYXRpb24gcmVzcG9uc2UgKi9cbiAgfSkoKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICBpZiAoXG4gICAgICAoZXJyb3IgaW5zdGFuY2VvZiBPUEVycm9yICYmXG4gICAgICAgIGVycm9yLmVycm9yICE9PSAnc2VydmVyX2Vycm9yJyAmJlxuICAgICAgICAhZXJyb3IuZXJyb3Iuc3RhcnRzV2l0aCgnaW52YWxpZCcpKSB8fFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBSUEVycm9yXG4gICAgKSB7XG4gICAgICB0aGlzLmZhaWwoZXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPcGVuSURDb25uZWN0U3RyYXRlZ3k7XG4iXSwibmFtZXMiOlsidXJsIiwicmVxdWlyZSIsImZvcm1hdCIsImNsb25lRGVlcCIsIlJQRXJyb3IiLCJPUEVycm9yIiwiQmFzZUNsaWVudCIsInJhbmRvbSIsImNvZGVDaGFsbGVuZ2UiLCJwaWNrIiwicmVzb2x2ZVJlc3BvbnNlVHlwZSIsInJlc29sdmVSZWRpcmVjdFVyaSIsInZlcmlmaWVkIiwiZXJyIiwidXNlciIsImluZm8iLCJlcnJvciIsImZhaWwiLCJzdWNjZXNzIiwiT3BlbklEQ29ubmVjdFN0cmF0ZWd5IiwiY2xpZW50IiwicGFyYW1zIiwicGFzc1JlcVRvQ2FsbGJhY2siLCJzZXNzaW9uS2V5IiwidXNlUEtDRSIsImV4dHJhcyIsInZlcmlmeSIsIlR5cGVFcnJvciIsImlzc3VlciIsIl9jbGllbnQiLCJfaXNzdWVyIiwiX3ZlcmlmeSIsIl9wYXNzUmVxVG9DYWxsYmFjayIsIl91c2VQS0NFIiwiX2tleSIsInBhcnNlIiwiaG9zdG5hbWUiLCJfcGFyYW1zIiwic3RhdGUiLCJub25jZSIsIl9leHRyYXMiLCJyZXNwb25zZV90eXBlIiwiY2FsbCIsInJlZGlyZWN0X3VyaSIsInNjb3BlIiwic3VwcG9ydGVkTWV0aG9kcyIsIkFycmF5IiwiaXNBcnJheSIsImNvZGVfY2hhbGxlbmdlX21ldGhvZHNfc3VwcG9ydGVkIiwiaW5jbHVkZXMiLCJuYW1lIiwicHJvdG90eXBlIiwiYXV0aGVudGljYXRlIiwicmVxIiwib3B0aW9ucyIsInNlc3Npb24iLCJyZXFQYXJhbXMiLCJjYWxsYmFja1BhcmFtcyIsInBhcmFtZXRlciIsImxlbmd0aCIsIk9iamVjdCIsImtleXMiLCJ2ZXJpZmllciIsImNvZGVfdmVyaWZpZXIiLCJjb2RlX2NoYWxsZW5nZSIsImNvZGVfY2hhbGxlbmdlX21ldGhvZCIsInJlZGlyZWN0IiwiYXV0aG9yaXphdGlvblVybCIsIkVycm9yIiwibWF4X2FnZSIsIm1heEFnZSIsImNvZGVWZXJpZmllciIsInJlc3BvbnNlVHlwZSIsIm9wdHMiLCJjaGVja3MiLCJ0b2tlbnNldCIsImNhbGxiYWNrIiwicGFzc1JlcSIsImxvYWRVc2VyaW5mbyIsInVzZXJpbmZvX2VuZHBvaW50IiwiYXJncyIsImJpbmQiLCJhY2Nlc3NfdG9rZW4iLCJtZXNzYWdlIiwidXNlcmluZm8iLCJzcGxpY2UiLCJ1bnNoaWZ0IiwiY2F0Y2giLCJzdGFydHNXaXRoIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/passport_strategy.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/lib/token_set.js":
/*!******************************************************!*\
  !*** ../node_modules/openid-client/lib/token_set.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst base64url = __webpack_require__(/*! ./helpers/base64url */ \"(rsc)/../node_modules/openid-client/lib/helpers/base64url.js\");\nconst now = __webpack_require__(/*! ./helpers/unix_timestamp */ \"(rsc)/../node_modules/openid-client/lib/helpers/unix_timestamp.js\");\nclass TokenSet {\n    constructor(values){\n        Object.assign(this, values);\n        const { constructor, ...properties } = Object.getOwnPropertyDescriptors(this.constructor.prototype);\n        Object.defineProperties(this, properties);\n    }\n    set expires_in(value) {\n        this.expires_at = now() + Number(value);\n    }\n    get expires_in() {\n        return Math.max.apply(null, [\n            this.expires_at - now(),\n            0\n        ]);\n    }\n    expired() {\n        return this.expires_in === 0;\n    }\n    claims() {\n        if (!this.id_token) {\n            throw new TypeError(\"id_token not present in TokenSet\");\n        }\n        return JSON.parse(base64url.decode(this.id_token.split(\".\")[1]));\n    }\n}\nmodule.exports = TokenSet;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvbGliL3Rva2VuX3NldC5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTUEsWUFBWUMsbUJBQU9BLENBQUM7QUFDMUIsTUFBTUMsTUFBTUQsbUJBQU9BLENBQUM7QUFFcEIsTUFBTUU7SUFDSkMsWUFBWUMsTUFBTSxDQUFFO1FBQ2xCQyxPQUFPQyxNQUFNLENBQUMsSUFBSSxFQUFFRjtRQUNwQixNQUFNLEVBQUVELFdBQVcsRUFBRSxHQUFHSSxZQUFZLEdBQUdGLE9BQU9HLHlCQUF5QixDQUNyRSxJQUFJLENBQUNMLFdBQVcsQ0FBQ00sU0FBUztRQUc1QkosT0FBT0ssZ0JBQWdCLENBQUMsSUFBSSxFQUFFSDtJQUNoQztJQUVBLElBQUlJLFdBQVdDLEtBQUssRUFBRTtRQUNwQixJQUFJLENBQUNDLFVBQVUsR0FBR1osUUFBUWEsT0FBT0Y7SUFDbkM7SUFFQSxJQUFJRCxhQUFhO1FBQ2YsT0FBT0ksS0FBS0MsR0FBRyxDQUFDQyxLQUFLLENBQUMsTUFBTTtZQUFDLElBQUksQ0FBQ0osVUFBVSxHQUFHWjtZQUFPO1NBQUU7SUFDMUQ7SUFFQWlCLFVBQVU7UUFDUixPQUFPLElBQUksQ0FBQ1AsVUFBVSxLQUFLO0lBQzdCO0lBRUFRLFNBQVM7UUFDUCxJQUFJLENBQUMsSUFBSSxDQUFDQyxRQUFRLEVBQUU7WUFDbEIsTUFBTSxJQUFJQyxVQUFVO1FBQ3RCO1FBRUEsT0FBT0MsS0FBS0MsS0FBSyxDQUFDeEIsVUFBVXlCLE1BQU0sQ0FBQyxJQUFJLENBQUNKLFFBQVEsQ0FBQ0ssS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO0lBQ2hFO0FBQ0Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lZHN1LWhvdXNlLXB1YmxpYy8uLi9ub2RlX21vZHVsZXMvb3BlbmlkLWNsaWVudC9saWIvdG9rZW5fc2V0LmpzPzYwOTMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYmFzZTY0dXJsID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Jhc2U2NHVybCcpO1xuY29uc3Qgbm93ID0gcmVxdWlyZSgnLi9oZWxwZXJzL3VuaXhfdGltZXN0YW1wJyk7XG5cbmNsYXNzIFRva2VuU2V0IHtcbiAgY29uc3RydWN0b3IodmFsdWVzKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCB2YWx1ZXMpO1xuICAgIGNvbnN0IHsgY29uc3RydWN0b3IsIC4uLnByb3BlcnRpZXMgfSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKFxuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsXG4gICAgKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHByb3BlcnRpZXMpO1xuICB9XG5cbiAgc2V0IGV4cGlyZXNfaW4odmFsdWUpIHtcbiAgICB0aGlzLmV4cGlyZXNfYXQgPSBub3coKSArIE51bWJlcih2YWx1ZSk7XG4gIH1cblxuICBnZXQgZXhwaXJlc19pbigpIHtcbiAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgW3RoaXMuZXhwaXJlc19hdCAtIG5vdygpLCAwXSk7XG4gIH1cblxuICBleHBpcmVkKCkge1xuICAgIHJldHVybiB0aGlzLmV4cGlyZXNfaW4gPT09IDA7XG4gIH1cblxuICBjbGFpbXMoKSB7XG4gICAgaWYgKCF0aGlzLmlkX3Rva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpZF90b2tlbiBub3QgcHJlc2VudCBpbiBUb2tlblNldCcpO1xuICAgIH1cblxuICAgIHJldHVybiBKU09OLnBhcnNlKGJhc2U2NHVybC5kZWNvZGUodGhpcy5pZF90b2tlbi5zcGxpdCgnLicpWzFdKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUb2tlblNldDtcbiJdLCJuYW1lcyI6WyJiYXNlNjR1cmwiLCJyZXF1aXJlIiwibm93IiwiVG9rZW5TZXQiLCJjb25zdHJ1Y3RvciIsInZhbHVlcyIsIk9iamVjdCIsImFzc2lnbiIsInByb3BlcnRpZXMiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwicHJvdG90eXBlIiwiZGVmaW5lUHJvcGVydGllcyIsImV4cGlyZXNfaW4iLCJ2YWx1ZSIsImV4cGlyZXNfYXQiLCJOdW1iZXIiLCJNYXRoIiwibWF4IiwiYXBwbHkiLCJleHBpcmVkIiwiY2xhaW1zIiwiaWRfdG9rZW4iLCJUeXBlRXJyb3IiLCJKU09OIiwicGFyc2UiLCJkZWNvZGUiLCJzcGxpdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/openid-client/lib/token_set.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/openid-client/package.json":
/*!**************************************************!*\
  !*** ../node_modules/openid-client/package.json ***!
  \**************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"openid-client","version":"5.7.1","description":"OpenID Connect Relying Party (RP, Client) implementation for Node.js runtime, supports passportjs","keywords":["auth","authentication","basic","certified","client","connect","dynamic","electron","hybrid","identity","implicit","oauth","oauth2","oidc","openid","passport","relying party","strategy"],"homepage":"https://github.com/panva/openid-client","repository":"panva/openid-client","funding":{"url":"https://github.com/sponsors/panva"},"license":"MIT","author":"Filip Skokan <panva.ip@gmail.com>","exports":{"types":"./types/index.d.ts","import":"./lib/index.mjs","require":"./lib/index.js"},"main":"./lib/index.js","types":"./types/index.d.ts","files":["lib","types/index.d.ts"],"scripts":{"format":"npx prettier --loglevel silent --write ./lib ./test ./certification ./types","test":"mocha test/**/*.test.js"},"dependencies":{"jose":"^4.15.9","lru-cache":"^6.0.0","object-hash":"^2.2.0","oidc-token-hash":"^5.0.3"},"devDependencies":{"@types/node":"^16.18.106","@types/passport":"^1.0.16","base64url":"^3.0.1","chai":"^4.5.0","mocha":"^10.7.3","nock":"^13.5.5","prettier":"^2.8.8","readable-mock-req":"^0.2.2","sinon":"^9.2.4","timekeeper":"^2.3.1"},"standard-version":{"scripts":{"postchangelog":"sed -i \'\' -e \'s/### \\\\[/## [/g\' CHANGELOG.md"},"types":[{"type":"feat","section":"Features"},{"type":"fix","section":"Fixes"},{"type":"chore","hidden":true},{"type":"docs","hidden":true},{"type":"style","hidden":true},{"type":"refactor","section":"Refactor","hidden":false},{"type":"perf","section":"Performance","hidden":false},{"type":"test","hidden":true}]}}');

/***/ })

};
;